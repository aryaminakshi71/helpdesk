{
  "version": 3,
  "sources": ["../../../../../node_modules/.bun/better-auth@1.4.14+cf5dc576ad9023b2/node_modules/better-auth/src/adapters/drizzle-adapter/drizzle-adapter.ts"],
  "sourcesContent": ["import type { BetterAuthOptions } from \"@better-auth/core\";\nimport type {\n\tAdapterFactoryCustomizeAdapterCreator,\n\tAdapterFactoryOptions,\n\tDBAdapter,\n\tDBAdapterDebugLogOption,\n\tWhere,\n} from \"@better-auth/core/db/adapter\";\nimport { createAdapterFactory } from \"@better-auth/core/db/adapter\";\nimport { logger } from \"@better-auth/core/env\";\nimport { BetterAuthError } from \"@better-auth/core/error\";\nimport type { SQL } from \"drizzle-orm\";\nimport {\n\tand,\n\tasc,\n\tcount,\n\tdesc,\n\teq,\n\tgt,\n\tgte,\n\tinArray,\n\tlike,\n\tlt,\n\tlte,\n\tne,\n\tnotInArray,\n\tor,\n\tsql,\n} from \"drizzle-orm\";\n\nexport interface DB {\n\t[key: string]: any;\n}\n\nexport interface DrizzleAdapterConfig {\n\t/**\n\t * The schema object that defines the tables and fields\n\t */\n\tschema?: Record<string, any> | undefined;\n\t/**\n\t * The database provider\n\t */\n\tprovider: \"pg\" | \"mysql\" | \"sqlite\";\n\t/**\n\t * If the table names in the schema are plural\n\t * set this to true. For example, if the schema\n\t * has an object with a key \"users\" instead of \"user\"\n\t */\n\tusePlural?: boolean | undefined;\n\t/**\n\t * Enable debug logs for the adapter\n\t *\n\t * @default false\n\t */\n\tdebugLogs?: DBAdapterDebugLogOption | undefined;\n\t/**\n\t * By default snake case is used for table and field names\n\t * when the CLI is used to generate the schema. If you want\n\t * to use camel case, set this to true.\n\t * @default false\n\t */\n\tcamelCase?: boolean | undefined;\n\t/**\n\t * Whether to execute multiple operations in a transaction.\n\t *\n\t * If the database doesn't support transactions,\n\t * set this to `false` and operations will be executed sequentially.\n\t * @default false\n\t */\n\ttransaction?: boolean | undefined;\n}\n\nexport const drizzleAdapter = (db: DB, config: DrizzleAdapterConfig) => {\n\tlet lazyOptions: BetterAuthOptions | null = null;\n\tconst createCustomAdapter =\n\t\t(db: DB): AdapterFactoryCustomizeAdapterCreator =>\n\t\t({ getFieldName, options }) => {\n\t\t\tfunction getSchema(model: string) {\n\t\t\t\tconst schema = config.schema || db._.fullSchema;\n\t\t\t\tif (!schema) {\n\t\t\t\t\tthrow new BetterAuthError(\n\t\t\t\t\t\t\"Drizzle adapter failed to initialize. Schema not found. Please provide a schema object in the adapter options object.\",\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\tconst schemaModel = schema[model];\n\t\t\t\tif (!schemaModel) {\n\t\t\t\t\tthrow new BetterAuthError(\n\t\t\t\t\t\t`[# Drizzle Adapter]: The model \"${model}\" was not found in the schema object. Please pass the schema directly to the adapter options.`,\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\treturn schemaModel;\n\t\t\t}\n\t\t\tconst withReturning = async (\n\t\t\t\tmodel: string,\n\t\t\t\tbuilder: any,\n\t\t\t\tdata: Record<string, any>,\n\t\t\t\twhere?: Where[] | undefined,\n\t\t\t) => {\n\t\t\t\tif (config.provider !== \"mysql\") {\n\t\t\t\t\tconst c = await builder.returning();\n\t\t\t\t\treturn c[0];\n\t\t\t\t}\n\t\t\t\tawait builder.execute();\n\t\t\t\tconst schemaModel = getSchema(model);\n\t\t\t\tconst builderVal = builder.config?.values;\n\t\t\t\tif (where?.length) {\n\t\t\t\t\t// If we're updating a field that's in the where clause, use the new value\n\t\t\t\t\tconst updatedWhere = where.map((w) => {\n\t\t\t\t\t\t// If this field was updated, use the new value for lookup\n\t\t\t\t\t\tif (data[w.field] !== undefined) {\n\t\t\t\t\t\t\treturn { ...w, value: data[w.field] };\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn w;\n\t\t\t\t\t});\n\n\t\t\t\t\tconst clause = convertWhereClause(updatedWhere, model);\n\t\t\t\t\tconst res = await db\n\t\t\t\t\t\t.select()\n\t\t\t\t\t\t.from(schemaModel)\n\t\t\t\t\t\t.where(...clause);\n\t\t\t\t\treturn res[0];\n\t\t\t\t} else if (builderVal && builderVal[0]?.id?.value) {\n\t\t\t\t\tlet tId = builderVal[0]?.id?.value;\n\t\t\t\t\tif (!tId) {\n\t\t\t\t\t\t//get last inserted id\n\t\t\t\t\t\tconst lastInsertId = await db\n\t\t\t\t\t\t\t.select({ id: sql`LAST_INSERT_ID()` })\n\t\t\t\t\t\t\t.from(schemaModel)\n\t\t\t\t\t\t\t.orderBy(desc(schemaModel.id))\n\t\t\t\t\t\t\t.limit(1);\n\t\t\t\t\t\ttId = lastInsertId[0].id;\n\t\t\t\t\t}\n\t\t\t\t\tconst res = await db\n\t\t\t\t\t\t.select()\n\t\t\t\t\t\t.from(schemaModel)\n\t\t\t\t\t\t.where(eq(schemaModel.id, tId))\n\t\t\t\t\t\t.limit(1)\n\t\t\t\t\t\t.execute();\n\t\t\t\t\treturn res[0];\n\t\t\t\t} else if (data.id) {\n\t\t\t\t\tconst res = await db\n\t\t\t\t\t\t.select()\n\t\t\t\t\t\t.from(schemaModel)\n\t\t\t\t\t\t.where(eq(schemaModel.id, data.id))\n\t\t\t\t\t\t.limit(1)\n\t\t\t\t\t\t.execute();\n\t\t\t\t\treturn res[0];\n\t\t\t\t} else {\n\t\t\t\t\t// If the user doesn't have `id` as a field, then this will fail.\n\t\t\t\t\t// We expect that they defined `id` in all of their models.\n\t\t\t\t\tif (!(\"id\" in schemaModel)) {\n\t\t\t\t\t\tthrow new BetterAuthError(\n\t\t\t\t\t\t\t`The model \"${model}\" does not have an \"id\" field. Please use the \"id\" field as your primary key.`,\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t\tconst res = await db\n\t\t\t\t\t\t.select()\n\t\t\t\t\t\t.from(schemaModel)\n\t\t\t\t\t\t.orderBy(desc(schemaModel.id))\n\t\t\t\t\t\t.limit(1)\n\t\t\t\t\t\t.execute();\n\t\t\t\t\treturn res[0];\n\t\t\t\t}\n\t\t\t};\n\t\t\tfunction convertWhereClause(where: Where[], model: string) {\n\t\t\t\tconst schemaModel = getSchema(model);\n\t\t\t\tif (!where) return [];\n\t\t\t\tif (where.length === 1) {\n\t\t\t\t\tconst w = where[0];\n\t\t\t\t\tif (!w) {\n\t\t\t\t\t\treturn [];\n\t\t\t\t\t}\n\t\t\t\t\tconst field = getFieldName({ model, field: w.field });\n\t\t\t\t\tif (!schemaModel[field]) {\n\t\t\t\t\t\tthrow new BetterAuthError(\n\t\t\t\t\t\t\t`The field \"${w.field}\" does not exist in the schema for the model \"${model}\". Please update your schema.`,\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t\tif (w.operator === \"in\") {\n\t\t\t\t\t\tif (!Array.isArray(w.value)) {\n\t\t\t\t\t\t\tthrow new BetterAuthError(\n\t\t\t\t\t\t\t\t`The value for the field \"${w.field}\" must be an array when using the \"in\" operator.`,\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn [inArray(schemaModel[field], w.value)];\n\t\t\t\t\t}\n\n\t\t\t\t\tif (w.operator === \"not_in\") {\n\t\t\t\t\t\tif (!Array.isArray(w.value)) {\n\t\t\t\t\t\t\tthrow new BetterAuthError(\n\t\t\t\t\t\t\t\t`The value for the field \"${w.field}\" must be an array when using the \"not_in\" operator.`,\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn [notInArray(schemaModel[field], w.value)];\n\t\t\t\t\t}\n\n\t\t\t\t\tif (w.operator === \"contains\") {\n\t\t\t\t\t\treturn [like(schemaModel[field], `%${w.value}%`)];\n\t\t\t\t\t}\n\n\t\t\t\t\tif (w.operator === \"starts_with\") {\n\t\t\t\t\t\treturn [like(schemaModel[field], `${w.value}%`)];\n\t\t\t\t\t}\n\n\t\t\t\t\tif (w.operator === \"ends_with\") {\n\t\t\t\t\t\treturn [like(schemaModel[field], `%${w.value}`)];\n\t\t\t\t\t}\n\n\t\t\t\t\tif (w.operator === \"lt\") {\n\t\t\t\t\t\treturn [lt(schemaModel[field], w.value)];\n\t\t\t\t\t}\n\n\t\t\t\t\tif (w.operator === \"lte\") {\n\t\t\t\t\t\treturn [lte(schemaModel[field], w.value)];\n\t\t\t\t\t}\n\n\t\t\t\t\tif (w.operator === \"ne\") {\n\t\t\t\t\t\treturn [ne(schemaModel[field], w.value)];\n\t\t\t\t\t}\n\n\t\t\t\t\tif (w.operator === \"gt\") {\n\t\t\t\t\t\treturn [gt(schemaModel[field], w.value)];\n\t\t\t\t\t}\n\n\t\t\t\t\tif (w.operator === \"gte\") {\n\t\t\t\t\t\treturn [gte(schemaModel[field], w.value)];\n\t\t\t\t\t}\n\n\t\t\t\t\treturn [eq(schemaModel[field], w.value)];\n\t\t\t\t}\n\t\t\t\tconst andGroup = where.filter(\n\t\t\t\t\t(w) => w.connector === \"AND\" || !w.connector,\n\t\t\t\t);\n\t\t\t\tconst orGroup = where.filter((w) => w.connector === \"OR\");\n\n\t\t\t\tconst andClause = and(\n\t\t\t\t\t...andGroup.map((w) => {\n\t\t\t\t\t\tconst field = getFieldName({ model, field: w.field });\n\t\t\t\t\t\tif (w.operator === \"in\") {\n\t\t\t\t\t\t\tif (!Array.isArray(w.value)) {\n\t\t\t\t\t\t\t\tthrow new BetterAuthError(\n\t\t\t\t\t\t\t\t\t`The value for the field \"${w.field}\" must be an array when using the \"in\" operator.`,\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn inArray(schemaModel[field], w.value);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (w.operator === \"not_in\") {\n\t\t\t\t\t\t\tif (!Array.isArray(w.value)) {\n\t\t\t\t\t\t\t\tthrow new BetterAuthError(\n\t\t\t\t\t\t\t\t\t`The value for the field \"${w.field}\" must be an array when using the \"not_in\" operator.`,\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn notInArray(schemaModel[field], w.value);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (w.operator === \"contains\") {\n\t\t\t\t\t\t\treturn like(schemaModel[field], `%${w.value}%`);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (w.operator === \"starts_with\") {\n\t\t\t\t\t\t\treturn like(schemaModel[field], `${w.value}%`);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (w.operator === \"ends_with\") {\n\t\t\t\t\t\t\treturn like(schemaModel[field], `%${w.value}`);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (w.operator === \"lt\") {\n\t\t\t\t\t\t\treturn lt(schemaModel[field], w.value);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (w.operator === \"lte\") {\n\t\t\t\t\t\t\treturn lte(schemaModel[field], w.value);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (w.operator === \"gt\") {\n\t\t\t\t\t\t\treturn gt(schemaModel[field], w.value);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (w.operator === \"gte\") {\n\t\t\t\t\t\t\treturn gte(schemaModel[field], w.value);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (w.operator === \"ne\") {\n\t\t\t\t\t\t\treturn ne(schemaModel[field], w.value);\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn eq(schemaModel[field], w.value);\n\t\t\t\t\t}),\n\t\t\t\t);\n\t\t\t\tconst orClause = or(\n\t\t\t\t\t...orGroup.map((w) => {\n\t\t\t\t\t\tconst field = getFieldName({ model, field: w.field });\n\t\t\t\t\t\tif (w.operator === \"in\") {\n\t\t\t\t\t\t\tif (!Array.isArray(w.value)) {\n\t\t\t\t\t\t\t\tthrow new BetterAuthError(\n\t\t\t\t\t\t\t\t\t`The value for the field \"${w.field}\" must be an array when using the \"in\" operator.`,\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn inArray(schemaModel[field], w.value);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (w.operator === \"not_in\") {\n\t\t\t\t\t\t\tif (!Array.isArray(w.value)) {\n\t\t\t\t\t\t\t\tthrow new BetterAuthError(\n\t\t\t\t\t\t\t\t\t`The value for the field \"${w.field}\" must be an array when using the \"not_in\" operator.`,\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn notInArray(schemaModel[field], w.value);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (w.operator === \"contains\") {\n\t\t\t\t\t\t\treturn like(schemaModel[field], `%${w.value}%`);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (w.operator === \"starts_with\") {\n\t\t\t\t\t\t\treturn like(schemaModel[field], `${w.value}%`);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (w.operator === \"ends_with\") {\n\t\t\t\t\t\t\treturn like(schemaModel[field], `%${w.value}`);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (w.operator === \"lt\") {\n\t\t\t\t\t\t\treturn lt(schemaModel[field], w.value);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (w.operator === \"lte\") {\n\t\t\t\t\t\t\treturn lte(schemaModel[field], w.value);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (w.operator === \"gt\") {\n\t\t\t\t\t\t\treturn gt(schemaModel[field], w.value);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (w.operator === \"gte\") {\n\t\t\t\t\t\t\treturn gte(schemaModel[field], w.value);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (w.operator === \"ne\") {\n\t\t\t\t\t\t\treturn ne(schemaModel[field], w.value);\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn eq(schemaModel[field], w.value);\n\t\t\t\t\t}),\n\t\t\t\t);\n\n\t\t\t\tconst clause: SQL<unknown>[] = [];\n\n\t\t\t\tif (andGroup.length) clause.push(andClause!);\n\t\t\t\tif (orGroup.length) clause.push(orClause!);\n\t\t\t\treturn clause;\n\t\t\t}\n\t\t\tfunction checkMissingFields(\n\t\t\t\tschema: Record<string, any>,\n\t\t\t\tmodel: string,\n\t\t\t\tvalues: Record<string, any>,\n\t\t\t) {\n\t\t\t\tif (!schema) {\n\t\t\t\t\tthrow new BetterAuthError(\n\t\t\t\t\t\t\"Drizzle adapter failed to initialize. Drizzle Schema not found. Please provide a schema object in the adapter options object.\",\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\tfor (const key in values) {\n\t\t\t\t\tif (!schema[key]) {\n\t\t\t\t\t\tthrow new BetterAuthError(\n\t\t\t\t\t\t\t`The field \"${key}\" does not exist in the \"${model}\" Drizzle schema. Please update your drizzle schema or re-generate using \"npx @better-auth/cli@latest generate\".`,\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\tasync create({ model, data: values }) {\n\t\t\t\t\tconst schemaModel = getSchema(model);\n\t\t\t\t\tcheckMissingFields(schemaModel, model, values);\n\t\t\t\t\tconst builder = db.insert(schemaModel).values(values);\n\t\t\t\t\tconst returned = await withReturning(model, builder, values);\n\t\t\t\t\treturn returned;\n\t\t\t\t},\n\t\t\t\tasync findOne({ model, where, join }) {\n\t\t\t\t\tconst schemaModel = getSchema(model);\n\t\t\t\t\tconst clause = convertWhereClause(where, model);\n\n\t\t\t\t\tif (options.experimental?.joins) {\n\t\t\t\t\t\tif (!db.query || !db.query[model]) {\n\t\t\t\t\t\t\tlogger.error(\n\t\t\t\t\t\t\t\t`[# Drizzle Adapter]: The model \"${model}\" was not found in the query object. Please update your Drizzle schema to include relations or re-generate using \"npx @better-auth/cli@latest generate\".`,\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tlogger.info(\"Falling back to regular query\");\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tlet includes:\n\t\t\t\t\t\t\t\t| Record<string, { limit: number } | boolean>\n\t\t\t\t\t\t\t\t| undefined;\n\n\t\t\t\t\t\t\tconst pluralJoinResults: string[] = [];\n\t\t\t\t\t\t\tif (join) {\n\t\t\t\t\t\t\t\tincludes = {};\n\t\t\t\t\t\t\t\tconst joinEntries = Object.entries(join);\n\t\t\t\t\t\t\t\tfor (const [model, joinAttr] of joinEntries) {\n\t\t\t\t\t\t\t\t\tconst limit =\n\t\t\t\t\t\t\t\t\t\tjoinAttr.limit ??\n\t\t\t\t\t\t\t\t\t\toptions.advanced?.database?.defaultFindManyLimit ??\n\t\t\t\t\t\t\t\t\t\t100;\n\t\t\t\t\t\t\t\t\tconst isUnique = joinAttr.relation === \"one-to-one\";\n\t\t\t\t\t\t\t\t\tconst pluralSuffix = isUnique || config.usePlural ? \"\" : \"s\";\n\t\t\t\t\t\t\t\t\tincludes[`${model}${pluralSuffix}`] = isUnique\n\t\t\t\t\t\t\t\t\t\t? true\n\t\t\t\t\t\t\t\t\t\t: { limit };\n\t\t\t\t\t\t\t\t\tif (!isUnique) {\n\t\t\t\t\t\t\t\t\t\tpluralJoinResults.push(`${model}${pluralSuffix}`);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tconst query = db.query[model].findFirst({\n\t\t\t\t\t\t\t\twhere: clause[0],\n\t\t\t\t\t\t\t\twith: includes,\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\tconst res = await query;\n\n\t\t\t\t\t\t\tif (res) {\n\t\t\t\t\t\t\t\tfor (const pluralJoinResult of pluralJoinResults) {\n\t\t\t\t\t\t\t\t\tconst singularKey = !config.usePlural\n\t\t\t\t\t\t\t\t\t\t? pluralJoinResult.slice(0, -1)\n\t\t\t\t\t\t\t\t\t\t: pluralJoinResult;\n\t\t\t\t\t\t\t\t\tres[singularKey] = res[pluralJoinResult];\n\t\t\t\t\t\t\t\t\tif (pluralJoinResult !== singularKey) {\n\t\t\t\t\t\t\t\t\t\tdelete res[pluralJoinResult];\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn res;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tconst query = db\n\t\t\t\t\t\t.select()\n\t\t\t\t\t\t.from(schemaModel)\n\t\t\t\t\t\t.where(...clause);\n\n\t\t\t\t\tconst res = await query;\n\n\t\t\t\t\tif (!res.length) return null;\n\t\t\t\t\treturn res[0];\n\t\t\t\t},\n\t\t\t\tasync findMany({ model, where, sortBy, limit, offset, join }) {\n\t\t\t\t\tconst schemaModel = getSchema(model);\n\t\t\t\t\tconst clause = where ? convertWhereClause(where, model) : [];\n\t\t\t\t\tconst sortFn = sortBy?.direction === \"desc\" ? desc : asc;\n\n\t\t\t\t\tif (options.experimental?.joins) {\n\t\t\t\t\t\tif (!db.query[model]) {\n\t\t\t\t\t\t\tlogger.error(\n\t\t\t\t\t\t\t\t`[# Drizzle Adapter]: The model \"${model}\" was not found in the query object. Please update your Drizzle schema to include relations or re-generate using \"npx @better-auth/cli@latest generate\".`,\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tlogger.info(\"Falling back to regular query\");\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tlet includes:\n\t\t\t\t\t\t\t\t| Record<string, { limit: number } | boolean>\n\t\t\t\t\t\t\t\t| undefined;\n\n\t\t\t\t\t\t\tconst pluralJoinResults: string[] = [];\n\t\t\t\t\t\t\tif (join) {\n\t\t\t\t\t\t\t\tincludes = {};\n\t\t\t\t\t\t\t\tconst joinEntries = Object.entries(join);\n\t\t\t\t\t\t\t\tfor (const [model, joinAttr] of joinEntries) {\n\t\t\t\t\t\t\t\t\tconst isUnique = joinAttr.relation === \"one-to-one\";\n\t\t\t\t\t\t\t\t\tconst limit =\n\t\t\t\t\t\t\t\t\t\tjoinAttr.limit ??\n\t\t\t\t\t\t\t\t\t\toptions.advanced?.database?.defaultFindManyLimit ??\n\t\t\t\t\t\t\t\t\t\t100;\n\t\t\t\t\t\t\t\t\tconst pluralSuffix = isUnique || config.usePlural ? \"\" : \"s\";\n\t\t\t\t\t\t\t\t\tincludes[`${model}${pluralSuffix}`] = isUnique\n\t\t\t\t\t\t\t\t\t\t? true\n\t\t\t\t\t\t\t\t\t\t: { limit };\n\t\t\t\t\t\t\t\t\tif (!isUnique)\n\t\t\t\t\t\t\t\t\t\tpluralJoinResults.push(`${model}${pluralSuffix}`);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tlet orderBy: SQL<unknown>[] | undefined = undefined;\n\t\t\t\t\t\t\tif (sortBy?.field) {\n\t\t\t\t\t\t\t\torderBy = [\n\t\t\t\t\t\t\t\t\tsortFn(\n\t\t\t\t\t\t\t\t\t\tschemaModel[getFieldName({ model, field: sortBy?.field })],\n\t\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t\t];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tconst query = db.query[model].findMany({\n\t\t\t\t\t\t\t\twhere: clause[0],\n\t\t\t\t\t\t\t\twith: includes,\n\t\t\t\t\t\t\t\tlimit: limit ?? 100,\n\t\t\t\t\t\t\t\toffset: offset ?? 0,\n\t\t\t\t\t\t\t\torderBy,\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\tconst res = await query;\n\t\t\t\t\t\t\tif (res) {\n\t\t\t\t\t\t\t\tfor (const item of res) {\n\t\t\t\t\t\t\t\t\tfor (const pluralJoinResult of pluralJoinResults) {\n\t\t\t\t\t\t\t\t\t\tconst singularKey = !config.usePlural\n\t\t\t\t\t\t\t\t\t\t\t? pluralJoinResult.slice(0, -1)\n\t\t\t\t\t\t\t\t\t\t\t: pluralJoinResult;\n\t\t\t\t\t\t\t\t\t\tif (singularKey === pluralJoinResult) continue;\n\t\t\t\t\t\t\t\t\t\titem[singularKey] = item[pluralJoinResult];\n\t\t\t\t\t\t\t\t\t\tdelete item[pluralJoinResult];\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn res;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tlet builder = db.select().from(schemaModel);\n\n\t\t\t\t\tconst effectiveLimit = limit;\n\t\t\t\t\tconst effectiveOffset = offset;\n\n\t\t\t\t\tif (typeof effectiveLimit !== \"undefined\") {\n\t\t\t\t\t\tbuilder = builder.limit(effectiveLimit);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (typeof effectiveOffset !== \"undefined\") {\n\t\t\t\t\t\tbuilder = builder.offset(effectiveOffset);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (sortBy?.field) {\n\t\t\t\t\t\tbuilder = builder.orderBy(\n\t\t\t\t\t\t\tsortFn(\n\t\t\t\t\t\t\t\tschemaModel[getFieldName({ model, field: sortBy?.field })],\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\n\t\t\t\t\tconst res = await builder.where(...clause);\n\t\t\t\t\treturn res;\n\t\t\t\t},\n\t\t\t\tasync count({ model, where }) {\n\t\t\t\t\tconst schemaModel = getSchema(model);\n\t\t\t\t\tconst clause = where ? convertWhereClause(where, model) : [];\n\t\t\t\t\tconst res = await db\n\t\t\t\t\t\t.select({ count: count() })\n\t\t\t\t\t\t.from(schemaModel)\n\t\t\t\t\t\t.where(...clause);\n\t\t\t\t\treturn res[0].count;\n\t\t\t\t},\n\t\t\t\tasync update({ model, where, update: values }) {\n\t\t\t\t\tconst schemaModel = getSchema(model);\n\t\t\t\t\tconst clause = convertWhereClause(where, model);\n\t\t\t\t\tconst builder = db\n\t\t\t\t\t\t.update(schemaModel)\n\t\t\t\t\t\t.set(values)\n\t\t\t\t\t\t.where(...clause);\n\t\t\t\t\treturn await withReturning(model, builder, values as any, where);\n\t\t\t\t},\n\t\t\t\tasync updateMany({ model, where, update: values }) {\n\t\t\t\t\tconst schemaModel = getSchema(model);\n\t\t\t\t\tconst clause = convertWhereClause(where, model);\n\t\t\t\t\tconst builder = db\n\t\t\t\t\t\t.update(schemaModel)\n\t\t\t\t\t\t.set(values)\n\t\t\t\t\t\t.where(...clause);\n\t\t\t\t\treturn await builder;\n\t\t\t\t},\n\t\t\t\tasync delete({ model, where }) {\n\t\t\t\t\tconst schemaModel = getSchema(model);\n\t\t\t\t\tconst clause = convertWhereClause(where, model);\n\t\t\t\t\tconst builder = db.delete(schemaModel).where(...clause);\n\t\t\t\t\treturn await builder;\n\t\t\t\t},\n\t\t\t\tasync deleteMany({ model, where }) {\n\t\t\t\t\tconst schemaModel = getSchema(model);\n\t\t\t\t\tconst clause = convertWhereClause(where, model);\n\t\t\t\t\tconst builder = db.delete(schemaModel).where(...clause);\n\t\t\t\t\tconst res = await builder;\n\t\t\t\t\tlet count = 0;\n\t\t\t\t\tif (res && \"rowCount\" in res) count = res.rowCount;\n\t\t\t\t\telse if (Array.isArray(res)) count = res.length;\n\t\t\t\t\telse if (\n\t\t\t\t\t\tres &&\n\t\t\t\t\t\t(\"affectedRows\" in res || \"rowsAffected\" in res || \"changes\" in res)\n\t\t\t\t\t)\n\t\t\t\t\t\tcount = res.affectedRows ?? res.rowsAffected ?? res.changes;\n\t\t\t\t\tif (typeof count !== \"number\") {\n\t\t\t\t\t\tlogger.error(\n\t\t\t\t\t\t\t\"[Drizzle Adapter] The result of the deleteMany operation is not a number. This is likely a bug in the adapter. Please report this issue to the Better Auth team.\",\n\t\t\t\t\t\t\t{ res, model, where },\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t\treturn count;\n\t\t\t\t},\n\t\t\t\toptions: config,\n\t\t\t};\n\t\t};\n\tlet adapterOptions: AdapterFactoryOptions | null = null;\n\tadapterOptions = {\n\t\tconfig: {\n\t\t\tadapterId: \"drizzle\",\n\t\t\tadapterName: \"Drizzle Adapter\",\n\t\t\tusePlural: config.usePlural ?? false,\n\t\t\tdebugLogs: config.debugLogs ?? false,\n\t\t\tsupportsUUIDs: config.provider === \"pg\" ? true : false,\n\t\t\tsupportsJSON:\n\t\t\t\tconfig.provider === \"pg\" // even though mysql also supports it, mysql requires to pass stringified json anyway.\n\t\t\t\t\t? true\n\t\t\t\t\t: false,\n\t\t\tsupportsArrays: config.provider === \"pg\" ? true : false,\n\t\t\ttransaction:\n\t\t\t\t(config.transaction ?? false)\n\t\t\t\t\t? (cb) =>\n\t\t\t\t\t\t\tdb.transaction((tx: DB) => {\n\t\t\t\t\t\t\t\tconst adapter = createAdapterFactory({\n\t\t\t\t\t\t\t\t\tconfig: adapterOptions!.config,\n\t\t\t\t\t\t\t\t\tadapter: createCustomAdapter(tx),\n\t\t\t\t\t\t\t\t})(lazyOptions!);\n\t\t\t\t\t\t\t\treturn cb(adapter);\n\t\t\t\t\t\t\t})\n\t\t\t\t\t: false,\n\t\t},\n\t\tadapter: createCustomAdapter(db),\n\t};\n\tconst adapter = createAdapterFactory(adapterOptions);\n\treturn (options: BetterAuthOptions): DBAdapter<BetterAuthOptions> => {\n\t\tlazyOptions = options;\n\t\treturn adapter(options);\n\t};\n};\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAwEA,IAAa,iBAAA,CAAkB,IAAQ,WAAiC;AACvE,MAAIA,cAAwC;AAC5C,QAAM,sBAAA,CACJ,SAAA,CACA,EAAE,cAAc,QAAA,MAAc;AAC9B,aAAS,UAAU,OAAe;AACjC,YAAM,SAAS,OAAO,UAAUC,KAAG,EAAE;AACrC,UAAI,CAAC,OACJ,OAAM,IAAI,gBACT,uHAAA;AAGF,YAAM,cAAc,OAAO,KAAA;AAC3B,UAAI,CAAC,YACJ,OAAM,IAAI,gBACT,mCAAmC,KAAA,+FAAM;AAG3C,aAAO;;AAER,UAAM,gBAAgB,OACrB,OACA,SACA,MACA,UACI;AACJ,UAAI,OAAO,aAAa,QAEvB,SADU,MAAM,QAAQ,UAAA,GACf,CAAA;AAEV,YAAM,QAAQ,QAAA;AACd,YAAM,cAAc,UAAU,KAAA;AAC9B,YAAM,aAAa,QAAQ,QAAQ;AACnC,UAAI,OAAO,QAAQ;AAUlB,cAAM,SAAS,mBARM,MAAM,IAAA,CAAK,MAAM;AAErC,cAAI,KAAK,EAAE,KAAA,MAAW,OACrB,QAAO;YAAE,GAAG;YAAG,OAAO,KAAK,EAAE,KAAA;;AAE9B,iBAAO;YAGwC,KAAA;AAKhD,gBAJY,MAAMA,KAChB,OAAA,EACA,KAAK,WAAA,EACL,MAAM,GAAG,MAAA,GACA,CAAA;iBACD,cAAc,WAAW,CAAA,GAAI,IAAI,OAAO;AAClD,YAAI,MAAM,WAAW,CAAA,GAAI,IAAI;AAC7B,YAAI,CAAC,IAOJ,QALqB,MAAMA,KACzB,OAAO,EAAE,IAAI,sBAAG,CAAoB,EACpC,KAAK,WAAA,EACL,QAAQ,KAAK,YAAY,EAAA,CAAG,EAC5B,MAAM,CAAA,GACW,CAAA,EAAG;AAQvB,gBANY,MAAMA,KAChB,OAAA,EACA,KAAK,WAAA,EACL,MAAM,GAAG,YAAY,IAAI,GAAA,CAAI,EAC7B,MAAM,CAAA,EACN,QAAA,GACS,CAAA;iBACD,KAAK,GAOf,SANY,MAAMA,KAChB,OAAA,EACA,KAAK,WAAA,EACL,MAAM,GAAG,YAAY,IAAI,KAAK,EAAA,CAAG,EACjC,MAAM,CAAA,EACN,QAAA,GACS,CAAA;WACL;AAGN,YAAI,EAAE,QAAQ,aACb,OAAM,IAAI,gBACT,cAAc,KAAA,+EAAM;AAStB,gBANY,MAAMA,KAChB,OAAA,EACA,KAAK,WAAA,EACL,QAAQ,KAAK,YAAY,EAAA,CAAG,EAC5B,MAAM,CAAA,EACN,QAAA,GACS,CAAA;;;AAGb,aAAS,mBAAmB,OAAgB,OAAe;AAC1D,YAAM,cAAc,UAAU,KAAA;AAC9B,UAAI,CAAC,MAAO,QAAO,CAAA;AACnB,UAAI,MAAM,WAAW,GAAG;AACvB,cAAM,IAAI,MAAM,CAAA;AAChB,YAAI,CAAC,EACJ,QAAO,CAAA;AAER,cAAM,QAAQ,aAAa;UAAE;UAAO,OAAO,EAAE;SAAO;AACpD,YAAI,CAAC,YAAY,KAAA,EAChB,OAAM,IAAI,gBACT,cAAc,EAAE,KAAA,iDAAsD,KAAA,+BAAM;AAG9E,YAAI,EAAE,aAAa,MAAM;AACxB,cAAI,CAAC,MAAM,QAAQ,EAAE,KAAA,EACpB,OAAM,IAAI,gBACT,4BAA4B,EAAE,KAAA,kDAAM;AAGtC,iBAAO,CAAC,QAAQ,YAAY,KAAA,GAAQ,EAAE,KAAA,CAAM;;AAG7C,YAAI,EAAE,aAAa,UAAU;AAC5B,cAAI,CAAC,MAAM,QAAQ,EAAE,KAAA,EACpB,OAAM,IAAI,gBACT,4BAA4B,EAAE,KAAA,sDAAM;AAGtC,iBAAO,CAAC,WAAW,YAAY,KAAA,GAAQ,EAAE,KAAA,CAAM;;AAGhD,YAAI,EAAE,aAAa,WAClB,QAAO,CAAC,KAAK,YAAY,KAAA,GAAQ,IAAI,EAAE,KAAA,GAAM,CAAG;AAGjD,YAAI,EAAE,aAAa,cAClB,QAAO,CAAC,KAAK,YAAY,KAAA,GAAQ,GAAG,EAAE,KAAA,GAAM,CAAG;AAGhD,YAAI,EAAE,aAAa,YAClB,QAAO,CAAC,KAAK,YAAY,KAAA,GAAQ,IAAI,EAAE,KAAA,EAAA,CAAQ;AAGhD,YAAI,EAAE,aAAa,KAClB,QAAO,CAAC,GAAG,YAAY,KAAA,GAAQ,EAAE,KAAA,CAAM;AAGxC,YAAI,EAAE,aAAa,MAClB,QAAO,CAAC,IAAI,YAAY,KAAA,GAAQ,EAAE,KAAA,CAAM;AAGzC,YAAI,EAAE,aAAa,KAClB,QAAO,CAAC,GAAG,YAAY,KAAA,GAAQ,EAAE,KAAA,CAAM;AAGxC,YAAI,EAAE,aAAa,KAClB,QAAO,CAAC,GAAG,YAAY,KAAA,GAAQ,EAAE,KAAA,CAAM;AAGxC,YAAI,EAAE,aAAa,MAClB,QAAO,CAAC,IAAI,YAAY,KAAA,GAAQ,EAAE,KAAA,CAAM;AAGzC,eAAO,CAAC,GAAG,YAAY,KAAA,GAAQ,EAAE,KAAA,CAAM;;AAExC,YAAM,WAAW,MAAM,OAAA,CACrB,MAAM,EAAE,cAAc,SAAS,CAAC,EAAE,SAAA;AAEpC,YAAM,UAAU,MAAM,OAAA,CAAQ,MAAM,EAAE,cAAc,IAAA;AAEpD,YAAM,YAAY,IACjB,GAAG,SAAS,IAAA,CAAK,MAAM;AACtB,cAAM,QAAQ,aAAa;UAAE;UAAO,OAAO,EAAE;SAAO;AACpD,YAAI,EAAE,aAAa,MAAM;AACxB,cAAI,CAAC,MAAM,QAAQ,EAAE,KAAA,EACpB,OAAM,IAAI,gBACT,4BAA4B,EAAE,KAAA,kDAAM;AAGtC,iBAAO,QAAQ,YAAY,KAAA,GAAQ,EAAE,KAAA;;AAEtC,YAAI,EAAE,aAAa,UAAU;AAC5B,cAAI,CAAC,MAAM,QAAQ,EAAE,KAAA,EACpB,OAAM,IAAI,gBACT,4BAA4B,EAAE,KAAA,sDAAM;AAGtC,iBAAO,WAAW,YAAY,KAAA,GAAQ,EAAE,KAAA;;AAEzC,YAAI,EAAE,aAAa,WAClB,QAAO,KAAK,YAAY,KAAA,GAAQ,IAAI,EAAE,KAAA,GAAM;AAE7C,YAAI,EAAE,aAAa,cAClB,QAAO,KAAK,YAAY,KAAA,GAAQ,GAAG,EAAE,KAAA,GAAM;AAE5C,YAAI,EAAE,aAAa,YAClB,QAAO,KAAK,YAAY,KAAA,GAAQ,IAAI,EAAE,KAAA,EAAA;AAEvC,YAAI,EAAE,aAAa,KAClB,QAAO,GAAG,YAAY,KAAA,GAAQ,EAAE,KAAA;AAEjC,YAAI,EAAE,aAAa,MAClB,QAAO,IAAI,YAAY,KAAA,GAAQ,EAAE,KAAA;AAElC,YAAI,EAAE,aAAa,KAClB,QAAO,GAAG,YAAY,KAAA,GAAQ,EAAE,KAAA;AAEjC,YAAI,EAAE,aAAa,MAClB,QAAO,IAAI,YAAY,KAAA,GAAQ,EAAE,KAAA;AAElC,YAAI,EAAE,aAAa,KAClB,QAAO,GAAG,YAAY,KAAA,GAAQ,EAAE,KAAA;AAEjC,eAAO,GAAG,YAAY,KAAA,GAAQ,EAAE,KAAA;QAC/B;AAEH,YAAM,WAAW,GAChB,GAAG,QAAQ,IAAA,CAAK,MAAM;AACrB,cAAM,QAAQ,aAAa;UAAE;UAAO,OAAO,EAAE;SAAO;AACpD,YAAI,EAAE,aAAa,MAAM;AACxB,cAAI,CAAC,MAAM,QAAQ,EAAE,KAAA,EACpB,OAAM,IAAI,gBACT,4BAA4B,EAAE,KAAA,kDAAM;AAGtC,iBAAO,QAAQ,YAAY,KAAA,GAAQ,EAAE,KAAA;;AAEtC,YAAI,EAAE,aAAa,UAAU;AAC5B,cAAI,CAAC,MAAM,QAAQ,EAAE,KAAA,EACpB,OAAM,IAAI,gBACT,4BAA4B,EAAE,KAAA,sDAAM;AAGtC,iBAAO,WAAW,YAAY,KAAA,GAAQ,EAAE,KAAA;;AAEzC,YAAI,EAAE,aAAa,WAClB,QAAO,KAAK,YAAY,KAAA,GAAQ,IAAI,EAAE,KAAA,GAAM;AAE7C,YAAI,EAAE,aAAa,cAClB,QAAO,KAAK,YAAY,KAAA,GAAQ,GAAG,EAAE,KAAA,GAAM;AAE5C,YAAI,EAAE,aAAa,YAClB,QAAO,KAAK,YAAY,KAAA,GAAQ,IAAI,EAAE,KAAA,EAAA;AAEvC,YAAI,EAAE,aAAa,KAClB,QAAO,GAAG,YAAY,KAAA,GAAQ,EAAE,KAAA;AAEjC,YAAI,EAAE,aAAa,MAClB,QAAO,IAAI,YAAY,KAAA,GAAQ,EAAE,KAAA;AAElC,YAAI,EAAE,aAAa,KAClB,QAAO,GAAG,YAAY,KAAA,GAAQ,EAAE,KAAA;AAEjC,YAAI,EAAE,aAAa,MAClB,QAAO,IAAI,YAAY,KAAA,GAAQ,EAAE,KAAA;AAElC,YAAI,EAAE,aAAa,KAClB,QAAO,GAAG,YAAY,KAAA,GAAQ,EAAE,KAAA;AAEjC,eAAO,GAAG,YAAY,KAAA,GAAQ,EAAE,KAAA;QAC/B;AAGH,YAAMC,SAAyB,CAAA;AAE/B,UAAI,SAAS,OAAQ,QAAO,KAAK,SAAA;AACjC,UAAI,QAAQ,OAAQ,QAAO,KAAK,QAAA;AAChC,aAAO;;AAER,aAAS,mBACR,QACA,OACA,QACC;AACD,UAAI,CAAC,OACJ,OAAM,IAAI,gBACT,+HAAA;AAGF,iBAAW,OAAO,OACjB,KAAI,CAAC,OAAO,GAAA,EACX,OAAM,IAAI,gBACT,cAAc,GAAA,4BAA+B,KAAA,kHAAM;;AAMvD,WAAO;MACN,MAAM,OAAO,EAAE,OAAO,MAAM,OAAA,GAAU;AACrC,cAAM,cAAc,UAAU,KAAA;AAC9B,2BAAmB,aAAa,OAAO,MAAA;AAGvC,eADiB,MAAM,cAAc,OADrBD,KAAG,OAAO,WAAA,EAAa,OAAO,MAAA,GACO,MAAA;;MAGtD,MAAM,QAAQ,EAAE,OAAO,OAAO,KAAA,GAAQ;AACrC,cAAM,cAAc,UAAU,KAAA;AAC9B,cAAM,SAAS,mBAAmB,OAAO,KAAA;AAEzC,YAAI,QAAQ,cAAc,MACzB,KAAI,CAACA,KAAG,SAAS,CAACA,KAAG,MAAM,KAAA,GAAQ;AAClC,iBAAO,MACN,mCAAmC,KAAA,0JAAM;AAE1C,iBAAO,KAAK,+BAAA;eACN;AACN,cAAIE;AAIJ,gBAAMC,oBAA8B,CAAA;AACpC,cAAI,MAAM;AACT,uBAAW,CAAA;AACX,kBAAM,cAAc,OAAO,QAAQ,IAAA;AACnC,uBAAW,CAACC,SAAO,QAAA,KAAa,aAAa;AAC5C,oBAAM,QACL,SAAS,SACT,QAAQ,UAAU,UAAU,wBAC5B;AACD,oBAAM,WAAW,SAAS,aAAa;AACvC,oBAAM,eAAe,YAAY,OAAO,YAAY,KAAK;AACzD,uBAAS,GAAGA,OAAAA,GAAQ,YAAA,EAAA,IAAkB,WACnC,OACA,EAAE,MAAA;AACL,kBAAI,CAAC,SACJ,mBAAkB,KAAK,GAAGA,OAAAA,GAAQ,YAAA,EAAA;;;AAQrC,gBAAMC,QAAM,MAJEL,KAAG,MAAM,KAAA,EAAO,UAAU;YACvC,OAAO,OAAO,CAAA;YACd,MAAM;WACN;AAGD,cAAIK,MACH,YAAW,oBAAoB,mBAAmB;AACjD,kBAAM,cAAc,CAAC,OAAO,YACzB,iBAAiB,MAAM,GAAG,EAAA,IAC1B;AACH,kBAAI,WAAA,IAAeA,MAAI,gBAAA;AACvB,gBAAI,qBAAqB,YACxB,QAAOA,MAAI,gBAAA;;AAId,iBAAOA;;AAST,cAAM,MAAM,MALEL,KACZ,OAAA,EACA,KAAK,WAAA,EACL,MAAM,GAAG,MAAA;AAIX,YAAI,CAAC,IAAI,OAAQ,QAAO;AACxB,eAAO,IAAI,CAAA;;MAEZ,MAAM,SAAS,EAAE,OAAO,OAAO,QAAQ,OAAO,QAAQ,KAAA,GAAQ;AAC7D,cAAM,cAAc,UAAU,KAAA;AAC9B,cAAM,SAAS,QAAQ,mBAAmB,OAAO,KAAA,IAAS,CAAA;AAC1D,cAAM,SAAS,QAAQ,cAAc,SAAS,OAAO;AAErD,YAAI,QAAQ,cAAc,MACzB,KAAI,CAACA,KAAG,MAAM,KAAA,GAAQ;AACrB,iBAAO,MACN,mCAAmC,KAAA,0JAAM;AAE1C,iBAAO,KAAK,+BAAA;eACN;AACN,cAAIE;AAIJ,gBAAMC,oBAA8B,CAAA;AACpC,cAAI,MAAM;AACT,uBAAW,CAAA;AACX,kBAAM,cAAc,OAAO,QAAQ,IAAA;AACnC,uBAAW,CAACC,SAAO,QAAA,KAAa,aAAa;AAC5C,oBAAM,WAAW,SAAS,aAAa;AACvC,oBAAME,UACL,SAAS,SACT,QAAQ,UAAU,UAAU,wBAC5B;AACD,oBAAM,eAAe,YAAY,OAAO,YAAY,KAAK;AACzD,uBAAS,GAAGF,OAAAA,GAAQ,YAAA,EAAA,IAAkB,WACnC,OACA,EAAE,OAAA,QAAA;AACL,kBAAI,CAAC,SACJ,mBAAkB,KAAK,GAAGA,OAAAA,GAAQ,YAAA,EAAA;;;AAGrC,cAAIG,UAAsC;AAC1C,cAAI,QAAQ,MACX,WAAU,CACT,OACC,YAAY,aAAa;YAAE;YAAO,OAAO,QAAQ;WAAO,CAAC,CAAA,CACzD;AAUH,gBAAM,MAAM,MAPEP,KAAG,MAAM,KAAA,EAAO,SAAS;YACtC,OAAO,OAAO,CAAA;YACd,MAAM;YACN,OAAO,SAAS;YAChB,QAAQ,UAAU;YAClB;WACA;AAED,cAAI,IACH,YAAW,QAAQ,IAClB,YAAW,oBAAoB,mBAAmB;AACjD,kBAAM,cAAc,CAAC,OAAO,YACzB,iBAAiB,MAAM,GAAG,EAAA,IAC1B;AACH,gBAAI,gBAAgB,iBAAkB;AACtC,iBAAK,WAAA,IAAe,KAAK,gBAAA;AACzB,mBAAO,KAAK,gBAAA;;AAIf,iBAAO;;AAIT,YAAI,UAAUA,KAAG,OAAA,EAAS,KAAK,WAAA;AAE/B,cAAM,iBAAiB;AACvB,cAAM,kBAAkB;AAExB,YAAI,OAAO,mBAAmB,YAC7B,WAAU,QAAQ,MAAM,cAAA;AAGzB,YAAI,OAAO,oBAAoB,YAC9B,WAAU,QAAQ,OAAO,eAAA;AAG1B,YAAI,QAAQ,MACX,WAAU,QAAQ,QACjB,OACC,YAAY,aAAa;UAAE;UAAO,OAAO,QAAQ;SAAO,CAAC,CAAA,CACzD;AAKH,eADY,MAAM,QAAQ,MAAM,GAAG,MAAA;;MAGpC,MAAM,MAAM,EAAE,OAAO,MAAA,GAAS;AAC7B,cAAM,cAAc,UAAU,KAAA;AAC9B,cAAM,SAAS,QAAQ,mBAAmB,OAAO,KAAA,IAAS,CAAA;AAK1D,gBAJY,MAAMA,KAChB,OAAO,EAAE,OAAO,MAAA,EAAO,CAAE,EACzB,KAAK,WAAA,EACL,MAAM,GAAG,MAAA,GACA,CAAA,EAAG;;MAEf,MAAM,OAAO,EAAE,OAAO,OAAO,QAAQ,OAAA,GAAU;AAC9C,cAAM,cAAc,UAAU,KAAA;AAC9B,cAAM,SAAS,mBAAmB,OAAO,KAAA;AAKzC,eAAO,MAAM,cAAc,OAJXA,KACd,OAAO,WAAA,EACP,IAAI,MAAA,EACJ,MAAM,GAAG,MAAA,GACgC,QAAe,KAAA;;MAE3D,MAAM,WAAW,EAAE,OAAO,OAAO,QAAQ,OAAA,GAAU;AAClD,cAAM,cAAc,UAAU,KAAA;AAC9B,cAAM,SAAS,mBAAmB,OAAO,KAAA;AAKzC,eAAO,MAJSA,KACd,OAAO,WAAA,EACP,IAAI,MAAA,EACJ,MAAM,GAAG,MAAA;;MAGZ,MAAM,OAAO,EAAE,OAAO,MAAA,GAAS;AAC9B,cAAM,cAAc,UAAU,KAAA;AAC9B,cAAM,SAAS,mBAAmB,OAAO,KAAA;AAEzC,eAAO,MADSA,KAAG,OAAO,WAAA,EAAa,MAAM,GAAG,MAAA;;MAGjD,MAAM,WAAW,EAAE,OAAO,MAAA,GAAS;AAClC,cAAM,cAAc,UAAU,KAAA;AAC9B,cAAM,SAAS,mBAAmB,OAAO,KAAA;AAEzC,cAAM,MAAM,MADIA,KAAG,OAAO,WAAA,EAAa,MAAM,GAAG,MAAA;AAEhD,YAAIQ,UAAQ;AACZ,YAAI,OAAO,cAAc,IAAK,WAAQ,IAAI;iBACjC,MAAM,QAAQ,GAAA,EAAM,WAAQ,IAAI;iBAExC,QACC,kBAAkB,OAAO,kBAAkB,OAAO,aAAa,KAEhE,WAAQ,IAAI,gBAAgB,IAAI,gBAAgB,IAAI;AACrD,YAAI,OAAOA,YAAU,SACpB,QAAO,MACN,oKACA;UAAE;UAAK;UAAO;SAAO;AAGvB,eAAOA;;MAER,SAAS;;;AAGZ,MAAIC,iBAA+C;AACnD,mBAAiB;IAChB,QAAQ;MACP,WAAW;MACX,aAAa;MACb,WAAW,OAAO,aAAa;MAC/B,WAAW,OAAO,aAAa;MAC/B,eAAe,OAAO,aAAa,OAAO,OAAO;MACjD,cACC,OAAO,aAAa,OACjB,OACA;MACJ,gBAAgB,OAAO,aAAa,OAAO,OAAO;MAClD,aACE,OAAO,eAAe,QAAA,CACnB,OACD,GAAG,YAAA,CAAa,OAAW;AAK1B,eAAO,GAJS,qBAAqB;UACpC,QAAQ,eAAgB;UACxB,SAAS,oBAAoB,EAAA;SAC7B,EAAE,WAAA,CAAa;WAGjB;;IAEL,SAAS,oBAAoB,EAAA;;AAE9B,QAAM,UAAU,qBAAqB,cAAA;AACrC,SAAA,CAAQ,YAA6D;AACpE,kBAAc;AACd,WAAO,QAAQ,OAAA;;;",
  "names": ["lazyOptions: BetterAuthOptions | null", "db", "clause: SQL<unknown>[]", "includes:\n\t\t\t\t\t\t\t\t| Record<string, { limit: number } | boolean>\n\t\t\t\t\t\t\t\t| undefined", "pluralJoinResults: string[]", "model", "res", "limit", "orderBy: SQL<unknown>[] | undefined", "count", "adapterOptions: AdapterFactoryOptions | null"]
}
