{
  "version": 3,
  "sources": ["../../../../../node_modules/.bun/@orpc+openapi-client@1.13.4+460773ef8ff1e07c/node_modules/@orpc/openapi-client/dist/shared/openapi-client.t9fCAe3x.mjs", "../../../../../node_modules/.bun/@orpc+openapi-client@1.13.4+460773ef8ff1e07c/node_modules/@orpc/openapi-client/dist/shared/openapi-client.B2Q9qU5m.mjs", "../../../../../node_modules/.bun/json-schema-typed@8.0.2/node_modules/json-schema-typed/draft_2020_12.js", "../../../../../node_modules/.bun/@orpc+openapi@1.13.4+64f0629d09b745d9/node_modules/@orpc/openapi/dist/shared/openapi.CoREqFh3.mjs", "../../../../../node_modules/.bun/@orpc+openapi@1.13.4+64f0629d09b745d9/node_modules/@orpc/openapi/dist/index.mjs"],
  "sourcesContent": ["import { isObject, NullProtoObj } from '@orpc/shared';\n\nclass StandardBracketNotationSerializer {\n  maxArrayIndex;\n  constructor(options = {}) {\n    this.maxArrayIndex = options.maxBracketNotationArrayIndex ?? 9999;\n  }\n  serialize(data, segments = [], result = []) {\n    if (Array.isArray(data)) {\n      data.forEach((item, i) => {\n        this.serialize(item, [...segments, i], result);\n      });\n    } else if (isObject(data)) {\n      for (const key in data) {\n        this.serialize(data[key], [...segments, key], result);\n      }\n    } else {\n      result.push([this.stringifyPath(segments), data]);\n    }\n    return result;\n  }\n  deserialize(serialized) {\n    if (serialized.length === 0) {\n      return {};\n    }\n    const arrayPushStyles = /* @__PURE__ */ new WeakSet();\n    const ref = { value: [] };\n    for (const [path, value] of serialized) {\n      const segments = this.parsePath(path);\n      let currentRef = ref;\n      let nextSegment = \"value\";\n      segments.forEach((segment, i) => {\n        if (!Array.isArray(currentRef[nextSegment]) && !isObject(currentRef[nextSegment])) {\n          currentRef[nextSegment] = [];\n        }\n        if (i !== segments.length - 1) {\n          if (Array.isArray(currentRef[nextSegment]) && !isValidArrayIndex(segment, this.maxArrayIndex)) {\n            if (arrayPushStyles.has(currentRef[nextSegment])) {\n              arrayPushStyles.delete(currentRef[nextSegment]);\n              currentRef[nextSegment] = pushStyleArrayToObject(currentRef[nextSegment]);\n            } else {\n              currentRef[nextSegment] = arrayToObject(currentRef[nextSegment]);\n            }\n          }\n        } else {\n          if (Array.isArray(currentRef[nextSegment])) {\n            if (segment === \"\") {\n              if (currentRef[nextSegment].length && !arrayPushStyles.has(currentRef[nextSegment])) {\n                currentRef[nextSegment] = arrayToObject(currentRef[nextSegment]);\n              }\n            } else {\n              if (arrayPushStyles.has(currentRef[nextSegment])) {\n                arrayPushStyles.delete(currentRef[nextSegment]);\n                currentRef[nextSegment] = pushStyleArrayToObject(currentRef[nextSegment]);\n              } else if (!isValidArrayIndex(segment, this.maxArrayIndex)) {\n                currentRef[nextSegment] = arrayToObject(currentRef[nextSegment]);\n              }\n            }\n          }\n        }\n        currentRef = currentRef[nextSegment];\n        nextSegment = segment;\n      });\n      if (Array.isArray(currentRef) && nextSegment === \"\") {\n        arrayPushStyles.add(currentRef);\n        currentRef.push(value);\n      } else if (nextSegment in currentRef) {\n        if (Array.isArray(currentRef[nextSegment])) {\n          currentRef[nextSegment].push(value);\n        } else {\n          currentRef[nextSegment] = [currentRef[nextSegment], value];\n        }\n      } else {\n        currentRef[nextSegment] = value;\n      }\n    }\n    return ref.value;\n  }\n  stringifyPath(segments) {\n    return segments.map((segment) => {\n      return segment.toString().replace(/[\\\\[\\]]/g, (match) => {\n        switch (match) {\n          case \"\\\\\":\n            return \"\\\\\\\\\";\n          case \"[\":\n            return \"\\\\[\";\n          case \"]\":\n            return \"\\\\]\";\n          /* v8 ignore next 2 */\n          default:\n            return match;\n        }\n      });\n    }).reduce((result, segment, i) => {\n      if (i === 0) {\n        return segment;\n      }\n      return `${result}[${segment}]`;\n    }, \"\");\n  }\n  parsePath(path) {\n    const segments = [];\n    let inBrackets = false;\n    let currentSegment = \"\";\n    let backslashCount = 0;\n    for (let i = 0; i < path.length; i++) {\n      const char = path[i];\n      const nextChar = path[i + 1];\n      if (inBrackets && char === \"]\" && (nextChar === void 0 || nextChar === \"[\") && backslashCount % 2 === 0) {\n        if (nextChar === void 0) {\n          inBrackets = false;\n        }\n        segments.push(currentSegment);\n        currentSegment = \"\";\n        i++;\n      } else if (segments.length === 0 && char === \"[\" && backslashCount % 2 === 0) {\n        inBrackets = true;\n        segments.push(currentSegment);\n        currentSegment = \"\";\n      } else if (char === \"\\\\\") {\n        backslashCount++;\n      } else {\n        currentSegment += \"\\\\\".repeat(backslashCount / 2) + char;\n        backslashCount = 0;\n      }\n    }\n    return inBrackets || segments.length === 0 ? [path] : segments;\n  }\n}\nfunction isValidArrayIndex(value, maxIndex) {\n  return /^0$|^[1-9]\\d*$/.test(value) && Number(value) <= maxIndex;\n}\nfunction arrayToObject(array) {\n  const obj = new NullProtoObj();\n  array.forEach((item, i) => {\n    obj[i] = item;\n  });\n  return obj;\n}\nfunction pushStyleArrayToObject(array) {\n  const obj = new NullProtoObj();\n  obj[\"\"] = array.length === 1 ? array[0] : array;\n  return obj;\n}\n\nexport { StandardBracketNotationSerializer as S };\n", "import { toStandardHeaders, toHttpPath, getMalformedResponseErrorCode, StandardLink } from '@orpc/client/standard';\nimport { S as StandardBracketNotationSerializer } from './openapi-client.t9fCAe3x.mjs';\nimport { isObject, value, get, isAsyncIteratorObject } from '@orpc/shared';\nimport { isORPCErrorStatus, isORPCErrorJson, createORPCErrorFromJson, mapEventIterator, toORPCError } from '@orpc/client';\nimport { isContractProcedure, fallbackContractConfig, ORPCError } from '@orpc/contract';\nimport { mergeStandardHeaders, ErrorEvent } from '@orpc/standard-server';\n\nclass StandardOpenAPIJsonSerializer {\n  customSerializers;\n  constructor(options = {}) {\n    this.customSerializers = options.customJsonSerializers ?? [];\n  }\n  serialize(data, hasBlobRef = { value: false }) {\n    for (const custom of this.customSerializers) {\n      if (custom.condition(data)) {\n        const result = this.serialize(custom.serialize(data), hasBlobRef);\n        return result;\n      }\n    }\n    if (data instanceof Blob) {\n      hasBlobRef.value = true;\n      return [data, hasBlobRef.value];\n    }\n    if (data instanceof Set) {\n      return this.serialize(Array.from(data), hasBlobRef);\n    }\n    if (data instanceof Map) {\n      return this.serialize(Array.from(data.entries()), hasBlobRef);\n    }\n    if (Array.isArray(data)) {\n      const json = data.map((v) => v === void 0 ? null : this.serialize(v, hasBlobRef)[0]);\n      return [json, hasBlobRef.value];\n    }\n    if (isObject(data)) {\n      const json = {};\n      for (const k in data) {\n        if (k === \"toJSON\" && typeof data[k] === \"function\") {\n          continue;\n        }\n        json[k] = this.serialize(data[k], hasBlobRef)[0];\n      }\n      return [json, hasBlobRef.value];\n    }\n    if (typeof data === \"bigint\" || data instanceof RegExp || data instanceof URL) {\n      return [data.toString(), hasBlobRef.value];\n    }\n    if (data instanceof Date) {\n      return [Number.isNaN(data.getTime()) ? null : data.toISOString(), hasBlobRef.value];\n    }\n    if (Number.isNaN(data)) {\n      return [null, hasBlobRef.value];\n    }\n    return [data, hasBlobRef.value];\n  }\n}\n\nfunction standardizeHTTPPath(path) {\n  return `/${path.replace(/\\/{2,}/g, \"/\").replace(/^\\/|\\/$/g, \"\")}`;\n}\nfunction getDynamicParams(path) {\n  return path ? standardizeHTTPPath(path).match(/\\/\\{[^}]+\\}/g)?.map((v) => ({\n    raw: v,\n    name: v.match(/\\{\\+?([^}]+)\\}/)[1]\n  })) : void 0;\n}\n\nclass StandardOpenapiLinkCodec {\n  constructor(contract, serializer, options) {\n    this.contract = contract;\n    this.serializer = serializer;\n    this.baseUrl = options.url;\n    this.headers = options.headers ?? {};\n    this.customErrorResponseBodyDecoder = options.customErrorResponseBodyDecoder;\n  }\n  baseUrl;\n  headers;\n  customErrorResponseBodyDecoder;\n  async encode(path, input, options) {\n    let headers = toStandardHeaders(await value(this.headers, options, path, input));\n    if (options.lastEventId !== void 0) {\n      headers = mergeStandardHeaders(headers, { \"last-event-id\": options.lastEventId });\n    }\n    const baseUrl = await value(this.baseUrl, options, path, input);\n    const procedure = get(this.contract, path);\n    if (!isContractProcedure(procedure)) {\n      throw new Error(`[StandardOpenapiLinkCodec] expect a contract procedure at ${path.join(\".\")}`);\n    }\n    const inputStructure = fallbackContractConfig(\"defaultInputStructure\", procedure[\"~orpc\"].route.inputStructure);\n    return inputStructure === \"compact\" ? this.#encodeCompact(procedure, path, input, options, baseUrl, headers) : this.#encodeDetailed(procedure, path, input, options, baseUrl, headers);\n  }\n  #encodeCompact(procedure, path, input, options, baseUrl, headers) {\n    let httpPath = standardizeHTTPPath(procedure[\"~orpc\"].route.path ?? toHttpPath(path));\n    let httpBody = input;\n    const dynamicParams = getDynamicParams(httpPath);\n    if (dynamicParams?.length) {\n      if (!isObject(input)) {\n        throw new TypeError(`[StandardOpenapiLinkCodec] Invalid input shape for \"compact\" structure when has dynamic params at ${path.join(\".\")}.`);\n      }\n      const body = { ...input };\n      for (const param of dynamicParams) {\n        const value2 = input[param.name];\n        httpPath = httpPath.replace(param.raw, `/${encodeURIComponent(`${this.serializer.serialize(value2)}`)}`);\n        delete body[param.name];\n      }\n      httpBody = Object.keys(body).length ? body : void 0;\n    }\n    const method = fallbackContractConfig(\"defaultMethod\", procedure[\"~orpc\"].route.method);\n    const url = new URL(baseUrl);\n    url.pathname = `${url.pathname.replace(/\\/$/, \"\")}${httpPath}`;\n    if (method === \"GET\") {\n      const serialized = this.serializer.serialize(httpBody, { outputFormat: \"URLSearchParams\" });\n      for (const [key, value2] of serialized) {\n        url.searchParams.append(key, value2);\n      }\n      return {\n        url,\n        method,\n        headers,\n        body: void 0,\n        signal: options.signal\n      };\n    }\n    return {\n      url,\n      method,\n      headers,\n      body: this.serializer.serialize(httpBody),\n      signal: options.signal\n    };\n  }\n  #encodeDetailed(procedure, path, input, options, baseUrl, headers) {\n    let httpPath = standardizeHTTPPath(procedure[\"~orpc\"].route.path ?? toHttpPath(path));\n    const dynamicParams = getDynamicParams(httpPath);\n    if (!isObject(input) && input !== void 0) {\n      throw new TypeError(`[StandardOpenapiLinkCodec] Invalid input shape for \"detailed\" structure at ${path.join(\".\")}.`);\n    }\n    if (dynamicParams?.length) {\n      if (!isObject(input?.params)) {\n        throw new TypeError(`[StandardOpenapiLinkCodec] Invalid input.params shape for \"detailed\" structure when has dynamic params at ${path.join(\".\")}.`);\n      }\n      for (const param of dynamicParams) {\n        const value2 = input.params[param.name];\n        httpPath = httpPath.replace(param.raw, `/${encodeURIComponent(`${this.serializer.serialize(value2)}`)}`);\n      }\n    }\n    let mergedHeaders = headers;\n    if (input?.headers !== void 0) {\n      if (!isObject(input.headers)) {\n        throw new TypeError(`[StandardOpenapiLinkCodec] Invalid input.headers shape for \"detailed\" structure at ${path.join(\".\")}.`);\n      }\n      mergedHeaders = mergeStandardHeaders(input.headers, headers);\n    }\n    const method = fallbackContractConfig(\"defaultMethod\", procedure[\"~orpc\"].route.method);\n    const url = new URL(baseUrl);\n    url.pathname = `${url.pathname.replace(/\\/$/, \"\")}${httpPath}`;\n    if (input?.query !== void 0) {\n      const query = this.serializer.serialize(input.query, { outputFormat: \"URLSearchParams\" });\n      for (const [key, value2] of query) {\n        url.searchParams.append(key, value2);\n      }\n    }\n    if (method === \"GET\") {\n      return {\n        url,\n        method,\n        headers: mergedHeaders,\n        body: void 0,\n        signal: options.signal\n      };\n    }\n    return {\n      url,\n      method,\n      headers: mergedHeaders,\n      body: this.serializer.serialize(input?.body),\n      signal: options.signal\n    };\n  }\n  async decode(response, _options, path) {\n    const isOk = !isORPCErrorStatus(response.status);\n    const deserialized = await (async () => {\n      let isBodyOk = false;\n      try {\n        const body = await response.body();\n        isBodyOk = true;\n        return this.serializer.deserialize(body);\n      } catch (error) {\n        if (!isBodyOk) {\n          throw new Error(\"Cannot parse response body, please check the response body and content-type.\", {\n            cause: error\n          });\n        }\n        throw new Error(\"Invalid OpenAPI response format.\", {\n          cause: error\n        });\n      }\n    })();\n    if (!isOk) {\n      const error = this.customErrorResponseBodyDecoder?.(deserialized, response);\n      if (error !== null && error !== void 0) {\n        throw error;\n      }\n      if (isORPCErrorJson(deserialized)) {\n        throw createORPCErrorFromJson(deserialized);\n      }\n      throw new ORPCError(getMalformedResponseErrorCode(response.status), {\n        status: response.status,\n        data: { ...response, body: deserialized }\n      });\n    }\n    const procedure = get(this.contract, path);\n    if (!isContractProcedure(procedure)) {\n      throw new Error(`[StandardOpenapiLinkCodec] expect a contract procedure at ${path.join(\".\")}`);\n    }\n    const outputStructure = fallbackContractConfig(\"defaultOutputStructure\", procedure[\"~orpc\"].route.outputStructure);\n    if (outputStructure === \"compact\") {\n      return deserialized;\n    }\n    return {\n      status: response.status,\n      headers: response.headers,\n      body: deserialized\n    };\n  }\n}\n\nclass StandardOpenAPISerializer {\n  constructor(jsonSerializer, bracketNotation) {\n    this.jsonSerializer = jsonSerializer;\n    this.bracketNotation = bracketNotation;\n  }\n  serialize(data, options = {}) {\n    if (isAsyncIteratorObject(data) && !options.outputFormat) {\n      return mapEventIterator(data, {\n        value: async (value) => this.#serialize(value, { outputFormat: \"plain\" }),\n        error: async (e) => {\n          return new ErrorEvent({\n            data: this.#serialize(toORPCError(e).toJSON(), { outputFormat: \"plain\" }),\n            cause: e\n          });\n        }\n      });\n    }\n    return this.#serialize(data, options);\n  }\n  #serialize(data, options) {\n    const [json, hasBlob] = this.jsonSerializer.serialize(data);\n    if (options.outputFormat === \"plain\") {\n      return json;\n    }\n    if (options.outputFormat === \"URLSearchParams\") {\n      const params = new URLSearchParams();\n      for (const [path, value] of this.bracketNotation.serialize(json)) {\n        if (typeof value === \"string\" || typeof value === \"number\" || typeof value === \"boolean\") {\n          params.append(path, value.toString());\n        }\n      }\n      return params;\n    }\n    if (json instanceof Blob || json === void 0 || !hasBlob) {\n      return json;\n    }\n    const form = new FormData();\n    for (const [path, value] of this.bracketNotation.serialize(json)) {\n      if (typeof value === \"string\" || typeof value === \"number\" || typeof value === \"boolean\") {\n        form.append(path, value.toString());\n      } else if (value instanceof Blob) {\n        form.append(path, value);\n      }\n    }\n    return form;\n  }\n  deserialize(data) {\n    if (data instanceof URLSearchParams || data instanceof FormData) {\n      return this.bracketNotation.deserialize(Array.from(data.entries()));\n    }\n    if (isAsyncIteratorObject(data)) {\n      return mapEventIterator(data, {\n        value: async (value) => value,\n        error: async (e) => {\n          if (e instanceof ErrorEvent && isORPCErrorJson(e.data)) {\n            return createORPCErrorFromJson(e.data, { cause: e });\n          }\n          return e;\n        }\n      });\n    }\n    return data;\n  }\n}\n\nclass StandardOpenAPILink extends StandardLink {\n  constructor(contract, linkClient, options) {\n    const jsonSerializer = new StandardOpenAPIJsonSerializer(options);\n    const bracketNotationSerializer = new StandardBracketNotationSerializer({ maxBracketNotationArrayIndex: 4294967294 });\n    const serializer = new StandardOpenAPISerializer(jsonSerializer, bracketNotationSerializer);\n    const linkCodec = new StandardOpenapiLinkCodec(contract, serializer, options);\n    super(linkCodec, linkClient, options);\n  }\n}\n\nexport { StandardOpenAPIJsonSerializer as S, StandardOpenAPILink as a, StandardOpenapiLinkCodec as b, StandardOpenAPISerializer as c, getDynamicParams as g, standardizeHTTPPath as s };\n", "// @generated\r\n// This code is automatically generated. Manual editing is not recommended.\r\n/*\r\n * BSD-2-Clause License\r\n *\r\n * Original source code is copyright (c) 2025 Remy Rylan\r\n * <https://github.com/RemyRylan>\r\n *\r\n * Documentation and keyword descriptions are copyright (c) 2020 IETF Trust\r\n * <https://www.ietf.org/>, Austin Wright <aaa@bzfx.net>, Henry Andrews\r\n * <andrews_henry@yahoo.com>, Ben Hutton <ben@jsonschema.dev>, and Greg Dennis\r\n * <gregsdennis@yahoo.com>. All rights reserved.\r\n *\r\n * Redistribution and use in source and binary forms, with or without\r\n * modification, are permitted provided that the following conditions are met:\r\n *\r\n * 1. Redistributions of source code must retain the above copyright notice,\r\n *    this list of conditions and the following disclaimer.\r\n *\r\n * 2. Redistributions in binary form must reproduce the above copyright notice,\r\n *    this list of conditions and the following disclaimer in the documentation\r\n *    and/or other materials provided with the distribution.\r\n *\r\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\r\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\r\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\r\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\r\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\r\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\r\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\r\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\r\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\r\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\r\n * POSSIBILITY OF SUCH DAMAGE.\r\n */\r\nexport const draft = \"2020-12\";\r\nexport const $schema = \"https://json-schema.org/draft/2020-12/schema\";\r\n// -----------------------------------------------------------------------------\r\n/**\r\n * Content encoding strategy enum.\r\n *\r\n * - [Content-Transfer-Encoding Syntax](https://datatracker.ietf.org/doc/html/rfc2045#section-6.1)\r\n * - [7bit vs 8bit encoding](https://stackoverflow.com/questions/25710599/content-transfer-encoding-7bit-or-8-bit/28531705#28531705)\r\n */\r\nexport var ContentEncoding;\r\n(function (ContentEncoding) {\r\n    /**\r\n     * Only US-ASCII characters, which use the lower 7 bits for each character.\r\n     *\r\n     * Each line must be less than 1,000 characters.\r\n     */\r\n    ContentEncoding[\"7bit\"] = \"7bit\";\r\n    /**\r\n     * Allow extended ASCII characters which can use the 8th (highest) bit to\r\n     * indicate special characters not available in 7bit.\r\n     *\r\n     * Each line must be less than 1,000 characters.\r\n     */\r\n    ContentEncoding[\"8bit\"] = \"8bit\";\r\n    /**\r\n     * Useful for data that is mostly non-text.\r\n     */\r\n    ContentEncoding[\"Base64\"] = \"base64\";\r\n    /**\r\n     * Same character set as 8bit, with no line length restriction.\r\n     */\r\n    ContentEncoding[\"Binary\"] = \"binary\";\r\n    /**\r\n     * An extension token defined by a standards-track RFC and registered with\r\n     * IANA.\r\n     */\r\n    ContentEncoding[\"IETFToken\"] = \"ietf-token\";\r\n    /**\r\n     * Lines are limited to 76 characters, and line breaks are represented using\r\n     * special characters that are escaped.\r\n     */\r\n    ContentEncoding[\"QuotedPrintable\"] = \"quoted-printable\";\r\n    /**\r\n     * The two characters \"X-\" or \"x-\" followed, with no intervening white space,\r\n     * by any token.\r\n     */\r\n    ContentEncoding[\"XToken\"] = \"x-token\";\r\n})(ContentEncoding || (ContentEncoding = {}));\r\n/**\r\n * This enum provides well-known formats that apply to strings.\r\n */\r\nexport var Format;\r\n(function (Format) {\r\n    /**\r\n     * A string instance is valid against this attribute if it is a valid\r\n     * representation according to the \"full-date\" production in\r\n     * [RFC 3339][RFC3339].\r\n     *\r\n     * [RFC3339]: https://datatracker.ietf.org/doc/html/rfc3339\r\n     */\r\n    Format[\"Date\"] = \"date\";\r\n    /**\r\n     * A string instance is valid against this attribute if it is a valid\r\n     * representation according to the \"date-time\" production in\r\n     * [RFC 3339][RFC3339].\r\n     *\r\n     * [RFC3339]: https://datatracker.ietf.org/doc/html/rfc3339\r\n     */\r\n    Format[\"DateTime\"] = \"date-time\";\r\n    /**\r\n     * A string instance is valid against this attribute if it is a valid\r\n     * representation according to the \"duration\" production.\r\n     */\r\n    Format[\"Duration\"] = \"duration\";\r\n    /**\r\n     * A string instance is valid against this attribute if it is a valid Internet\r\n     * email address as defined by by the \"Mailbox\" ABNF rule in [RFC\r\n     * 5321][RFC5322], section 4.1.2.\r\n     *\r\n     * [RFC5321]: https://datatracker.ietf.org/doc/html/rfc5321\r\n     */\r\n    Format[\"Email\"] = \"email\";\r\n    /**\r\n     * As defined by [RFC 1123, section 2.1][RFC1123], including host names\r\n     * produced using the Punycode algorithm specified in\r\n     * [RFC 5891, section 4.4][RFC5891].\r\n     *\r\n     * [RFC1123]: https://datatracker.ietf.org/doc/html/rfc1123\r\n     * [RFC5891]: https://datatracker.ietf.org/doc/html/rfc5891\r\n     */\r\n    Format[\"Hostname\"] = \"hostname\";\r\n    /**\r\n     * A string instance is valid against this attribute if it is a valid Internet\r\n     * email address as defined by the extended \"Mailbox\" ABNF rule in\r\n     * [RFC 6531][RFC6531], section 3.3.\r\n     *\r\n     * [RFC6531]: https://datatracker.ietf.org/doc/html/rfc6531\r\n     */\r\n    Format[\"IDNEmail\"] = \"idn-email\";\r\n    /**\r\n     * As defined by either [RFC 1123, section 2.1][RFC1123] as for hostname, or\r\n     * an internationalized hostname as defined by\r\n     * [RFC 5890, section 2.3.2.3][RFC5890].\r\n     *\r\n     * [RFC1123]: https://datatracker.ietf.org/doc/html/rfc1123\r\n     * [RFC5890]: https://datatracker.ietf.org/doc/html/rfc5890\r\n     */\r\n    Format[\"IDNHostname\"] = \"idn-hostname\";\r\n    /**\r\n     * An IPv4 address according to the \"dotted-quad\" ABNF syntax as defined in\r\n     * [RFC 2673, section 3.2][RFC2673].\r\n     *\r\n     * [RFC2673]: https://datatracker.ietf.org/doc/html/rfc2673\r\n     */\r\n    Format[\"IPv4\"] = \"ipv4\";\r\n    /**\r\n     * An IPv6 address as defined in [RFC 4291, section 2.2][RFC4291].\r\n     *\r\n     * [RFC4291]: https://datatracker.ietf.org/doc/html/rfc4291\r\n     */\r\n    Format[\"IPv6\"] = \"ipv6\";\r\n    /**\r\n     * A string instance is valid against this attribute if it is a valid IRI,\r\n     * according to [RFC 3987][RFC3987].\r\n     *\r\n     * [RFC3987]: https://datatracker.ietf.org/doc/html/rfc3987\r\n     */\r\n    Format[\"IRI\"] = \"iri\";\r\n    /**\r\n     * A string instance is valid against this attribute if it is a valid IRI\r\n     * Reference (either an IRI or a relative-reference), according to\r\n     * [RFC 3987][RFC3987].\r\n     *\r\n     * [RFC3987]: https://datatracker.ietf.org/doc/html/rfc3987\r\n     */\r\n    Format[\"IRIReference\"] = \"iri-reference\";\r\n    /**\r\n     * A string instance is valid against this attribute if it is a valid JSON\r\n     * string representation of a JSON Pointer, according to\r\n     * [RFC 6901, section 5][RFC6901].\r\n     *\r\n     * [RFC6901]: https://datatracker.ietf.org/doc/html/rfc6901\r\n     */\r\n    Format[\"JSONPointer\"] = \"json-pointer\";\r\n    /**\r\n     * A string instance is valid against this attribute if it is a valid JSON\r\n     * string representation of a JSON Pointer fragment, according to\r\n     * [RFC 6901, section 5][RFC6901].\r\n     *\r\n     * [RFC6901]: https://datatracker.ietf.org/doc/html/rfc6901\r\n     */\r\n    Format[\"JSONPointerURIFragment\"] = \"json-pointer-uri-fragment\";\r\n    /**\r\n     * This attribute applies to string instances.\r\n     *\r\n     * A regular expression, which SHOULD be valid according to the\r\n     * [ECMA-262][ecma262] regular expression dialect.\r\n     *\r\n     * Implementations that validate formats MUST accept at least the subset of\r\n     * [ECMA-262][ecma262] defined in the [Regular Expressions][regexInterop]\r\n     * section of this specification, and SHOULD accept all valid\r\n     * [ECMA-262][ecma262] expressions.\r\n     *\r\n     * [ecma262]: https://www.ecma-international.org/publications-and-standards/standards/ecma-262/\r\n     * [regexInterop]: https://json-schema.org/draft/2020-12/json-schema-validation.html#regexInterop\r\n     */\r\n    Format[\"RegEx\"] = \"regex\";\r\n    /**\r\n     * A string instance is valid against this attribute if it is a valid\r\n     * [Relative JSON Pointer][relative-json-pointer].\r\n     *\r\n     * [relative-json-pointer]: https://datatracker.ietf.org/doc/html/draft-handrews-relative-json-pointer-01\r\n     */\r\n    Format[\"RelativeJSONPointer\"] = \"relative-json-pointer\";\r\n    /**\r\n     * A string instance is valid against this attribute if it is a valid\r\n     * representation according to the \"time\" production in [RFC 3339][RFC3339].\r\n     *\r\n     * [RFC3339]: https://datatracker.ietf.org/doc/html/rfc3339\r\n     */\r\n    Format[\"Time\"] = \"time\";\r\n    /**\r\n     * A string instance is valid against this attribute if it is a valid URI,\r\n     * according to [RFC3986][RFC3986].\r\n     *\r\n     * [RFC3986]: https://datatracker.ietf.org/doc/html/rfc3986\r\n     */\r\n    Format[\"URI\"] = \"uri\";\r\n    /**\r\n     * A string instance is valid against this attribute if it is a valid URI\r\n     * Reference (either a URI or a relative-reference), according to\r\n     * [RFC3986][RFC3986].\r\n     *\r\n     * [RFC3986]: https://datatracker.ietf.org/doc/html/rfc3986\r\n     */\r\n    Format[\"URIReference\"] = \"uri-reference\";\r\n    /**\r\n     * A string instance is valid against this attribute if it is a valid URI\r\n     * Template (of any level), according to [RFC 6570][RFC6570].\r\n     *\r\n     * Note that URI Templates may be used for IRIs; there is no separate IRI\r\n     * Template specification.\r\n     *\r\n     * [RFC6570]: https://datatracker.ietf.org/doc/html/rfc6570\r\n     */\r\n    Format[\"URITemplate\"] = \"uri-template\";\r\n    /**\r\n     * A string instance is valid against this attribute if it is a valid string\r\n     * representation of a UUID, according to [RFC 4122][RFC4122].\r\n     *\r\n     * [RFC4122]: https://datatracker.ietf.org/doc/html/rfc4122\r\n     */\r\n    Format[\"UUID\"] = \"uuid\";\r\n})(Format || (Format = {}));\r\n/**\r\n * Enum consisting of simple type names for the `type` keyword\r\n */\r\nexport var TypeName;\r\n(function (TypeName) {\r\n    /**\r\n     * Value MUST be an array.\r\n     */\r\n    TypeName[\"Array\"] = \"array\";\r\n    /**\r\n     * Value MUST be a boolean.\r\n     */\r\n    TypeName[\"Boolean\"] = \"boolean\";\r\n    /**\r\n     * Value MUST be an integer, no floating point numbers are allowed. This is a\r\n     * subset of the number type.\r\n     */\r\n    TypeName[\"Integer\"] = \"integer\";\r\n    /**\r\n     * Value MUST be null. Note this is mainly for purpose of being able use union\r\n     * types to define nullability. If this type is not included in a union, null\r\n     * values are not allowed (the primitives listed above do not allow nulls on\r\n     * their own).\r\n     */\r\n    TypeName[\"Null\"] = \"null\";\r\n    /**\r\n     * Value MUST be a number, floating point numbers are allowed.\r\n     */\r\n    TypeName[\"Number\"] = \"number\";\r\n    /**\r\n     * Value MUST be an object.\r\n     */\r\n    TypeName[\"Object\"] = \"object\";\r\n    /**\r\n     * Value MUST be a string.\r\n     */\r\n    TypeName[\"String\"] = \"string\";\r\n})(TypeName || (TypeName = {}));\r\n// -----------------------------------------------------------------------------\r\n// Keywords\r\n// -----------------------------------------------------------------------------\r\nexport const keywords = [\r\n    \"$anchor\",\r\n    \"$comment\",\r\n    \"$defs\",\r\n    \"$dynamicAnchor\",\r\n    \"$dynamicRef\",\r\n    \"$id\",\r\n    \"$ref\",\r\n    \"$schema\",\r\n    \"$vocabulary\",\r\n    \"additionalItems\",\r\n    \"additionalProperties\",\r\n    \"allOf\",\r\n    \"anyOf\",\r\n    \"const\",\r\n    \"contains\",\r\n    \"contentEncoding\",\r\n    \"contentMediaType\",\r\n    \"contentSchema\",\r\n    \"default\",\r\n    \"definitions\",\r\n    \"dependencies\",\r\n    \"dependentRequired\",\r\n    \"dependentSchemas\",\r\n    \"deprecated\",\r\n    \"description\",\r\n    \"else\",\r\n    \"enum\",\r\n    \"examples\",\r\n    \"exclusiveMaximum\",\r\n    \"exclusiveMinimum\",\r\n    \"format\",\r\n    \"if\",\r\n    \"items\",\r\n    \"maxContains\",\r\n    \"maximum\",\r\n    \"maxItems\",\r\n    \"maxLength\",\r\n    \"maxProperties\",\r\n    \"minContains\",\r\n    \"minimum\",\r\n    \"minItems\",\r\n    \"minLength\",\r\n    \"minProperties\",\r\n    \"multipleOf\",\r\n    \"not\",\r\n    \"oneOf\",\r\n    \"pattern\",\r\n    \"patternProperties\",\r\n    \"prefixItems\",\r\n    \"properties\",\r\n    \"propertyNames\",\r\n    \"readOnly\",\r\n    \"required\",\r\n    \"then\",\r\n    \"title\",\r\n    \"type\",\r\n    \"unevaluatedItems\",\r\n    \"unevaluatedProperties\",\r\n    \"uniqueItems\",\r\n    \"writeOnly\",\r\n];\r\n", "import { isORPCErrorStatus, fallbackORPCErrorStatus, fallbackORPCErrorMessage } from '@orpc/client';\nimport { toHttpPath } from '@orpc/client/standard';\nimport { fallbackContractConfig, getEventIteratorSchemaDetails } from '@orpc/contract';\nimport { standardizeHTTPPath, StandardOpenAPIJsonSerializer, getDynamicParams } from '@orpc/openapi-client/standard';\nimport { isProcedure, resolveContractProcedures } from '@orpc/server';\nimport { isObject, stringifyJSON, findDeepMatches, toArray, clone, value } from '@orpc/shared';\nimport { TypeName } from 'json-schema-typed/draft-2020-12';\n\nconst OPERATION_EXTENDER_SYMBOL = Symbol(\"ORPC_OPERATION_EXTENDER\");\nfunction customOpenAPIOperation(o, extend) {\n  return new Proxy(o, {\n    get(target, prop, receiver) {\n      if (prop === OPERATION_EXTENDER_SYMBOL) {\n        return extend;\n      }\n      return Reflect.get(target, prop, receiver);\n    }\n  });\n}\nfunction getCustomOpenAPIOperation(o) {\n  return o[OPERATION_EXTENDER_SYMBOL];\n}\nfunction applyCustomOpenAPIOperation(operation, contract) {\n  const operationCustoms = [];\n  for (const errorItem of Object.values(contract[\"~orpc\"].errorMap)) {\n    const maybeExtender = errorItem ? getCustomOpenAPIOperation(errorItem) : void 0;\n    if (maybeExtender) {\n      operationCustoms.push(maybeExtender);\n    }\n  }\n  if (isProcedure(contract)) {\n    for (const middleware of contract[\"~orpc\"].middlewares) {\n      const maybeExtender = getCustomOpenAPIOperation(middleware);\n      if (maybeExtender) {\n        operationCustoms.push(maybeExtender);\n      }\n    }\n  }\n  let currentOperation = operation;\n  for (const custom of operationCustoms) {\n    if (typeof custom === \"function\") {\n      currentOperation = custom(currentOperation, contract);\n    } else {\n      currentOperation = {\n        ...currentOperation,\n        ...custom\n      };\n    }\n  }\n  return currentOperation;\n}\n\nconst LOGIC_KEYWORDS = [\n  \"$dynamicRef\",\n  \"$ref\",\n  \"additionalItems\",\n  \"additionalProperties\",\n  \"allOf\",\n  \"anyOf\",\n  \"const\",\n  \"contains\",\n  \"contentEncoding\",\n  \"contentMediaType\",\n  \"contentSchema\",\n  \"dependencies\",\n  \"dependentRequired\",\n  \"dependentSchemas\",\n  \"else\",\n  \"enum\",\n  \"exclusiveMaximum\",\n  \"exclusiveMinimum\",\n  \"format\",\n  \"if\",\n  \"items\",\n  \"maxContains\",\n  \"maximum\",\n  \"maxItems\",\n  \"maxLength\",\n  \"maxProperties\",\n  \"minContains\",\n  \"minimum\",\n  \"minItems\",\n  \"minLength\",\n  \"minProperties\",\n  \"multipleOf\",\n  \"not\",\n  \"oneOf\",\n  \"pattern\",\n  \"patternProperties\",\n  \"prefixItems\",\n  \"properties\",\n  \"propertyNames\",\n  \"required\",\n  \"then\",\n  \"type\",\n  \"unevaluatedItems\",\n  \"unevaluatedProperties\",\n  \"uniqueItems\"\n];\n\nfunction isFileSchema(schema) {\n  return isObject(schema) && schema.type === \"string\" && typeof schema.contentMediaType === \"string\";\n}\nfunction isObjectSchema(schema) {\n  return isObject(schema) && schema.type === \"object\";\n}\nfunction isAnySchema(schema) {\n  if (schema === true) {\n    return true;\n  }\n  if (Object.keys(schema).every((k) => !LOGIC_KEYWORDS.includes(k))) {\n    return true;\n  }\n  return false;\n}\nfunction separateObjectSchema(schema, separatedProperties) {\n  if (Object.keys(schema).some(\n    (k) => ![\"type\", \"properties\", \"required\", \"additionalProperties\"].includes(k) && LOGIC_KEYWORDS.includes(k) && schema[k] !== void 0\n  )) {\n    return [{ type: \"object\" }, schema];\n  }\n  const matched = { ...schema };\n  const rest = { ...schema };\n  matched.properties = separatedProperties.reduce((acc, key) => {\n    const keySchema = schema.properties?.[key] ?? schema.additionalProperties;\n    if (keySchema !== void 0) {\n      acc[key] = keySchema;\n    }\n    return acc;\n  }, {});\n  matched.required = schema.required?.filter((key) => separatedProperties.includes(key));\n  matched.examples = schema.examples?.map((example) => {\n    if (!isObject(example)) {\n      return example;\n    }\n    return Object.entries(example).reduce((acc, [key, value]) => {\n      if (separatedProperties.includes(key)) {\n        acc[key] = value;\n      }\n      return acc;\n    }, {});\n  });\n  rest.properties = schema.properties && Object.entries(schema.properties).filter(([key]) => !separatedProperties.includes(key)).reduce((acc, [key, value]) => {\n    acc[key] = value;\n    return acc;\n  }, {});\n  rest.required = schema.required?.filter((key) => !separatedProperties.includes(key));\n  rest.examples = schema.examples?.map((example) => {\n    if (!isObject(example)) {\n      return example;\n    }\n    return Object.entries(example).reduce((acc, [key, value]) => {\n      if (!separatedProperties.includes(key)) {\n        acc[key] = value;\n      }\n      return acc;\n    }, {});\n  });\n  return [matched, rest];\n}\nfunction filterSchemaBranches(schema, check, matches = []) {\n  if (check(schema)) {\n    matches.push(schema);\n    return [matches, void 0];\n  }\n  if (isObject(schema)) {\n    for (const keyword of [\"anyOf\", \"oneOf\"]) {\n      if (schema[keyword] && Object.keys(schema).every(\n        (k) => k === keyword || !LOGIC_KEYWORDS.includes(k)\n      )) {\n        const rest = schema[keyword].map((s) => filterSchemaBranches(s, check, matches)[1]).filter((v) => !!v);\n        if (rest.length === 1 && typeof rest[0] === \"object\") {\n          return [matches, { ...schema, [keyword]: void 0, ...rest[0] }];\n        }\n        return [matches, { ...schema, [keyword]: rest }];\n      }\n    }\n  }\n  return [matches, schema];\n}\nfunction applySchemaOptionality(required, schema) {\n  if (required) {\n    return schema;\n  }\n  return {\n    anyOf: [\n      schema,\n      { not: {} }\n    ]\n  };\n}\nfunction expandUnionSchema(schema) {\n  if (typeof schema === \"object\") {\n    for (const keyword of [\"anyOf\", \"oneOf\"]) {\n      if (schema[keyword] && Object.keys(schema).every(\n        (k) => k === keyword || !LOGIC_KEYWORDS.includes(k)\n      )) {\n        return schema[keyword].flatMap((s) => expandUnionSchema(s));\n      }\n    }\n  }\n  return [schema];\n}\nfunction expandArrayableSchema(schema) {\n  const schemas = expandUnionSchema(schema);\n  if (schemas.length !== 2) {\n    return void 0;\n  }\n  const arraySchema = schemas.find(\n    (s) => typeof s === \"object\" && s.type === \"array\" && Object.keys(s).filter((k) => LOGIC_KEYWORDS.includes(k)).every((k) => k === \"type\" || k === \"items\")\n  );\n  if (arraySchema === void 0) {\n    return void 0;\n  }\n  const items1 = arraySchema.items;\n  const items2 = schemas.find((s) => s !== arraySchema);\n  if (stringifyJSON(items1) !== stringifyJSON(items2)) {\n    return void 0;\n  }\n  return [items2, arraySchema];\n}\nconst PRIMITIVE_SCHEMA_TYPES = /* @__PURE__ */ new Set([\n  TypeName.String,\n  TypeName.Number,\n  TypeName.Integer,\n  TypeName.Boolean,\n  TypeName.Null\n]);\nfunction isPrimitiveSchema(schema) {\n  return expandUnionSchema(schema).every((s) => {\n    if (typeof s === \"boolean\") {\n      return false;\n    }\n    if (typeof s.type === \"string\" && PRIMITIVE_SCHEMA_TYPES.has(s.type)) {\n      return true;\n    }\n    if (s.const !== void 0) {\n      return true;\n    }\n    return false;\n  });\n}\n\nfunction toOpenAPIPath(path) {\n  return standardizeHTTPPath(path).replace(/\\/\\{\\+([^}]+)\\}/g, \"/{$1}\");\n}\nfunction toOpenAPIMethod(method) {\n  return method.toLocaleLowerCase();\n}\nfunction toOpenAPIContent(schema) {\n  const content = {};\n  const [matches, restSchema] = filterSchemaBranches(schema, isFileSchema);\n  for (const file of matches) {\n    content[file.contentMediaType] = {\n      schema: toOpenAPISchema(file)\n    };\n  }\n  if (restSchema !== void 0) {\n    content[\"application/json\"] = {\n      schema: toOpenAPISchema(restSchema)\n    };\n    const isStillHasFileSchema = findDeepMatches((v) => isObject(v) && isFileSchema(v), restSchema).values.length > 0;\n    if (isStillHasFileSchema) {\n      content[\"multipart/form-data\"] = {\n        schema: toOpenAPISchema(restSchema)\n      };\n    }\n  }\n  return content;\n}\nfunction toOpenAPIEventIteratorContent([yieldsRequired, yieldsSchema], [returnsRequired, returnsSchema]) {\n  return {\n    \"text/event-stream\": {\n      schema: toOpenAPISchema({\n        oneOf: [\n          {\n            type: \"object\",\n            properties: {\n              event: { const: \"message\" },\n              data: yieldsSchema,\n              id: { type: \"string\" },\n              retry: { type: \"number\" }\n            },\n            required: yieldsRequired ? [\"event\", \"data\"] : [\"event\"]\n          },\n          {\n            type: \"object\",\n            properties: {\n              event: { const: \"done\" },\n              data: returnsSchema,\n              id: { type: \"string\" },\n              retry: { type: \"number\" }\n            },\n            required: returnsRequired ? [\"event\", \"data\"] : [\"event\"]\n          },\n          {\n            type: \"object\",\n            properties: {\n              event: { const: \"error\" },\n              data: {},\n              id: { type: \"string\" },\n              retry: { type: \"number\" }\n            },\n            required: [\"event\"]\n          }\n        ]\n      })\n    }\n  };\n}\nfunction toOpenAPIParameters(schema, parameterIn) {\n  const parameters = [];\n  for (const key in schema.properties) {\n    const keySchema = schema.properties[key];\n    let isDeepObjectStyle = true;\n    if (parameterIn !== \"query\") {\n      isDeepObjectStyle = false;\n    } else if (isPrimitiveSchema(keySchema)) {\n      isDeepObjectStyle = false;\n    } else {\n      const [item] = expandArrayableSchema(keySchema) ?? [];\n      if (item !== void 0 && isPrimitiveSchema(item)) {\n        isDeepObjectStyle = false;\n      }\n    }\n    parameters.push({\n      name: key,\n      in: parameterIn,\n      required: schema.required?.includes(key),\n      schema: toOpenAPISchema(keySchema),\n      style: isDeepObjectStyle ? \"deepObject\" : void 0,\n      explode: isDeepObjectStyle ? true : void 0,\n      allowEmptyValue: parameterIn === \"query\" ? true : void 0,\n      allowReserved: parameterIn === \"query\" ? true : void 0\n    });\n  }\n  return parameters;\n}\nfunction checkParamsSchema(schema, params) {\n  const properties = Object.keys(schema.properties ?? {});\n  const required = schema.required ?? [];\n  if (properties.length !== params.length || properties.some((v) => !params.includes(v))) {\n    return false;\n  }\n  if (required.length !== params.length || required.some((v) => !params.includes(v))) {\n    return false;\n  }\n  return true;\n}\nfunction toOpenAPISchema(schema) {\n  return schema === true ? {} : schema === false ? { not: {} } : schema;\n}\nconst OPENAPI_JSON_SCHEMA_REF_PREFIX = \"#/components/schemas/\";\nfunction resolveOpenAPIJsonSchemaRef(doc, schema) {\n  if (typeof schema !== \"object\" || !schema.$ref?.startsWith(OPENAPI_JSON_SCHEMA_REF_PREFIX)) {\n    return schema;\n  }\n  const name = schema.$ref.slice(OPENAPI_JSON_SCHEMA_REF_PREFIX.length);\n  const resolved = doc.components?.schemas?.[name];\n  return resolved ?? schema;\n}\nfunction simplifyComposedObjectJsonSchemasAndRefs(schema, doc) {\n  if (doc) {\n    schema = resolveOpenAPIJsonSchemaRef(doc, schema);\n  }\n  if (typeof schema !== \"object\" || !schema.anyOf && !schema.oneOf && !schema.allOf) {\n    return schema;\n  }\n  const unionSchemas = [\n    ...toArray(schema.anyOf?.map((s) => simplifyComposedObjectJsonSchemasAndRefs(s, doc))),\n    ...toArray(schema.oneOf?.map((s) => simplifyComposedObjectJsonSchemasAndRefs(s, doc)))\n  ];\n  const objectUnionSchemas = [];\n  for (const u of unionSchemas) {\n    if (!isObjectSchema(u)) {\n      return schema;\n    }\n    objectUnionSchemas.push(u);\n  }\n  const mergedUnionPropertyMap = /* @__PURE__ */ new Map();\n  for (const u of objectUnionSchemas) {\n    if (u.properties) {\n      for (const [key, value] of Object.entries(u.properties)) {\n        let entry = mergedUnionPropertyMap.get(key);\n        if (!entry) {\n          const required = objectUnionSchemas.every((s) => s.required?.includes(key));\n          entry = { required, schemas: [] };\n          mergedUnionPropertyMap.set(key, entry);\n        }\n        entry.schemas.push(value);\n      }\n    }\n  }\n  const intersectionSchemas = toArray(schema.allOf?.map((s) => simplifyComposedObjectJsonSchemasAndRefs(s, doc)));\n  const objectIntersectionSchemas = [];\n  for (const u of intersectionSchemas) {\n    if (!isObjectSchema(u)) {\n      return schema;\n    }\n    objectIntersectionSchemas.push(u);\n  }\n  if (isObjectSchema(schema)) {\n    objectIntersectionSchemas.push(schema);\n  }\n  const mergedInteractionPropertyMap = /* @__PURE__ */ new Map();\n  for (const u of objectIntersectionSchemas) {\n    if (u.properties) {\n      for (const [key, value] of Object.entries(u.properties)) {\n        let entry = mergedInteractionPropertyMap.get(key);\n        if (!entry) {\n          const required = objectIntersectionSchemas.some((s) => s.required?.includes(key));\n          entry = { required, schemas: [] };\n          mergedInteractionPropertyMap.set(key, entry);\n        }\n        entry.schemas.push(value);\n      }\n    }\n  }\n  const resultObjectSchema = { type: \"object\", properties: {}, required: [] };\n  const keys = /* @__PURE__ */ new Set([\n    ...mergedUnionPropertyMap.keys(),\n    ...mergedInteractionPropertyMap.keys()\n  ]);\n  if (keys.size === 0) {\n    return schema;\n  }\n  const deduplicateSchemas = (schemas) => {\n    const seen = /* @__PURE__ */ new Set();\n    const result = [];\n    for (const schema2 of schemas) {\n      const key = stringifyJSON(schema2);\n      if (!seen.has(key)) {\n        seen.add(key);\n        result.push(schema2);\n      }\n    }\n    return result;\n  };\n  for (const key of keys) {\n    const unionEntry = mergedUnionPropertyMap.get(key);\n    const intersectionEntry = mergedInteractionPropertyMap.get(key);\n    resultObjectSchema.properties[key] = (() => {\n      const dedupedUnionSchemas = unionEntry ? deduplicateSchemas(unionEntry.schemas) : [];\n      const dedupedIntersectionSchemas = intersectionEntry ? deduplicateSchemas(intersectionEntry.schemas) : [];\n      if (!dedupedUnionSchemas.length) {\n        return dedupedIntersectionSchemas.length === 1 ? dedupedIntersectionSchemas[0] : { allOf: dedupedIntersectionSchemas };\n      }\n      if (!dedupedIntersectionSchemas.length) {\n        return dedupedUnionSchemas.length === 1 ? dedupedUnionSchemas[0] : { anyOf: dedupedUnionSchemas };\n      }\n      const allOf = deduplicateSchemas([\n        ...dedupedIntersectionSchemas,\n        dedupedUnionSchemas.length === 1 ? dedupedUnionSchemas[0] : { anyOf: dedupedUnionSchemas }\n      ]);\n      return allOf.length === 1 ? allOf[0] : { allOf };\n    })();\n    if (unionEntry?.required || intersectionEntry?.required) {\n      resultObjectSchema.required.push(key);\n    }\n  }\n  return resultObjectSchema;\n}\n\nclass CompositeSchemaConverter {\n  converters;\n  constructor(converters) {\n    this.converters = converters;\n  }\n  async convert(schema, options) {\n    for (const converter of this.converters) {\n      if (await converter.condition(schema, options)) {\n        return converter.convert(schema, options);\n      }\n    }\n    return [false, {}];\n  }\n}\n\nclass OpenAPIGeneratorError extends Error {\n}\nclass OpenAPIGenerator {\n  serializer;\n  converter;\n  constructor(options = {}) {\n    this.serializer = new StandardOpenAPIJsonSerializer(options);\n    this.converter = new CompositeSchemaConverter(toArray(options.schemaConverters));\n  }\n  /**\n   * Generates OpenAPI specifications from oRPC routers/contracts.\n   *\n   * @see {@link https://orpc.dev/docs/openapi/openapi-specification OpenAPI Specification Docs}\n   */\n  async generate(router, { customErrorResponseBodySchema, commonSchemas, filter: baseFilter, exclude, ...baseDoc } = {}) {\n    const filter = baseFilter ?? (({ contract, path }) => {\n      return !(exclude?.(contract, path) ?? false);\n    });\n    const doc = {\n      ...clone(baseDoc),\n      info: baseDoc.info ?? { title: \"API Reference\", version: \"0.0.0\" },\n      openapi: \"3.1.1\"\n    };\n    const { baseSchemaConvertOptions, undefinedErrorJsonSchema } = await this.#resolveCommonSchemas(doc, commonSchemas);\n    const contracts = [];\n    await resolveContractProcedures({ path: [], router }, (traverseOptions) => {\n      if (!value(filter, traverseOptions)) {\n        return;\n      }\n      contracts.push(traverseOptions);\n    });\n    const errors = [];\n    for (const { contract, path } of contracts) {\n      const stringPath = path.join(\".\");\n      try {\n        const def = contract[\"~orpc\"];\n        const method = toOpenAPIMethod(fallbackContractConfig(\"defaultMethod\", def.route.method));\n        const httpPath = toOpenAPIPath(def.route.path ?? toHttpPath(path));\n        let operationObjectRef;\n        if (def.route.spec !== void 0 && typeof def.route.spec !== \"function\") {\n          operationObjectRef = def.route.spec;\n        } else {\n          operationObjectRef = {\n            operationId: def.route.operationId ?? stringPath,\n            summary: def.route.summary,\n            description: def.route.description,\n            deprecated: def.route.deprecated,\n            tags: def.route.tags?.map((tag) => tag)\n          };\n          await this.#request(doc, operationObjectRef, def, baseSchemaConvertOptions);\n          await this.#successResponse(doc, operationObjectRef, def, baseSchemaConvertOptions);\n          await this.#errorResponse(operationObjectRef, def, baseSchemaConvertOptions, undefinedErrorJsonSchema, customErrorResponseBodySchema);\n        }\n        if (typeof def.route.spec === \"function\") {\n          operationObjectRef = def.route.spec(operationObjectRef);\n        }\n        doc.paths ??= {};\n        doc.paths[httpPath] ??= {};\n        doc.paths[httpPath][method] = applyCustomOpenAPIOperation(operationObjectRef, contract);\n      } catch (e) {\n        if (!(e instanceof OpenAPIGeneratorError)) {\n          throw e;\n        }\n        errors.push(\n          `[OpenAPIGenerator] Error occurred while generating OpenAPI for procedure at path: ${stringPath}\n${e.message}`\n        );\n      }\n    }\n    if (errors.length) {\n      throw new OpenAPIGeneratorError(\n        `Some error occurred during OpenAPI generation:\n\n${errors.join(\"\\n\\n\")}`\n      );\n    }\n    return this.serializer.serialize(doc)[0];\n  }\n  async #resolveCommonSchemas(doc, commonSchemas) {\n    let undefinedErrorJsonSchema = {\n      type: \"object\",\n      properties: {\n        defined: { const: false },\n        code: { type: \"string\" },\n        status: { type: \"number\" },\n        message: { type: \"string\" },\n        data: {}\n      },\n      required: [\"defined\", \"code\", \"status\", \"message\"]\n    };\n    const baseSchemaConvertOptions = {};\n    if (commonSchemas) {\n      baseSchemaConvertOptions.components = [];\n      for (const key in commonSchemas) {\n        const options = commonSchemas[key];\n        if (options.schema === void 0) {\n          continue;\n        }\n        const { schema, strategy = \"input\" } = options;\n        const [required, json] = await this.converter.convert(schema, { strategy });\n        const allowedStrategies = [strategy];\n        if (strategy === \"input\") {\n          const [outputRequired, outputJson] = await this.converter.convert(schema, { strategy: \"output\" });\n          if (outputRequired === required && stringifyJSON(outputJson) === stringifyJSON(json)) {\n            allowedStrategies.push(\"output\");\n          }\n        } else if (strategy === \"output\") {\n          const [inputRequired, inputJson] = await this.converter.convert(schema, { strategy: \"input\" });\n          if (inputRequired === required && stringifyJSON(inputJson) === stringifyJSON(json)) {\n            allowedStrategies.push(\"input\");\n          }\n        }\n        baseSchemaConvertOptions.components.push({\n          schema,\n          required,\n          ref: `#/components/schemas/${key}`,\n          allowedStrategies\n        });\n      }\n      doc.components ??= {};\n      doc.components.schemas ??= {};\n      for (const key in commonSchemas) {\n        const options = commonSchemas[key];\n        if (options.schema === void 0) {\n          if (options.error === \"UndefinedError\") {\n            doc.components.schemas[key] = toOpenAPISchema(undefinedErrorJsonSchema);\n            undefinedErrorJsonSchema = { $ref: `#/components/schemas/${key}` };\n          }\n          continue;\n        }\n        const { schema, strategy = \"input\" } = options;\n        const [, json] = await this.converter.convert(\n          schema,\n          {\n            ...baseSchemaConvertOptions,\n            strategy,\n            minStructureDepthForRef: 1\n            // not allow use $ref for root schemas\n          }\n        );\n        doc.components.schemas[key] = toOpenAPISchema(json);\n      }\n    }\n    return { baseSchemaConvertOptions, undefinedErrorJsonSchema };\n  }\n  async #request(doc, ref, def, baseSchemaConvertOptions) {\n    const method = fallbackContractConfig(\"defaultMethod\", def.route.method);\n    const details = getEventIteratorSchemaDetails(def.inputSchema);\n    if (details) {\n      ref.requestBody = {\n        required: true,\n        content: toOpenAPIEventIteratorContent(\n          await this.converter.convert(details.yields, { ...baseSchemaConvertOptions, strategy: \"input\" }),\n          await this.converter.convert(details.returns, { ...baseSchemaConvertOptions, strategy: \"input\" })\n        )\n      };\n      return;\n    }\n    const dynamicParams = getDynamicParams(def.route.path)?.map((v) => v.name);\n    const inputStructure = fallbackContractConfig(\"defaultInputStructure\", def.route.inputStructure);\n    let [required, schema] = await this.converter.convert(\n      def.inputSchema,\n      {\n        ...baseSchemaConvertOptions,\n        strategy: \"input\"\n      }\n    );\n    if (isAnySchema(schema) && !dynamicParams?.length) {\n      return;\n    }\n    if (inputStructure === \"detailed\" || inputStructure === \"compact\" && (dynamicParams?.length || method === \"GET\")) {\n      schema = simplifyComposedObjectJsonSchemasAndRefs(schema, doc);\n    }\n    if (inputStructure === \"compact\") {\n      if (dynamicParams?.length) {\n        const error2 = new OpenAPIGeneratorError(\n          'When input structure is \"compact\", and path has dynamic params, input schema must be an object with all dynamic params as required.'\n        );\n        if (!isObjectSchema(schema)) {\n          throw error2;\n        }\n        const [paramsSchema, rest] = separateObjectSchema(schema, dynamicParams);\n        schema = rest;\n        required = rest.required ? rest.required.length !== 0 : false;\n        if (!checkParamsSchema(paramsSchema, dynamicParams)) {\n          throw error2;\n        }\n        ref.parameters ??= [];\n        ref.parameters.push(...toOpenAPIParameters(paramsSchema, \"path\"));\n      }\n      if (method === \"GET\") {\n        if (!isObjectSchema(schema)) {\n          throw new OpenAPIGeneratorError(\n            'When method is \"GET\", input schema must satisfy: object | any | unknown'\n          );\n        }\n        ref.parameters ??= [];\n        ref.parameters.push(...toOpenAPIParameters(schema, \"query\"));\n      } else {\n        ref.requestBody = {\n          required,\n          content: toOpenAPIContent(schema)\n        };\n      }\n      return;\n    }\n    const error = new OpenAPIGeneratorError(\n      'When input structure is \"detailed\", input schema must satisfy: { params?: Record<string, unknown>, query?: Record<string, unknown>, headers?: Record<string, unknown>, body?: unknown }'\n    );\n    if (!isObjectSchema(schema)) {\n      throw error;\n    }\n    const resolvedParamSchema = schema.properties?.params !== void 0 ? simplifyComposedObjectJsonSchemasAndRefs(schema.properties.params, doc) : void 0;\n    if (dynamicParams?.length && (resolvedParamSchema === void 0 || !isObjectSchema(resolvedParamSchema) || !checkParamsSchema(resolvedParamSchema, dynamicParams))) {\n      throw new OpenAPIGeneratorError(\n        'When input structure is \"detailed\" and path has dynamic params, the \"params\" schema must be an object with all dynamic params as required.'\n      );\n    }\n    for (const from of [\"params\", \"query\", \"headers\"]) {\n      const fromSchema = schema.properties?.[from];\n      if (fromSchema !== void 0) {\n        const resolvedSchema = simplifyComposedObjectJsonSchemasAndRefs(fromSchema, doc);\n        if (!isObjectSchema(resolvedSchema)) {\n          throw error;\n        }\n        const parameterIn = from === \"params\" ? \"path\" : from === \"headers\" ? \"header\" : \"query\";\n        ref.parameters ??= [];\n        ref.parameters.push(...toOpenAPIParameters(resolvedSchema, parameterIn));\n      }\n    }\n    if (schema.properties?.body !== void 0) {\n      ref.requestBody = {\n        required: schema.required?.includes(\"body\"),\n        content: toOpenAPIContent(schema.properties.body)\n      };\n    }\n  }\n  async #successResponse(doc, ref, def, baseSchemaConvertOptions) {\n    const outputSchema = def.outputSchema;\n    const status = fallbackContractConfig(\"defaultSuccessStatus\", def.route.successStatus);\n    const description = fallbackContractConfig(\"defaultSuccessDescription\", def.route?.successDescription);\n    const eventIteratorSchemaDetails = getEventIteratorSchemaDetails(outputSchema);\n    const outputStructure = fallbackContractConfig(\"defaultOutputStructure\", def.route.outputStructure);\n    if (eventIteratorSchemaDetails) {\n      ref.responses ??= {};\n      ref.responses[status] = {\n        description,\n        content: toOpenAPIEventIteratorContent(\n          await this.converter.convert(eventIteratorSchemaDetails.yields, { ...baseSchemaConvertOptions, strategy: \"output\" }),\n          await this.converter.convert(eventIteratorSchemaDetails.returns, { ...baseSchemaConvertOptions, strategy: \"output\" })\n        )\n      };\n      return;\n    }\n    const [required, json] = await this.converter.convert(\n      outputSchema,\n      {\n        ...baseSchemaConvertOptions,\n        strategy: \"output\",\n        minStructureDepthForRef: outputStructure === \"detailed\" ? 1 : 0\n      }\n    );\n    if (outputStructure === \"compact\") {\n      ref.responses ??= {};\n      ref.responses[status] = {\n        description\n      };\n      ref.responses[status].content = toOpenAPIContent(applySchemaOptionality(required, json));\n      return;\n    }\n    const handledStatuses = /* @__PURE__ */ new Set();\n    for (const item of expandUnionSchema(json)) {\n      const error = new OpenAPIGeneratorError(`\n        When output structure is \"detailed\", output schema must satisfy:\n        { \n          status?: number, // must be a literal number and in the range of 200-399\n          headers?: Record<string, unknown>, \n          body?: unknown \n        }\n        \n        But got: ${stringifyJSON(item)}\n      `);\n      const simplifiedItem = simplifyComposedObjectJsonSchemasAndRefs(item, doc);\n      if (!isObjectSchema(simplifiedItem)) {\n        throw error;\n      }\n      let schemaStatus;\n      let schemaDescription;\n      if (simplifiedItem.properties?.status !== void 0) {\n        const statusSchema = resolveOpenAPIJsonSchemaRef(doc, simplifiedItem.properties.status);\n        if (typeof statusSchema !== \"object\" || statusSchema.const === void 0 || typeof statusSchema.const !== \"number\" || !Number.isInteger(statusSchema.const) || isORPCErrorStatus(statusSchema.const)) {\n          throw error;\n        }\n        schemaStatus = statusSchema.const;\n        schemaDescription = statusSchema.description;\n      }\n      const itemStatus = schemaStatus ?? status;\n      const itemDescription = schemaDescription ?? description;\n      if (handledStatuses.has(itemStatus)) {\n        throw new OpenAPIGeneratorError(`\n          When output structure is \"detailed\", each success status must be unique.\n          But got status: ${itemStatus} used more than once.\n        `);\n      }\n      handledStatuses.add(itemStatus);\n      ref.responses ??= {};\n      ref.responses[itemStatus] = {\n        description: itemDescription\n      };\n      if (simplifiedItem.properties?.headers !== void 0) {\n        const headersSchema = simplifyComposedObjectJsonSchemasAndRefs(simplifiedItem.properties.headers, doc);\n        if (!isObjectSchema(headersSchema)) {\n          throw error;\n        }\n        for (const key in headersSchema.properties) {\n          const headerSchema = headersSchema.properties[key];\n          if (headerSchema !== void 0) {\n            ref.responses[itemStatus].headers ??= {};\n            ref.responses[itemStatus].headers[key] = {\n              schema: toOpenAPISchema(headerSchema),\n              required: simplifiedItem.required?.includes(\"headers\") && headersSchema.required?.includes(key)\n            };\n          }\n        }\n      }\n      if (simplifiedItem.properties?.body !== void 0) {\n        ref.responses[itemStatus].content = toOpenAPIContent(\n          applySchemaOptionality(simplifiedItem.required?.includes(\"body\") ?? false, simplifiedItem.properties.body)\n        );\n      }\n    }\n  }\n  async #errorResponse(ref, def, baseSchemaConvertOptions, undefinedErrorSchema, customErrorResponseBodySchema) {\n    const errorMap = def.errorMap;\n    const errorResponsesByStatus = {};\n    for (const code in errorMap) {\n      const config = errorMap[code];\n      if (!config) {\n        continue;\n      }\n      const status = fallbackORPCErrorStatus(code, config.status);\n      const defaultMessage = fallbackORPCErrorMessage(code, config.message);\n      errorResponsesByStatus[status] ??= { status, definedErrorDefinitions: [], errorSchemaVariants: [] };\n      const [dataRequired, dataSchema] = await this.converter.convert(config.data, { ...baseSchemaConvertOptions, strategy: \"output\" });\n      errorResponsesByStatus[status].definedErrorDefinitions.push([code, defaultMessage, dataRequired, dataSchema]);\n      errorResponsesByStatus[status].errorSchemaVariants.push({\n        type: \"object\",\n        properties: {\n          defined: { const: true },\n          code: { const: code },\n          status: { const: status },\n          message: { type: \"string\", default: defaultMessage },\n          data: dataSchema\n        },\n        required: dataRequired ? [\"defined\", \"code\", \"status\", \"message\", \"data\"] : [\"defined\", \"code\", \"status\", \"message\"]\n      });\n    }\n    ref.responses ??= {};\n    for (const statusString in errorResponsesByStatus) {\n      const errorResponse = errorResponsesByStatus[statusString];\n      const customBodySchema = value(customErrorResponseBodySchema, errorResponse.definedErrorDefinitions, errorResponse.status);\n      ref.responses[statusString] = {\n        description: statusString,\n        content: toOpenAPIContent(customBodySchema ?? {\n          oneOf: [\n            ...errorResponse.errorSchemaVariants,\n            undefinedErrorSchema\n          ]\n        })\n      };\n    }\n  }\n}\n\nexport { CompositeSchemaConverter as C, LOGIC_KEYWORDS as L, OpenAPIGenerator as O, applyCustomOpenAPIOperation as a, toOpenAPIMethod as b, customOpenAPIOperation as c, toOpenAPIContent as d, toOpenAPIEventIteratorContent as e, toOpenAPIParameters as f, getCustomOpenAPIOperation as g, checkParamsSchema as h, toOpenAPISchema as i, isFileSchema as j, isObjectSchema as k, isAnySchema as l, separateObjectSchema as m, filterSchemaBranches as n, applySchemaOptionality as o, expandUnionSchema as p, expandArrayableSchema as q, resolveOpenAPIJsonSchemaRef as r, simplifyComposedObjectJsonSchemasAndRefs as s, toOpenAPIPath as t, isPrimitiveSchema as u };\n", "import { c as customOpenAPIOperation } from './shared/openapi.CoREqFh3.mjs';\nexport { C as CompositeSchemaConverter, L as LOGIC_KEYWORDS, O as OpenAPIGenerator, a as applyCustomOpenAPIOperation, o as applySchemaOptionality, h as checkParamsSchema, q as expandArrayableSchema, p as expandUnionSchema, n as filterSchemaBranches, g as getCustomOpenAPIOperation, l as isAnySchema, j as isFileSchema, k as isObjectSchema, u as isPrimitiveSchema, r as resolveOpenAPIJsonSchemaRef, m as separateObjectSchema, s as simplifyComposedObjectJsonSchemasAndRefs, d as toOpenAPIContent, e as toOpenAPIEventIteratorContent, b as toOpenAPIMethod, f as toOpenAPIParameters, t as toOpenAPIPath, i as toOpenAPISchema } from './shared/openapi.CoREqFh3.mjs';\nimport { createORPCErrorFromJson } from '@orpc/client';\nimport { StandardOpenAPISerializer, StandardOpenAPIJsonSerializer, StandardBracketNotationSerializer } from '@orpc/openapi-client/standard';\nimport { ORPCError, createRouterClient } from '@orpc/server';\nimport { resolveMaybeOptionalOptions } from '@orpc/shared';\nexport { ContentEncoding as JSONSchemaContentEncoding, Format as JSONSchemaFormat, TypeName as JSONSchemaTypeName } from 'json-schema-typed/draft-2020-12';\nimport '@orpc/client/standard';\nimport '@orpc/contract';\n\nfunction createJsonifiedRouterClient(router, ...rest) {\n  const options = resolveMaybeOptionalOptions(rest);\n  const serializer = new StandardOpenAPISerializer(new StandardOpenAPIJsonSerializer(), new StandardBracketNotationSerializer());\n  options.interceptors ??= [];\n  options.interceptors.unshift(async (options2) => {\n    try {\n      return serializer.deserialize(\n        serializer.serialize(\n          await options2.next()\n        )\n      );\n    } catch (e) {\n      if (e instanceof ORPCError) {\n        throw createORPCErrorFromJson(serializer.deserialize(\n          serializer.serialize(\n            e.toJSON(),\n            { outputFormat: \"plain\" }\n          )\n        ));\n      }\n      throw e;\n    }\n  });\n  return createRouterClient(router, options);\n}\n\nconst oo = {\n  spec: customOpenAPIOperation\n};\n\nexport { createJsonifiedRouterClient, customOpenAPIOperation, oo };\n"],
  "mappings": "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",
  "names": ["value", "value", "ContentEncoding", "Format", "TypeName", "value"]
}
