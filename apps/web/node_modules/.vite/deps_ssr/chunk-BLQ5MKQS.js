import {
  createRouterClient
} from "./chunk-ZG5GZ3TY.js";
import {
  fallbackContractConfig,
  getEventIteratorSchemaDetails,
  isProcedure,
  resolveContractProcedures
} from "./chunk-EGHEV2Q4.js";
import {
  toHttpPath
} from "./chunk-TU47NT6S.js";
import {
  ErrorEvent,
  ORPCError,
  createORPCErrorFromJson,
  fallbackORPCErrorMessage,
  fallbackORPCErrorStatus,
  isORPCErrorJson,
  isORPCErrorStatus,
  mapEventIterator,
  toORPCError
} from "./chunk-4MT5BNIL.js";
import {
  NullProtoObj,
  clone,
  findDeepMatches,
  isAsyncIteratorObject,
  isObject,
  resolveMaybeOptionalOptions,
  stringifyJSON,
  toArray,
  value
} from "./chunk-FX53GUXJ.js";

// ../../node_modules/.bun/@orpc+openapi-client@1.13.4+460773ef8ff1e07c/node_modules/@orpc/openapi-client/dist/shared/openapi-client.t9fCAe3x.mjs
var StandardBracketNotationSerializer = class {
  maxArrayIndex;
  constructor(options = {}) {
    this.maxArrayIndex = options.maxBracketNotationArrayIndex ?? 9999;
  }
  serialize(data, segments = [], result = []) {
    if (Array.isArray(data)) {
      data.forEach((item, i) => {
        this.serialize(item, [...segments, i], result);
      });
    } else if (isObject(data)) {
      for (const key in data) {
        this.serialize(data[key], [...segments, key], result);
      }
    } else {
      result.push([this.stringifyPath(segments), data]);
    }
    return result;
  }
  deserialize(serialized) {
    if (serialized.length === 0) {
      return {};
    }
    const arrayPushStyles = /* @__PURE__ */ new WeakSet();
    const ref = { value: [] };
    for (const [path, value2] of serialized) {
      const segments = this.parsePath(path);
      let currentRef = ref;
      let nextSegment = "value";
      segments.forEach((segment, i) => {
        if (!Array.isArray(currentRef[nextSegment]) && !isObject(currentRef[nextSegment])) {
          currentRef[nextSegment] = [];
        }
        if (i !== segments.length - 1) {
          if (Array.isArray(currentRef[nextSegment]) && !isValidArrayIndex(segment, this.maxArrayIndex)) {
            if (arrayPushStyles.has(currentRef[nextSegment])) {
              arrayPushStyles.delete(currentRef[nextSegment]);
              currentRef[nextSegment] = pushStyleArrayToObject(currentRef[nextSegment]);
            } else {
              currentRef[nextSegment] = arrayToObject(currentRef[nextSegment]);
            }
          }
        } else {
          if (Array.isArray(currentRef[nextSegment])) {
            if (segment === "") {
              if (currentRef[nextSegment].length && !arrayPushStyles.has(currentRef[nextSegment])) {
                currentRef[nextSegment] = arrayToObject(currentRef[nextSegment]);
              }
            } else {
              if (arrayPushStyles.has(currentRef[nextSegment])) {
                arrayPushStyles.delete(currentRef[nextSegment]);
                currentRef[nextSegment] = pushStyleArrayToObject(currentRef[nextSegment]);
              } else if (!isValidArrayIndex(segment, this.maxArrayIndex)) {
                currentRef[nextSegment] = arrayToObject(currentRef[nextSegment]);
              }
            }
          }
        }
        currentRef = currentRef[nextSegment];
        nextSegment = segment;
      });
      if (Array.isArray(currentRef) && nextSegment === "") {
        arrayPushStyles.add(currentRef);
        currentRef.push(value2);
      } else if (nextSegment in currentRef) {
        if (Array.isArray(currentRef[nextSegment])) {
          currentRef[nextSegment].push(value2);
        } else {
          currentRef[nextSegment] = [currentRef[nextSegment], value2];
        }
      } else {
        currentRef[nextSegment] = value2;
      }
    }
    return ref.value;
  }
  stringifyPath(segments) {
    return segments.map((segment) => {
      return segment.toString().replace(/[\\[\]]/g, (match) => {
        switch (match) {
          case "\\":
            return "\\\\";
          case "[":
            return "\\[";
          case "]":
            return "\\]";
          /* v8 ignore next 2 */
          default:
            return match;
        }
      });
    }).reduce((result, segment, i) => {
      if (i === 0) {
        return segment;
      }
      return `${result}[${segment}]`;
    }, "");
  }
  parsePath(path) {
    const segments = [];
    let inBrackets = false;
    let currentSegment = "";
    let backslashCount = 0;
    for (let i = 0; i < path.length; i++) {
      const char = path[i];
      const nextChar = path[i + 1];
      if (inBrackets && char === "]" && (nextChar === void 0 || nextChar === "[") && backslashCount % 2 === 0) {
        if (nextChar === void 0) {
          inBrackets = false;
        }
        segments.push(currentSegment);
        currentSegment = "";
        i++;
      } else if (segments.length === 0 && char === "[" && backslashCount % 2 === 0) {
        inBrackets = true;
        segments.push(currentSegment);
        currentSegment = "";
      } else if (char === "\\") {
        backslashCount++;
      } else {
        currentSegment += "\\".repeat(backslashCount / 2) + char;
        backslashCount = 0;
      }
    }
    return inBrackets || segments.length === 0 ? [path] : segments;
  }
};
function isValidArrayIndex(value2, maxIndex) {
  return /^0$|^[1-9]\d*$/.test(value2) && Number(value2) <= maxIndex;
}
function arrayToObject(array) {
  const obj = new NullProtoObj();
  array.forEach((item, i) => {
    obj[i] = item;
  });
  return obj;
}
function pushStyleArrayToObject(array) {
  const obj = new NullProtoObj();
  obj[""] = array.length === 1 ? array[0] : array;
  return obj;
}

// ../../node_modules/.bun/@orpc+openapi-client@1.13.4+460773ef8ff1e07c/node_modules/@orpc/openapi-client/dist/shared/openapi-client.B2Q9qU5m.mjs
var StandardOpenAPIJsonSerializer = class {
  customSerializers;
  constructor(options = {}) {
    this.customSerializers = options.customJsonSerializers ?? [];
  }
  serialize(data, hasBlobRef = { value: false }) {
    for (const custom of this.customSerializers) {
      if (custom.condition(data)) {
        const result = this.serialize(custom.serialize(data), hasBlobRef);
        return result;
      }
    }
    if (data instanceof Blob) {
      hasBlobRef.value = true;
      return [data, hasBlobRef.value];
    }
    if (data instanceof Set) {
      return this.serialize(Array.from(data), hasBlobRef);
    }
    if (data instanceof Map) {
      return this.serialize(Array.from(data.entries()), hasBlobRef);
    }
    if (Array.isArray(data)) {
      const json = data.map((v) => v === void 0 ? null : this.serialize(v, hasBlobRef)[0]);
      return [json, hasBlobRef.value];
    }
    if (isObject(data)) {
      const json = {};
      for (const k in data) {
        if (k === "toJSON" && typeof data[k] === "function") {
          continue;
        }
        json[k] = this.serialize(data[k], hasBlobRef)[0];
      }
      return [json, hasBlobRef.value];
    }
    if (typeof data === "bigint" || data instanceof RegExp || data instanceof URL) {
      return [data.toString(), hasBlobRef.value];
    }
    if (data instanceof Date) {
      return [Number.isNaN(data.getTime()) ? null : data.toISOString(), hasBlobRef.value];
    }
    if (Number.isNaN(data)) {
      return [null, hasBlobRef.value];
    }
    return [data, hasBlobRef.value];
  }
};
function standardizeHTTPPath(path) {
  return `/${path.replace(/\/{2,}/g, "/").replace(/^\/|\/$/g, "")}`;
}
function getDynamicParams(path) {
  return path ? standardizeHTTPPath(path).match(/\/\{[^}]+\}/g)?.map((v) => ({
    raw: v,
    name: v.match(/\{\+?([^}]+)\}/)[1]
  })) : void 0;
}
var StandardOpenAPISerializer = class {
  constructor(jsonSerializer, bracketNotation) {
    this.jsonSerializer = jsonSerializer;
    this.bracketNotation = bracketNotation;
  }
  serialize(data, options = {}) {
    if (isAsyncIteratorObject(data) && !options.outputFormat) {
      return mapEventIterator(data, {
        value: async (value2) => this.#serialize(value2, { outputFormat: "plain" }),
        error: async (e) => {
          return new ErrorEvent({
            data: this.#serialize(toORPCError(e).toJSON(), { outputFormat: "plain" }),
            cause: e
          });
        }
      });
    }
    return this.#serialize(data, options);
  }
  #serialize(data, options) {
    const [json, hasBlob] = this.jsonSerializer.serialize(data);
    if (options.outputFormat === "plain") {
      return json;
    }
    if (options.outputFormat === "URLSearchParams") {
      const params = new URLSearchParams();
      for (const [path, value2] of this.bracketNotation.serialize(json)) {
        if (typeof value2 === "string" || typeof value2 === "number" || typeof value2 === "boolean") {
          params.append(path, value2.toString());
        }
      }
      return params;
    }
    if (json instanceof Blob || json === void 0 || !hasBlob) {
      return json;
    }
    const form = new FormData();
    for (const [path, value2] of this.bracketNotation.serialize(json)) {
      if (typeof value2 === "string" || typeof value2 === "number" || typeof value2 === "boolean") {
        form.append(path, value2.toString());
      } else if (value2 instanceof Blob) {
        form.append(path, value2);
      }
    }
    return form;
  }
  deserialize(data) {
    if (data instanceof URLSearchParams || data instanceof FormData) {
      return this.bracketNotation.deserialize(Array.from(data.entries()));
    }
    if (isAsyncIteratorObject(data)) {
      return mapEventIterator(data, {
        value: async (value2) => value2,
        error: async (e) => {
          if (e instanceof ErrorEvent && isORPCErrorJson(e.data)) {
            return createORPCErrorFromJson(e.data, { cause: e });
          }
          return e;
        }
      });
    }
    return data;
  }
};

// ../../node_modules/.bun/json-schema-typed@8.0.2/node_modules/json-schema-typed/draft_2020_12.js
var ContentEncoding;
(function(ContentEncoding2) {
  ContentEncoding2["7bit"] = "7bit";
  ContentEncoding2["8bit"] = "8bit";
  ContentEncoding2["Base64"] = "base64";
  ContentEncoding2["Binary"] = "binary";
  ContentEncoding2["IETFToken"] = "ietf-token";
  ContentEncoding2["QuotedPrintable"] = "quoted-printable";
  ContentEncoding2["XToken"] = "x-token";
})(ContentEncoding || (ContentEncoding = {}));
var Format;
(function(Format2) {
  Format2["Date"] = "date";
  Format2["DateTime"] = "date-time";
  Format2["Duration"] = "duration";
  Format2["Email"] = "email";
  Format2["Hostname"] = "hostname";
  Format2["IDNEmail"] = "idn-email";
  Format2["IDNHostname"] = "idn-hostname";
  Format2["IPv4"] = "ipv4";
  Format2["IPv6"] = "ipv6";
  Format2["IRI"] = "iri";
  Format2["IRIReference"] = "iri-reference";
  Format2["JSONPointer"] = "json-pointer";
  Format2["JSONPointerURIFragment"] = "json-pointer-uri-fragment";
  Format2["RegEx"] = "regex";
  Format2["RelativeJSONPointer"] = "relative-json-pointer";
  Format2["Time"] = "time";
  Format2["URI"] = "uri";
  Format2["URIReference"] = "uri-reference";
  Format2["URITemplate"] = "uri-template";
  Format2["UUID"] = "uuid";
})(Format || (Format = {}));
var TypeName;
(function(TypeName2) {
  TypeName2["Array"] = "array";
  TypeName2["Boolean"] = "boolean";
  TypeName2["Integer"] = "integer";
  TypeName2["Null"] = "null";
  TypeName2["Number"] = "number";
  TypeName2["Object"] = "object";
  TypeName2["String"] = "string";
})(TypeName || (TypeName = {}));

// ../../node_modules/.bun/@orpc+openapi@1.13.4+64f0629d09b745d9/node_modules/@orpc/openapi/dist/shared/openapi.CoREqFh3.mjs
var OPERATION_EXTENDER_SYMBOL = /* @__PURE__ */ Symbol("ORPC_OPERATION_EXTENDER");
function customOpenAPIOperation(o, extend) {
  return new Proxy(o, {
    get(target, prop, receiver) {
      if (prop === OPERATION_EXTENDER_SYMBOL) {
        return extend;
      }
      return Reflect.get(target, prop, receiver);
    }
  });
}
function getCustomOpenAPIOperation(o) {
  return o[OPERATION_EXTENDER_SYMBOL];
}
function applyCustomOpenAPIOperation(operation, contract) {
  const operationCustoms = [];
  for (const errorItem of Object.values(contract["~orpc"].errorMap)) {
    const maybeExtender = errorItem ? getCustomOpenAPIOperation(errorItem) : void 0;
    if (maybeExtender) {
      operationCustoms.push(maybeExtender);
    }
  }
  if (isProcedure(contract)) {
    for (const middleware of contract["~orpc"].middlewares) {
      const maybeExtender = getCustomOpenAPIOperation(middleware);
      if (maybeExtender) {
        operationCustoms.push(maybeExtender);
      }
    }
  }
  let currentOperation = operation;
  for (const custom of operationCustoms) {
    if (typeof custom === "function") {
      currentOperation = custom(currentOperation, contract);
    } else {
      currentOperation = {
        ...currentOperation,
        ...custom
      };
    }
  }
  return currentOperation;
}
var LOGIC_KEYWORDS = [
  "$dynamicRef",
  "$ref",
  "additionalItems",
  "additionalProperties",
  "allOf",
  "anyOf",
  "const",
  "contains",
  "contentEncoding",
  "contentMediaType",
  "contentSchema",
  "dependencies",
  "dependentRequired",
  "dependentSchemas",
  "else",
  "enum",
  "exclusiveMaximum",
  "exclusiveMinimum",
  "format",
  "if",
  "items",
  "maxContains",
  "maximum",
  "maxItems",
  "maxLength",
  "maxProperties",
  "minContains",
  "minimum",
  "minItems",
  "minLength",
  "minProperties",
  "multipleOf",
  "not",
  "oneOf",
  "pattern",
  "patternProperties",
  "prefixItems",
  "properties",
  "propertyNames",
  "required",
  "then",
  "type",
  "unevaluatedItems",
  "unevaluatedProperties",
  "uniqueItems"
];
function isFileSchema(schema) {
  return isObject(schema) && schema.type === "string" && typeof schema.contentMediaType === "string";
}
function isObjectSchema(schema) {
  return isObject(schema) && schema.type === "object";
}
function isAnySchema(schema) {
  if (schema === true) {
    return true;
  }
  if (Object.keys(schema).every((k) => !LOGIC_KEYWORDS.includes(k))) {
    return true;
  }
  return false;
}
function separateObjectSchema(schema, separatedProperties) {
  if (Object.keys(schema).some(
    (k) => !["type", "properties", "required", "additionalProperties"].includes(k) && LOGIC_KEYWORDS.includes(k) && schema[k] !== void 0
  )) {
    return [{ type: "object" }, schema];
  }
  const matched = { ...schema };
  const rest = { ...schema };
  matched.properties = separatedProperties.reduce((acc, key) => {
    const keySchema = schema.properties?.[key] ?? schema.additionalProperties;
    if (keySchema !== void 0) {
      acc[key] = keySchema;
    }
    return acc;
  }, {});
  matched.required = schema.required?.filter((key) => separatedProperties.includes(key));
  matched.examples = schema.examples?.map((example) => {
    if (!isObject(example)) {
      return example;
    }
    return Object.entries(example).reduce((acc, [key, value2]) => {
      if (separatedProperties.includes(key)) {
        acc[key] = value2;
      }
      return acc;
    }, {});
  });
  rest.properties = schema.properties && Object.entries(schema.properties).filter(([key]) => !separatedProperties.includes(key)).reduce((acc, [key, value2]) => {
    acc[key] = value2;
    return acc;
  }, {});
  rest.required = schema.required?.filter((key) => !separatedProperties.includes(key));
  rest.examples = schema.examples?.map((example) => {
    if (!isObject(example)) {
      return example;
    }
    return Object.entries(example).reduce((acc, [key, value2]) => {
      if (!separatedProperties.includes(key)) {
        acc[key] = value2;
      }
      return acc;
    }, {});
  });
  return [matched, rest];
}
function filterSchemaBranches(schema, check, matches = []) {
  if (check(schema)) {
    matches.push(schema);
    return [matches, void 0];
  }
  if (isObject(schema)) {
    for (const keyword of ["anyOf", "oneOf"]) {
      if (schema[keyword] && Object.keys(schema).every(
        (k) => k === keyword || !LOGIC_KEYWORDS.includes(k)
      )) {
        const rest = schema[keyword].map((s) => filterSchemaBranches(s, check, matches)[1]).filter((v) => !!v);
        if (rest.length === 1 && typeof rest[0] === "object") {
          return [matches, { ...schema, [keyword]: void 0, ...rest[0] }];
        }
        return [matches, { ...schema, [keyword]: rest }];
      }
    }
  }
  return [matches, schema];
}
function applySchemaOptionality(required, schema) {
  if (required) {
    return schema;
  }
  return {
    anyOf: [
      schema,
      { not: {} }
    ]
  };
}
function expandUnionSchema(schema) {
  if (typeof schema === "object") {
    for (const keyword of ["anyOf", "oneOf"]) {
      if (schema[keyword] && Object.keys(schema).every(
        (k) => k === keyword || !LOGIC_KEYWORDS.includes(k)
      )) {
        return schema[keyword].flatMap((s) => expandUnionSchema(s));
      }
    }
  }
  return [schema];
}
function expandArrayableSchema(schema) {
  const schemas = expandUnionSchema(schema);
  if (schemas.length !== 2) {
    return void 0;
  }
  const arraySchema = schemas.find(
    (s) => typeof s === "object" && s.type === "array" && Object.keys(s).filter((k) => LOGIC_KEYWORDS.includes(k)).every((k) => k === "type" || k === "items")
  );
  if (arraySchema === void 0) {
    return void 0;
  }
  const items1 = arraySchema.items;
  const items2 = schemas.find((s) => s !== arraySchema);
  if (stringifyJSON(items1) !== stringifyJSON(items2)) {
    return void 0;
  }
  return [items2, arraySchema];
}
var PRIMITIVE_SCHEMA_TYPES = /* @__PURE__ */ new Set([
  TypeName.String,
  TypeName.Number,
  TypeName.Integer,
  TypeName.Boolean,
  TypeName.Null
]);
function isPrimitiveSchema(schema) {
  return expandUnionSchema(schema).every((s) => {
    if (typeof s === "boolean") {
      return false;
    }
    if (typeof s.type === "string" && PRIMITIVE_SCHEMA_TYPES.has(s.type)) {
      return true;
    }
    if (s.const !== void 0) {
      return true;
    }
    return false;
  });
}
function toOpenAPIPath(path) {
  return standardizeHTTPPath(path).replace(/\/\{\+([^}]+)\}/g, "/{$1}");
}
function toOpenAPIMethod(method) {
  return method.toLocaleLowerCase();
}
function toOpenAPIContent(schema) {
  const content = {};
  const [matches, restSchema] = filterSchemaBranches(schema, isFileSchema);
  for (const file of matches) {
    content[file.contentMediaType] = {
      schema: toOpenAPISchema(file)
    };
  }
  if (restSchema !== void 0) {
    content["application/json"] = {
      schema: toOpenAPISchema(restSchema)
    };
    const isStillHasFileSchema = findDeepMatches((v) => isObject(v) && isFileSchema(v), restSchema).values.length > 0;
    if (isStillHasFileSchema) {
      content["multipart/form-data"] = {
        schema: toOpenAPISchema(restSchema)
      };
    }
  }
  return content;
}
function toOpenAPIEventIteratorContent([yieldsRequired, yieldsSchema], [returnsRequired, returnsSchema]) {
  return {
    "text/event-stream": {
      schema: toOpenAPISchema({
        oneOf: [
          {
            type: "object",
            properties: {
              event: { const: "message" },
              data: yieldsSchema,
              id: { type: "string" },
              retry: { type: "number" }
            },
            required: yieldsRequired ? ["event", "data"] : ["event"]
          },
          {
            type: "object",
            properties: {
              event: { const: "done" },
              data: returnsSchema,
              id: { type: "string" },
              retry: { type: "number" }
            },
            required: returnsRequired ? ["event", "data"] : ["event"]
          },
          {
            type: "object",
            properties: {
              event: { const: "error" },
              data: {},
              id: { type: "string" },
              retry: { type: "number" }
            },
            required: ["event"]
          }
        ]
      })
    }
  };
}
function toOpenAPIParameters(schema, parameterIn) {
  const parameters = [];
  for (const key in schema.properties) {
    const keySchema = schema.properties[key];
    let isDeepObjectStyle = true;
    if (parameterIn !== "query") {
      isDeepObjectStyle = false;
    } else if (isPrimitiveSchema(keySchema)) {
      isDeepObjectStyle = false;
    } else {
      const [item] = expandArrayableSchema(keySchema) ?? [];
      if (item !== void 0 && isPrimitiveSchema(item)) {
        isDeepObjectStyle = false;
      }
    }
    parameters.push({
      name: key,
      in: parameterIn,
      required: schema.required?.includes(key),
      schema: toOpenAPISchema(keySchema),
      style: isDeepObjectStyle ? "deepObject" : void 0,
      explode: isDeepObjectStyle ? true : void 0,
      allowEmptyValue: parameterIn === "query" ? true : void 0,
      allowReserved: parameterIn === "query" ? true : void 0
    });
  }
  return parameters;
}
function checkParamsSchema(schema, params) {
  const properties = Object.keys(schema.properties ?? {});
  const required = schema.required ?? [];
  if (properties.length !== params.length || properties.some((v) => !params.includes(v))) {
    return false;
  }
  if (required.length !== params.length || required.some((v) => !params.includes(v))) {
    return false;
  }
  return true;
}
function toOpenAPISchema(schema) {
  return schema === true ? {} : schema === false ? { not: {} } : schema;
}
var OPENAPI_JSON_SCHEMA_REF_PREFIX = "#/components/schemas/";
function resolveOpenAPIJsonSchemaRef(doc, schema) {
  if (typeof schema !== "object" || !schema.$ref?.startsWith(OPENAPI_JSON_SCHEMA_REF_PREFIX)) {
    return schema;
  }
  const name = schema.$ref.slice(OPENAPI_JSON_SCHEMA_REF_PREFIX.length);
  const resolved = doc.components?.schemas?.[name];
  return resolved ?? schema;
}
function simplifyComposedObjectJsonSchemasAndRefs(schema, doc) {
  if (doc) {
    schema = resolveOpenAPIJsonSchemaRef(doc, schema);
  }
  if (typeof schema !== "object" || !schema.anyOf && !schema.oneOf && !schema.allOf) {
    return schema;
  }
  const unionSchemas = [
    ...toArray(schema.anyOf?.map((s) => simplifyComposedObjectJsonSchemasAndRefs(s, doc))),
    ...toArray(schema.oneOf?.map((s) => simplifyComposedObjectJsonSchemasAndRefs(s, doc)))
  ];
  const objectUnionSchemas = [];
  for (const u of unionSchemas) {
    if (!isObjectSchema(u)) {
      return schema;
    }
    objectUnionSchemas.push(u);
  }
  const mergedUnionPropertyMap = /* @__PURE__ */ new Map();
  for (const u of objectUnionSchemas) {
    if (u.properties) {
      for (const [key, value2] of Object.entries(u.properties)) {
        let entry = mergedUnionPropertyMap.get(key);
        if (!entry) {
          const required = objectUnionSchemas.every((s) => s.required?.includes(key));
          entry = { required, schemas: [] };
          mergedUnionPropertyMap.set(key, entry);
        }
        entry.schemas.push(value2);
      }
    }
  }
  const intersectionSchemas = toArray(schema.allOf?.map((s) => simplifyComposedObjectJsonSchemasAndRefs(s, doc)));
  const objectIntersectionSchemas = [];
  for (const u of intersectionSchemas) {
    if (!isObjectSchema(u)) {
      return schema;
    }
    objectIntersectionSchemas.push(u);
  }
  if (isObjectSchema(schema)) {
    objectIntersectionSchemas.push(schema);
  }
  const mergedInteractionPropertyMap = /* @__PURE__ */ new Map();
  for (const u of objectIntersectionSchemas) {
    if (u.properties) {
      for (const [key, value2] of Object.entries(u.properties)) {
        let entry = mergedInteractionPropertyMap.get(key);
        if (!entry) {
          const required = objectIntersectionSchemas.some((s) => s.required?.includes(key));
          entry = { required, schemas: [] };
          mergedInteractionPropertyMap.set(key, entry);
        }
        entry.schemas.push(value2);
      }
    }
  }
  const resultObjectSchema = { type: "object", properties: {}, required: [] };
  const keys = /* @__PURE__ */ new Set([
    ...mergedUnionPropertyMap.keys(),
    ...mergedInteractionPropertyMap.keys()
  ]);
  if (keys.size === 0) {
    return schema;
  }
  const deduplicateSchemas = (schemas) => {
    const seen = /* @__PURE__ */ new Set();
    const result = [];
    for (const schema2 of schemas) {
      const key = stringifyJSON(schema2);
      if (!seen.has(key)) {
        seen.add(key);
        result.push(schema2);
      }
    }
    return result;
  };
  for (const key of keys) {
    const unionEntry = mergedUnionPropertyMap.get(key);
    const intersectionEntry = mergedInteractionPropertyMap.get(key);
    resultObjectSchema.properties[key] = (() => {
      const dedupedUnionSchemas = unionEntry ? deduplicateSchemas(unionEntry.schemas) : [];
      const dedupedIntersectionSchemas = intersectionEntry ? deduplicateSchemas(intersectionEntry.schemas) : [];
      if (!dedupedUnionSchemas.length) {
        return dedupedIntersectionSchemas.length === 1 ? dedupedIntersectionSchemas[0] : { allOf: dedupedIntersectionSchemas };
      }
      if (!dedupedIntersectionSchemas.length) {
        return dedupedUnionSchemas.length === 1 ? dedupedUnionSchemas[0] : { anyOf: dedupedUnionSchemas };
      }
      const allOf = deduplicateSchemas([
        ...dedupedIntersectionSchemas,
        dedupedUnionSchemas.length === 1 ? dedupedUnionSchemas[0] : { anyOf: dedupedUnionSchemas }
      ]);
      return allOf.length === 1 ? allOf[0] : { allOf };
    })();
    if (unionEntry?.required || intersectionEntry?.required) {
      resultObjectSchema.required.push(key);
    }
  }
  return resultObjectSchema;
}
var CompositeSchemaConverter = class {
  converters;
  constructor(converters) {
    this.converters = converters;
  }
  async convert(schema, options) {
    for (const converter of this.converters) {
      if (await converter.condition(schema, options)) {
        return converter.convert(schema, options);
      }
    }
    return [false, {}];
  }
};
var OpenAPIGeneratorError = class extends Error {
};
var OpenAPIGenerator = class {
  serializer;
  converter;
  constructor(options = {}) {
    this.serializer = new StandardOpenAPIJsonSerializer(options);
    this.converter = new CompositeSchemaConverter(toArray(options.schemaConverters));
  }
  /**
   * Generates OpenAPI specifications from oRPC routers/contracts.
   *
   * @see {@link https://orpc.dev/docs/openapi/openapi-specification OpenAPI Specification Docs}
   */
  async generate(router, { customErrorResponseBodySchema, commonSchemas, filter: baseFilter, exclude, ...baseDoc } = {}) {
    const filter = baseFilter ?? (({ contract, path }) => {
      return !(exclude?.(contract, path) ?? false);
    });
    const doc = {
      ...clone(baseDoc),
      info: baseDoc.info ?? { title: "API Reference", version: "0.0.0" },
      openapi: "3.1.1"
    };
    const { baseSchemaConvertOptions, undefinedErrorJsonSchema } = await this.#resolveCommonSchemas(doc, commonSchemas);
    const contracts = [];
    await resolveContractProcedures({ path: [], router }, (traverseOptions) => {
      if (!value(filter, traverseOptions)) {
        return;
      }
      contracts.push(traverseOptions);
    });
    const errors = [];
    for (const { contract, path } of contracts) {
      const stringPath = path.join(".");
      try {
        const def = contract["~orpc"];
        const method = toOpenAPIMethod(fallbackContractConfig("defaultMethod", def.route.method));
        const httpPath = toOpenAPIPath(def.route.path ?? toHttpPath(path));
        let operationObjectRef;
        if (def.route.spec !== void 0 && typeof def.route.spec !== "function") {
          operationObjectRef = def.route.spec;
        } else {
          operationObjectRef = {
            operationId: def.route.operationId ?? stringPath,
            summary: def.route.summary,
            description: def.route.description,
            deprecated: def.route.deprecated,
            tags: def.route.tags?.map((tag) => tag)
          };
          await this.#request(doc, operationObjectRef, def, baseSchemaConvertOptions);
          await this.#successResponse(doc, operationObjectRef, def, baseSchemaConvertOptions);
          await this.#errorResponse(operationObjectRef, def, baseSchemaConvertOptions, undefinedErrorJsonSchema, customErrorResponseBodySchema);
        }
        if (typeof def.route.spec === "function") {
          operationObjectRef = def.route.spec(operationObjectRef);
        }
        doc.paths ??= {};
        doc.paths[httpPath] ??= {};
        doc.paths[httpPath][method] = applyCustomOpenAPIOperation(operationObjectRef, contract);
      } catch (e) {
        if (!(e instanceof OpenAPIGeneratorError)) {
          throw e;
        }
        errors.push(
          `[OpenAPIGenerator] Error occurred while generating OpenAPI for procedure at path: ${stringPath}
${e.message}`
        );
      }
    }
    if (errors.length) {
      throw new OpenAPIGeneratorError(
        `Some error occurred during OpenAPI generation:

${errors.join("\n\n")}`
      );
    }
    return this.serializer.serialize(doc)[0];
  }
  async #resolveCommonSchemas(doc, commonSchemas) {
    let undefinedErrorJsonSchema = {
      type: "object",
      properties: {
        defined: { const: false },
        code: { type: "string" },
        status: { type: "number" },
        message: { type: "string" },
        data: {}
      },
      required: ["defined", "code", "status", "message"]
    };
    const baseSchemaConvertOptions = {};
    if (commonSchemas) {
      baseSchemaConvertOptions.components = [];
      for (const key in commonSchemas) {
        const options = commonSchemas[key];
        if (options.schema === void 0) {
          continue;
        }
        const { schema, strategy = "input" } = options;
        const [required, json] = await this.converter.convert(schema, { strategy });
        const allowedStrategies = [strategy];
        if (strategy === "input") {
          const [outputRequired, outputJson] = await this.converter.convert(schema, { strategy: "output" });
          if (outputRequired === required && stringifyJSON(outputJson) === stringifyJSON(json)) {
            allowedStrategies.push("output");
          }
        } else if (strategy === "output") {
          const [inputRequired, inputJson] = await this.converter.convert(schema, { strategy: "input" });
          if (inputRequired === required && stringifyJSON(inputJson) === stringifyJSON(json)) {
            allowedStrategies.push("input");
          }
        }
        baseSchemaConvertOptions.components.push({
          schema,
          required,
          ref: `#/components/schemas/${key}`,
          allowedStrategies
        });
      }
      doc.components ??= {};
      doc.components.schemas ??= {};
      for (const key in commonSchemas) {
        const options = commonSchemas[key];
        if (options.schema === void 0) {
          if (options.error === "UndefinedError") {
            doc.components.schemas[key] = toOpenAPISchema(undefinedErrorJsonSchema);
            undefinedErrorJsonSchema = { $ref: `#/components/schemas/${key}` };
          }
          continue;
        }
        const { schema, strategy = "input" } = options;
        const [, json] = await this.converter.convert(
          schema,
          {
            ...baseSchemaConvertOptions,
            strategy,
            minStructureDepthForRef: 1
            // not allow use $ref for root schemas
          }
        );
        doc.components.schemas[key] = toOpenAPISchema(json);
      }
    }
    return { baseSchemaConvertOptions, undefinedErrorJsonSchema };
  }
  async #request(doc, ref, def, baseSchemaConvertOptions) {
    const method = fallbackContractConfig("defaultMethod", def.route.method);
    const details = getEventIteratorSchemaDetails(def.inputSchema);
    if (details) {
      ref.requestBody = {
        required: true,
        content: toOpenAPIEventIteratorContent(
          await this.converter.convert(details.yields, { ...baseSchemaConvertOptions, strategy: "input" }),
          await this.converter.convert(details.returns, { ...baseSchemaConvertOptions, strategy: "input" })
        )
      };
      return;
    }
    const dynamicParams = getDynamicParams(def.route.path)?.map((v) => v.name);
    const inputStructure = fallbackContractConfig("defaultInputStructure", def.route.inputStructure);
    let [required, schema] = await this.converter.convert(
      def.inputSchema,
      {
        ...baseSchemaConvertOptions,
        strategy: "input"
      }
    );
    if (isAnySchema(schema) && !dynamicParams?.length) {
      return;
    }
    if (inputStructure === "detailed" || inputStructure === "compact" && (dynamicParams?.length || method === "GET")) {
      schema = simplifyComposedObjectJsonSchemasAndRefs(schema, doc);
    }
    if (inputStructure === "compact") {
      if (dynamicParams?.length) {
        const error2 = new OpenAPIGeneratorError(
          'When input structure is "compact", and path has dynamic params, input schema must be an object with all dynamic params as required.'
        );
        if (!isObjectSchema(schema)) {
          throw error2;
        }
        const [paramsSchema, rest] = separateObjectSchema(schema, dynamicParams);
        schema = rest;
        required = rest.required ? rest.required.length !== 0 : false;
        if (!checkParamsSchema(paramsSchema, dynamicParams)) {
          throw error2;
        }
        ref.parameters ??= [];
        ref.parameters.push(...toOpenAPIParameters(paramsSchema, "path"));
      }
      if (method === "GET") {
        if (!isObjectSchema(schema)) {
          throw new OpenAPIGeneratorError(
            'When method is "GET", input schema must satisfy: object | any | unknown'
          );
        }
        ref.parameters ??= [];
        ref.parameters.push(...toOpenAPIParameters(schema, "query"));
      } else {
        ref.requestBody = {
          required,
          content: toOpenAPIContent(schema)
        };
      }
      return;
    }
    const error = new OpenAPIGeneratorError(
      'When input structure is "detailed", input schema must satisfy: { params?: Record<string, unknown>, query?: Record<string, unknown>, headers?: Record<string, unknown>, body?: unknown }'
    );
    if (!isObjectSchema(schema)) {
      throw error;
    }
    const resolvedParamSchema = schema.properties?.params !== void 0 ? simplifyComposedObjectJsonSchemasAndRefs(schema.properties.params, doc) : void 0;
    if (dynamicParams?.length && (resolvedParamSchema === void 0 || !isObjectSchema(resolvedParamSchema) || !checkParamsSchema(resolvedParamSchema, dynamicParams))) {
      throw new OpenAPIGeneratorError(
        'When input structure is "detailed" and path has dynamic params, the "params" schema must be an object with all dynamic params as required.'
      );
    }
    for (const from of ["params", "query", "headers"]) {
      const fromSchema = schema.properties?.[from];
      if (fromSchema !== void 0) {
        const resolvedSchema = simplifyComposedObjectJsonSchemasAndRefs(fromSchema, doc);
        if (!isObjectSchema(resolvedSchema)) {
          throw error;
        }
        const parameterIn = from === "params" ? "path" : from === "headers" ? "header" : "query";
        ref.parameters ??= [];
        ref.parameters.push(...toOpenAPIParameters(resolvedSchema, parameterIn));
      }
    }
    if (schema.properties?.body !== void 0) {
      ref.requestBody = {
        required: schema.required?.includes("body"),
        content: toOpenAPIContent(schema.properties.body)
      };
    }
  }
  async #successResponse(doc, ref, def, baseSchemaConvertOptions) {
    const outputSchema = def.outputSchema;
    const status = fallbackContractConfig("defaultSuccessStatus", def.route.successStatus);
    const description = fallbackContractConfig("defaultSuccessDescription", def.route?.successDescription);
    const eventIteratorSchemaDetails = getEventIteratorSchemaDetails(outputSchema);
    const outputStructure = fallbackContractConfig("defaultOutputStructure", def.route.outputStructure);
    if (eventIteratorSchemaDetails) {
      ref.responses ??= {};
      ref.responses[status] = {
        description,
        content: toOpenAPIEventIteratorContent(
          await this.converter.convert(eventIteratorSchemaDetails.yields, { ...baseSchemaConvertOptions, strategy: "output" }),
          await this.converter.convert(eventIteratorSchemaDetails.returns, { ...baseSchemaConvertOptions, strategy: "output" })
        )
      };
      return;
    }
    const [required, json] = await this.converter.convert(
      outputSchema,
      {
        ...baseSchemaConvertOptions,
        strategy: "output",
        minStructureDepthForRef: outputStructure === "detailed" ? 1 : 0
      }
    );
    if (outputStructure === "compact") {
      ref.responses ??= {};
      ref.responses[status] = {
        description
      };
      ref.responses[status].content = toOpenAPIContent(applySchemaOptionality(required, json));
      return;
    }
    const handledStatuses = /* @__PURE__ */ new Set();
    for (const item of expandUnionSchema(json)) {
      const error = new OpenAPIGeneratorError(`
        When output structure is "detailed", output schema must satisfy:
        { 
          status?: number, // must be a literal number and in the range of 200-399
          headers?: Record<string, unknown>, 
          body?: unknown 
        }
        
        But got: ${stringifyJSON(item)}
      `);
      const simplifiedItem = simplifyComposedObjectJsonSchemasAndRefs(item, doc);
      if (!isObjectSchema(simplifiedItem)) {
        throw error;
      }
      let schemaStatus;
      let schemaDescription;
      if (simplifiedItem.properties?.status !== void 0) {
        const statusSchema = resolveOpenAPIJsonSchemaRef(doc, simplifiedItem.properties.status);
        if (typeof statusSchema !== "object" || statusSchema.const === void 0 || typeof statusSchema.const !== "number" || !Number.isInteger(statusSchema.const) || isORPCErrorStatus(statusSchema.const)) {
          throw error;
        }
        schemaStatus = statusSchema.const;
        schemaDescription = statusSchema.description;
      }
      const itemStatus = schemaStatus ?? status;
      const itemDescription = schemaDescription ?? description;
      if (handledStatuses.has(itemStatus)) {
        throw new OpenAPIGeneratorError(`
          When output structure is "detailed", each success status must be unique.
          But got status: ${itemStatus} used more than once.
        `);
      }
      handledStatuses.add(itemStatus);
      ref.responses ??= {};
      ref.responses[itemStatus] = {
        description: itemDescription
      };
      if (simplifiedItem.properties?.headers !== void 0) {
        const headersSchema = simplifyComposedObjectJsonSchemasAndRefs(simplifiedItem.properties.headers, doc);
        if (!isObjectSchema(headersSchema)) {
          throw error;
        }
        for (const key in headersSchema.properties) {
          const headerSchema = headersSchema.properties[key];
          if (headerSchema !== void 0) {
            ref.responses[itemStatus].headers ??= {};
            ref.responses[itemStatus].headers[key] = {
              schema: toOpenAPISchema(headerSchema),
              required: simplifiedItem.required?.includes("headers") && headersSchema.required?.includes(key)
            };
          }
        }
      }
      if (simplifiedItem.properties?.body !== void 0) {
        ref.responses[itemStatus].content = toOpenAPIContent(
          applySchemaOptionality(simplifiedItem.required?.includes("body") ?? false, simplifiedItem.properties.body)
        );
      }
    }
  }
  async #errorResponse(ref, def, baseSchemaConvertOptions, undefinedErrorSchema, customErrorResponseBodySchema) {
    const errorMap = def.errorMap;
    const errorResponsesByStatus = {};
    for (const code in errorMap) {
      const config = errorMap[code];
      if (!config) {
        continue;
      }
      const status = fallbackORPCErrorStatus(code, config.status);
      const defaultMessage = fallbackORPCErrorMessage(code, config.message);
      errorResponsesByStatus[status] ??= { status, definedErrorDefinitions: [], errorSchemaVariants: [] };
      const [dataRequired, dataSchema] = await this.converter.convert(config.data, { ...baseSchemaConvertOptions, strategy: "output" });
      errorResponsesByStatus[status].definedErrorDefinitions.push([code, defaultMessage, dataRequired, dataSchema]);
      errorResponsesByStatus[status].errorSchemaVariants.push({
        type: "object",
        properties: {
          defined: { const: true },
          code: { const: code },
          status: { const: status },
          message: { type: "string", default: defaultMessage },
          data: dataSchema
        },
        required: dataRequired ? ["defined", "code", "status", "message", "data"] : ["defined", "code", "status", "message"]
      });
    }
    ref.responses ??= {};
    for (const statusString in errorResponsesByStatus) {
      const errorResponse = errorResponsesByStatus[statusString];
      const customBodySchema = value(customErrorResponseBodySchema, errorResponse.definedErrorDefinitions, errorResponse.status);
      ref.responses[statusString] = {
        description: statusString,
        content: toOpenAPIContent(customBodySchema ?? {
          oneOf: [
            ...errorResponse.errorSchemaVariants,
            undefinedErrorSchema
          ]
        })
      };
    }
  }
};

// ../../node_modules/.bun/@orpc+openapi@1.13.4+64f0629d09b745d9/node_modules/@orpc/openapi/dist/index.mjs
function createJsonifiedRouterClient(router, ...rest) {
  const options = resolveMaybeOptionalOptions(rest);
  const serializer = new StandardOpenAPISerializer(new StandardOpenAPIJsonSerializer(), new StandardBracketNotationSerializer());
  options.interceptors ??= [];
  options.interceptors.unshift(async (options2) => {
    try {
      return serializer.deserialize(
        serializer.serialize(
          await options2.next()
        )
      );
    } catch (e) {
      if (e instanceof ORPCError) {
        throw createORPCErrorFromJson(serializer.deserialize(
          serializer.serialize(
            e.toJSON(),
            { outputFormat: "plain" }
          )
        ));
      }
      throw e;
    }
  });
  return createRouterClient(router, options);
}
var oo = {
  spec: customOpenAPIOperation
};

export {
  ContentEncoding,
  Format,
  TypeName,
  customOpenAPIOperation,
  getCustomOpenAPIOperation,
  applyCustomOpenAPIOperation,
  LOGIC_KEYWORDS,
  isFileSchema,
  isObjectSchema,
  isAnySchema,
  separateObjectSchema,
  filterSchemaBranches,
  applySchemaOptionality,
  expandUnionSchema,
  expandArrayableSchema,
  isPrimitiveSchema,
  toOpenAPIPath,
  toOpenAPIMethod,
  toOpenAPIContent,
  toOpenAPIEventIteratorContent,
  toOpenAPIParameters,
  checkParamsSchema,
  toOpenAPISchema,
  resolveOpenAPIJsonSchemaRef,
  simplifyComposedObjectJsonSchemasAndRefs,
  CompositeSchemaConverter,
  OpenAPIGenerator,
  createJsonifiedRouterClient,
  oo
};
//# sourceMappingURL=chunk-BLQ5MKQS.js.map
