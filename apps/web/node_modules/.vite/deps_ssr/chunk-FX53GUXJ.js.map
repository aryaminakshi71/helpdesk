{
  "version": 3,
  "sources": ["../../../../../node_modules/.bun/radash@12.1.1/node_modules/radash/src/async.ts", "../../../../../node_modules/.bun/@orpc+shared@1.13.4+460773ef8ff1e07c/node_modules/@orpc/shared/dist/index.mjs"],
  "sourcesContent": ["import { fork, list, range, sort } from './array'\nimport { isArray, isPromise } from './typed'\n\n/**\n * An async reduce function. Works like the\n * built-in Array.reduce function but handles\n * an async reducer function\n */\nexport const reduce = async <T, K>(\n  array: readonly T[],\n  asyncReducer: (acc: K, item: T, index: number) => Promise<K>,\n  initValue?: K\n): Promise<K> => {\n  const initProvided = initValue !== undefined\n  if (!initProvided && array?.length < 1) {\n    throw new Error('Cannot reduce empty array with no init value')\n  }\n  const iter = initProvided ? array : array.slice(1)\n  let value: any = initProvided ? initValue : array[0]\n  for (const [i, item] of iter.entries()) {\n    value = await asyncReducer(value, item, i)\n  }\n  return value\n}\n\n/**\n * An async map function. Works like the\n * built-in Array.map function but handles\n * an async mapper function\n */\nexport const map = async <T, K>(\n  array: readonly T[],\n  asyncMapFunc: (item: T, index: number) => Promise<K>\n): Promise<K[]> => {\n  if (!array) return []\n  let result = []\n  let index = 0\n  for (const value of array) {\n    const newValue = await asyncMapFunc(value, index++)\n    result.push(newValue)\n  }\n  return result\n}\n\n/**\n * Useful when for script like things where cleanup\n * should be done on fail or sucess no matter.\n *\n * You can call defer many times to register many\n * defered functions that will all be called when\n * the function exits in any state.\n */\nexport const defer = async <TResponse>(\n  func: (\n    register: (\n      fn: (error?: any) => any,\n      options?: { rethrow?: boolean }\n    ) => void\n  ) => Promise<TResponse>\n): Promise<TResponse> => {\n  const callbacks: {\n    fn: (error?: any) => any\n    rethrow: boolean\n  }[] = []\n  const register = (\n    fn: (error?: any) => any,\n    options?: { rethrow?: boolean }\n  ) =>\n    callbacks.push({\n      fn,\n      rethrow: options?.rethrow ?? false\n    })\n  const [err, response] = await tryit(func)(register)\n  for (const { fn, rethrow } of callbacks) {\n    const [rethrown] = await tryit(fn)(err)\n    if (rethrown && rethrow) throw rethrown\n  }\n  if (err) throw err\n  return response\n}\n\ntype WorkItemResult<K> = {\n  index: number\n  result: K\n  error: any\n}\n\n/**\n * Support for the built-in AggregateError\n * is still new. Node < 15 doesn't have it\n * so patching here.\n * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/AggregateError#browser_compatibility\n */\nexport class AggregateError extends Error {\n  errors: Error[]\n  constructor(errors: Error[] = []) {\n    super()\n    const name = errors.find(e => e.name)?.name ?? ''\n    this.name = `AggregateError(${name}...)`\n    this.message = `AggregateError with ${errors.length} errors`\n    this.stack = errors.find(e => e.stack)?.stack ?? this.stack\n    this.errors = errors\n  }\n}\n\n/**\n * Executes many async functions in parallel. Returns the\n * results from all functions as an array. After all functions\n * have resolved, if any errors were thrown, they are rethrown\n * in an instance of AggregateError\n */\nexport const parallel = async <T, K>(\n  limit: number,\n  array: readonly T[],\n  func: (item: T) => Promise<K>\n): Promise<K[]> => {\n  const work = array.map((item, index) => ({\n    index,\n    item\n  }))\n  // Process array items\n  const processor = async (res: (value: WorkItemResult<K>[]) => void) => {\n    const results: WorkItemResult<K>[] = []\n    while (true) {\n      const next = work.pop()\n      if (!next) return res(results)\n      const [error, result] = await tryit(func)(next.item)\n      results.push({\n        error,\n        result: result as K,\n        index: next.index\n      })\n    }\n  }\n  // Create queues\n  const queues = list(1, limit).map(() => new Promise(processor))\n  // Wait for all queues to complete\n  const itemResults = (await Promise.all(queues)) as WorkItemResult<K>[][]\n  const [errors, results] = fork(\n    sort(itemResults.flat(), r => r.index),\n    x => !!x.error\n  )\n  if (errors.length > 0) {\n    throw new AggregateError(errors.map(error => error.error))\n  }\n  return results.map(r => r.result)\n}\n\ntype PromiseValues<T extends Promise<any>[]> = {\n  [K in keyof T]: T[K] extends Promise<infer U> ? U : never\n}\n\n/**\n * Functionally similar to Promise.all or Promise.allSettled. If any\n * errors are thrown, all errors are gathered and thrown in an\n * AggregateError.\n *\n * @example\n * const [user] = await all([\n *   api.users.create(...),\n *   s3.buckets.create(...),\n *   slack.customerSuccessChannel.sendMessage(...)\n * ])\n */\nexport async function all<T extends [Promise<any>, ...Promise<any>[]]>(\n  promises: T\n): Promise<PromiseValues<T>>\nexport async function all<T extends Promise<any>[]>(\n  promises: T\n): Promise<PromiseValues<T>>\n/**\n * Functionally similar to Promise.all or Promise.allSettled. If any\n * errors are thrown, all errors are gathered and thrown in an\n * AggregateError.\n *\n * @example\n * const { user } = await all({\n *   user: api.users.create(...),\n *   bucket: s3.buckets.create(...),\n *   message: slack.customerSuccessChannel.sendMessage(...)\n * })\n */\nexport async function all<T extends Record<string, Promise<any>>>(\n  promises: T\n): Promise<{ [K in keyof T]: Awaited<T[K]> }>\nexport async function all<\n  T extends Record<string, Promise<any>> | Promise<any>[]\n>(promises: T) {\n  const entries = isArray(promises)\n    ? promises.map(p => [null, p] as [null, Promise<any>])\n    : Object.entries(promises)\n\n  const results = await Promise.all(\n    entries.map(([key, value]) =>\n      value\n        .then(result => ({ result, exc: null, key }))\n        .catch(exc => ({ result: null, exc, key }))\n    )\n  )\n\n  const exceptions = results.filter(r => r.exc)\n  if (exceptions.length > 0) {\n    throw new AggregateError(exceptions.map(e => e.exc))\n  }\n\n  if (isArray(promises)) {\n    return results.map(r => r.result) as T extends Promise<any>[]\n      ? PromiseValues<T>\n      : unknown\n  }\n\n  return results.reduce(\n    (acc, item) => ({\n      ...acc,\n      [item.key!]: item.result\n    }),\n    {} as { [K in keyof T]: Awaited<T[K]> }\n  )\n}\n\n/**\n * Retries the given function the specified number\n * of times.\n */\nexport const retry = async <TResponse>(\n  options: {\n    times?: number\n    delay?: number | null\n    backoff?: (count: number) => number\n  },\n  func: (exit: (err: any) => void) => Promise<TResponse>\n): Promise<TResponse> => {\n  const times = options?.times ?? 3\n  const delay = options?.delay\n  const backoff = options?.backoff ?? null\n  for (const i of range(1, times)) {\n    const [err, result] = (await tryit(func)((err: any) => {\n      throw { _exited: err }\n    })) as [any, TResponse]\n    if (!err) return result\n    if (err._exited) throw err._exited\n    if (i === times) throw err\n    if (delay) await sleep(delay)\n    if (backoff) await sleep(backoff(i))\n  }\n  // Logically, we should never reach this\n  // code path. It makes the function meet\n  // strict mode requirements.\n  /* istanbul ignore next */\n  return undefined as unknown as TResponse\n}\n\n/**\n * Async wait\n */\nexport const sleep = (milliseconds: number) => {\n  return new Promise(res => setTimeout(res, milliseconds))\n}\n\n/**\n * A helper to try an async function without forking\n * the control flow. Returns an error first callback _like_\n * array response as [Error, result]\n */\nexport const tryit = <Args extends any[], Return>(\n  func: (...args: Args) => Return\n) => {\n  return (\n    ...args: Args\n  ): Return extends Promise<any>\n    ? Promise<[Error, undefined] | [undefined, Awaited<Return>]>\n    : [Error, undefined] | [undefined, Return] => {\n    try {\n      const result = func(...args)\n      if (isPromise(result)) {\n        return result\n          .then(value => [undefined, value])\n          .catch(err => [err, undefined]) as Return extends Promise<any>\n          ? Promise<[Error, undefined] | [undefined, Awaited<Return>]>\n          : [Error, undefined] | [undefined, Return]\n      }\n      return [undefined, result] as Return extends Promise<any>\n        ? Promise<[Error, undefined] | [undefined, Awaited<Return>]>\n        : [Error, undefined] | [undefined, Return]\n    } catch (err) {\n      return [err as any, undefined] as Return extends Promise<any>\n        ? Promise<[Error, undefined] | [undefined, Awaited<Return>]>\n        : [Error, undefined] | [undefined, Return]\n    }\n  }\n}\n\n/**\n * A helper to try an async function that returns undefined\n * if it fails.\n *\n * e.g. const result = await guard(fetchUsers)() ?? [];\n */\nexport const guard = <TFunction extends () => any>(\n  func: TFunction,\n  shouldGuard?: (err: any) => boolean\n): ReturnType<TFunction> extends Promise<any>\n  ? Promise<Awaited<ReturnType<TFunction>> | undefined>\n  : ReturnType<TFunction> | undefined => {\n  const _guard = (err: any) => {\n    if (shouldGuard && !shouldGuard(err)) throw err\n    return undefined as any\n  }\n  const isPromise = (result: any): result is Promise<any> =>\n    result instanceof Promise\n  try {\n    const result = func()\n    return isPromise(result) ? result.catch(_guard) : result\n  } catch (err) {\n    return _guard(err)\n  }\n}\n", "export { group, guard, mapEntries, mapValues, omit, retry, sleep } from 'radash';\n\nfunction resolveMaybeOptionalOptions(rest) {\n  return rest[0] ?? {};\n}\n\nfunction toArray(value) {\n  return Array.isArray(value) ? value : value === void 0 || value === null ? [] : [value];\n}\nfunction splitInHalf(arr) {\n  const half = Math.ceil(arr.length / 2);\n  return [arr.slice(0, half), arr.slice(half)];\n}\n\nfunction readAsBuffer(source) {\n  if (typeof source.bytes === \"function\") {\n    return source.bytes();\n  }\n  return source.arrayBuffer();\n}\n\nconst ORPC_NAME = \"orpc\";\nconst ORPC_SHARED_PACKAGE_NAME = \"@orpc/shared\";\nconst ORPC_SHARED_PACKAGE_VERSION = \"1.13.4\";\n\nclass AbortError extends Error {\n  constructor(...rest) {\n    super(...rest);\n    this.name = \"AbortError\";\n  }\n}\n\nfunction once(fn) {\n  let cached;\n  return () => {\n    if (cached) {\n      return cached.result;\n    }\n    const result = fn();\n    cached = { result };\n    return result;\n  };\n}\nfunction sequential(fn) {\n  let lastOperationPromise = Promise.resolve();\n  return (...args) => {\n    return lastOperationPromise = lastOperationPromise.catch(() => {\n    }).then(() => {\n      return fn(...args);\n    });\n  };\n}\nfunction defer(callback) {\n  if (typeof setTimeout === \"function\") {\n    setTimeout(callback, 0);\n  } else {\n    Promise.resolve().then(() => Promise.resolve().then(() => Promise.resolve().then(callback)));\n  }\n}\n\nconst SPAN_ERROR_STATUS = 2;\nconst GLOBAL_OTEL_CONFIG_KEY = `__${ORPC_SHARED_PACKAGE_NAME}@${ORPC_SHARED_PACKAGE_VERSION}/otel/config__`;\nfunction setGlobalOtelConfig(config) {\n  globalThis[GLOBAL_OTEL_CONFIG_KEY] = config;\n}\nfunction getGlobalOtelConfig() {\n  return globalThis[GLOBAL_OTEL_CONFIG_KEY];\n}\nfunction startSpan(name, options = {}, context) {\n  const tracer = getGlobalOtelConfig()?.tracer;\n  return tracer?.startSpan(name, options, context);\n}\nfunction setSpanError(span, error, options = {}) {\n  if (!span) {\n    return;\n  }\n  const exception = toOtelException(error);\n  span.recordException(exception);\n  if (!options.signal?.aborted || options.signal.reason !== error) {\n    span.setStatus({\n      code: SPAN_ERROR_STATUS,\n      message: exception.message\n    });\n  }\n}\nfunction setSpanAttribute(span, key, value) {\n  if (!span || value === void 0) {\n    return;\n  }\n  span.setAttribute(key, value);\n}\nfunction toOtelException(error) {\n  if (error instanceof Error) {\n    const exception = {\n      message: error.message,\n      name: error.name,\n      stack: error.stack\n    };\n    if (\"code\" in error && (typeof error.code === \"string\" || typeof error.code === \"number\")) {\n      exception.code = error.code;\n    }\n    return exception;\n  }\n  return { message: String(error) };\n}\nfunction toSpanAttributeValue(data) {\n  if (data === void 0) {\n    return \"undefined\";\n  }\n  try {\n    return JSON.stringify(data, (_, value) => {\n      if (typeof value === \"bigint\") {\n        return value.toString();\n      }\n      if (value instanceof Map || value instanceof Set) {\n        return Array.from(value);\n      }\n      return value;\n    });\n  } catch {\n    return String(data);\n  }\n}\nasync function runWithSpan({ name, context, ...options }, fn) {\n  const tracer = getGlobalOtelConfig()?.tracer;\n  if (!tracer) {\n    return fn();\n  }\n  const callback = async (span) => {\n    try {\n      return await fn(span);\n    } catch (e) {\n      setSpanError(span, e, options);\n      throw e;\n    } finally {\n      span.end();\n    }\n  };\n  if (context) {\n    return tracer.startActiveSpan(name, options, context, callback);\n  } else {\n    return tracer.startActiveSpan(name, options, callback);\n  }\n}\nasync function runInSpanContext(span, fn) {\n  const otelConfig = getGlobalOtelConfig();\n  if (!span || !otelConfig) {\n    return fn();\n  }\n  const ctx = otelConfig.trace.setSpan(otelConfig.context.active(), span);\n  return otelConfig.context.with(ctx, fn);\n}\n\nclass AsyncIdQueue {\n  openIds = /* @__PURE__ */ new Set();\n  queues = /* @__PURE__ */ new Map();\n  waiters = /* @__PURE__ */ new Map();\n  get length() {\n    return this.openIds.size;\n  }\n  get waiterIds() {\n    return Array.from(this.waiters.keys());\n  }\n  hasBufferedItems(id) {\n    return Boolean(this.queues.get(id)?.length);\n  }\n  open(id) {\n    this.openIds.add(id);\n  }\n  isOpen(id) {\n    return this.openIds.has(id);\n  }\n  push(id, item) {\n    this.assertOpen(id);\n    const pending = this.waiters.get(id);\n    if (pending?.length) {\n      pending.shift()[0](item);\n      if (pending.length === 0) {\n        this.waiters.delete(id);\n      }\n    } else {\n      const items = this.queues.get(id);\n      if (items) {\n        items.push(item);\n      } else {\n        this.queues.set(id, [item]);\n      }\n    }\n  }\n  async pull(id) {\n    this.assertOpen(id);\n    const items = this.queues.get(id);\n    if (items?.length) {\n      const item = items.shift();\n      if (items.length === 0) {\n        this.queues.delete(id);\n      }\n      return item;\n    }\n    return new Promise((resolve, reject) => {\n      const waitingPulls = this.waiters.get(id);\n      const pending = [resolve, reject];\n      if (waitingPulls) {\n        waitingPulls.push(pending);\n      } else {\n        this.waiters.set(id, [pending]);\n      }\n    });\n  }\n  close({ id, reason } = {}) {\n    if (id === void 0) {\n      this.waiters.forEach((pendingPulls, id2) => {\n        const error2 = reason ?? new AbortError(`[AsyncIdQueue] Queue[${id2}] was closed or aborted while waiting for pulling.`);\n        pendingPulls.forEach(([, reject]) => reject(error2));\n      });\n      this.waiters.clear();\n      this.openIds.clear();\n      this.queues.clear();\n      return;\n    }\n    const error = reason ?? new AbortError(`[AsyncIdQueue] Queue[${id}] was closed or aborted while waiting for pulling.`);\n    this.waiters.get(id)?.forEach(([, reject]) => reject(error));\n    this.waiters.delete(id);\n    this.openIds.delete(id);\n    this.queues.delete(id);\n  }\n  assertOpen(id) {\n    if (!this.isOpen(id)) {\n      throw new Error(`[AsyncIdQueue] Cannot access queue[${id}] because it is not open or aborted.`);\n    }\n  }\n}\n\nfunction isAsyncIteratorObject(maybe) {\n  if (!maybe || typeof maybe !== \"object\") {\n    return false;\n  }\n  return \"next\" in maybe && typeof maybe.next === \"function\" && Symbol.asyncIterator in maybe && typeof maybe[Symbol.asyncIterator] === \"function\";\n}\nconst fallbackAsyncDisposeSymbol = Symbol.for(\"asyncDispose\");\nconst asyncDisposeSymbol = Symbol.asyncDispose ?? fallbackAsyncDisposeSymbol;\nclass AsyncIteratorClass {\n  #isDone = false;\n  #isExecuteComplete = false;\n  #cleanup;\n  #next;\n  constructor(next, cleanup) {\n    this.#cleanup = cleanup;\n    this.#next = sequential(async () => {\n      if (this.#isDone) {\n        return { done: true, value: void 0 };\n      }\n      try {\n        const result = await next();\n        if (result.done) {\n          this.#isDone = true;\n        }\n        return result;\n      } catch (err) {\n        this.#isDone = true;\n        throw err;\n      } finally {\n        if (this.#isDone && !this.#isExecuteComplete) {\n          this.#isExecuteComplete = true;\n          await this.#cleanup(\"next\");\n        }\n      }\n    });\n  }\n  next() {\n    return this.#next();\n  }\n  async return(value) {\n    this.#isDone = true;\n    if (!this.#isExecuteComplete) {\n      this.#isExecuteComplete = true;\n      await this.#cleanup(\"return\");\n    }\n    return { done: true, value };\n  }\n  async throw(err) {\n    this.#isDone = true;\n    if (!this.#isExecuteComplete) {\n      this.#isExecuteComplete = true;\n      await this.#cleanup(\"throw\");\n    }\n    throw err;\n  }\n  /**\n   * asyncDispose symbol only available in esnext, we should fallback to Symbol.for('asyncDispose')\n   */\n  async [asyncDisposeSymbol]() {\n    this.#isDone = true;\n    if (!this.#isExecuteComplete) {\n      this.#isExecuteComplete = true;\n      await this.#cleanup(\"dispose\");\n    }\n  }\n  [Symbol.asyncIterator]() {\n    return this;\n  }\n}\nfunction replicateAsyncIterator(source, count) {\n  const queue = new AsyncIdQueue();\n  const ids = Array.from({ length: count }, (_, i) => i.toString());\n  let isSourceFinished = false;\n  const start = once(async () => {\n    try {\n      while (true) {\n        const item = await source.next();\n        ids.forEach((id) => {\n          if (queue.isOpen(id)) {\n            queue.push(id, { next: item });\n          }\n        });\n        if (item.done) {\n          break;\n        }\n      }\n    } catch (error) {\n      ids.forEach((id) => {\n        if (queue.isOpen(id)) {\n          queue.push(id, { error });\n        }\n      });\n    } finally {\n      isSourceFinished = true;\n    }\n  });\n  const replicated = ids.map((id) => {\n    queue.open(id);\n    return new AsyncIteratorClass(\n      async () => {\n        start();\n        const item = await queue.pull(id);\n        if (item.next) {\n          return item.next;\n        }\n        throw item.error;\n      },\n      async (reason) => {\n        queue.close({ id });\n        if (reason !== \"next\" && !queue.length && !isSourceFinished) {\n          isSourceFinished = true;\n          await source?.return?.();\n        }\n      }\n    );\n  });\n  return replicated;\n}\nfunction asyncIteratorWithSpan({ name, ...options }, iterator) {\n  let span;\n  return new AsyncIteratorClass(\n    async () => {\n      span ??= startSpan(name);\n      try {\n        const result = await runInSpanContext(span, () => iterator.next());\n        span?.addEvent(result.done ? \"completed\" : \"yielded\");\n        return result;\n      } catch (err) {\n        setSpanError(span, err, options);\n        throw err;\n      }\n    },\n    async (reason) => {\n      try {\n        if (reason !== \"next\") {\n          await runInSpanContext(span, () => iterator.return?.());\n        }\n      } catch (err) {\n        setSpanError(span, err, options);\n        throw err;\n      } finally {\n        span?.end();\n      }\n    }\n  );\n}\n\nclass EventPublisher {\n  #listenersMap = /* @__PURE__ */ new Map();\n  #maxBufferedEvents;\n  constructor(options = {}) {\n    this.#maxBufferedEvents = options.maxBufferedEvents ?? 100;\n  }\n  get size() {\n    return this.#listenersMap.size;\n  }\n  /**\n   * Emits an event and delivers the payload to all subscribed listeners.\n   */\n  publish(event, payload) {\n    const listeners = this.#listenersMap.get(event);\n    if (!listeners) {\n      return;\n    }\n    for (const listener of listeners) {\n      listener(payload);\n    }\n  }\n  subscribe(event, listenerOrOptions) {\n    if (typeof listenerOrOptions === \"function\") {\n      let listeners = this.#listenersMap.get(event);\n      if (!listeners) {\n        this.#listenersMap.set(event, listeners = []);\n      }\n      listeners.push(listenerOrOptions);\n      return once(() => {\n        listeners.splice(listeners.indexOf(listenerOrOptions), 1);\n        if (listeners.length === 0) {\n          this.#listenersMap.delete(event);\n        }\n      });\n    }\n    const signal = listenerOrOptions?.signal;\n    const maxBufferedEvents = listenerOrOptions?.maxBufferedEvents ?? this.#maxBufferedEvents;\n    signal?.throwIfAborted();\n    const bufferedEvents = [];\n    const pullResolvers = [];\n    const unsubscribe = this.subscribe(event, (payload) => {\n      const resolver = pullResolvers.shift();\n      if (resolver) {\n        resolver[0]({ done: false, value: payload });\n      } else {\n        bufferedEvents.push(payload);\n        if (bufferedEvents.length > maxBufferedEvents) {\n          bufferedEvents.shift();\n        }\n      }\n    });\n    const abortListener = (event2) => {\n      unsubscribe();\n      pullResolvers.forEach((resolver) => resolver[1](event2.target.reason));\n      pullResolvers.length = 0;\n      bufferedEvents.length = 0;\n    };\n    signal?.addEventListener(\"abort\", abortListener, { once: true });\n    return new AsyncIteratorClass(async () => {\n      if (signal?.aborted) {\n        throw signal.reason;\n      }\n      if (bufferedEvents.length > 0) {\n        return { done: false, value: bufferedEvents.shift() };\n      }\n      return new Promise((resolve, reject) => {\n        pullResolvers.push([resolve, reject]);\n      });\n    }, async () => {\n      unsubscribe();\n      signal?.removeEventListener(\"abort\", abortListener);\n      pullResolvers.forEach((resolver) => resolver[0]({ done: true, value: void 0 }));\n      pullResolvers.length = 0;\n      bufferedEvents.length = 0;\n    });\n  }\n}\n\nclass SequentialIdGenerator {\n  index = BigInt(1);\n  generate() {\n    const id = this.index.toString(36);\n    this.index++;\n    return id;\n  }\n}\nfunction compareSequentialIds(a, b) {\n  if (a.length !== b.length) {\n    return a.length - b.length;\n  }\n  return a < b ? -1 : a > b ? 1 : 0;\n}\n\nfunction onStart(callback) {\n  return async (options, ...rest) => {\n    await callback(options, ...rest);\n    return await options.next();\n  };\n}\nfunction onSuccess(callback) {\n  return async (options, ...rest) => {\n    const result = await options.next();\n    await callback(result, options, ...rest);\n    return result;\n  };\n}\nfunction onError(callback) {\n  return async (options, ...rest) => {\n    try {\n      return await options.next();\n    } catch (error) {\n      await callback(error, options, ...rest);\n      throw error;\n    }\n  };\n}\nfunction onFinish(callback) {\n  let state;\n  return async (options, ...rest) => {\n    try {\n      const result = await options.next();\n      state = [null, result, true];\n      return result;\n    } catch (error) {\n      state = [error, void 0, false];\n      throw error;\n    } finally {\n      await callback(state, options, ...rest);\n    }\n  };\n}\nfunction intercept(interceptors, options, main) {\n  const next = (options2, index) => {\n    const interceptor = interceptors[index];\n    if (!interceptor) {\n      return main(options2);\n    }\n    return interceptor({\n      ...options2,\n      next: (newOptions = options2) => next(newOptions, index + 1)\n    });\n  };\n  return next(options, 0);\n}\n\nfunction parseEmptyableJSON(text) {\n  if (!text) {\n    return void 0;\n  }\n  return JSON.parse(text);\n}\nfunction stringifyJSON(value) {\n  return JSON.stringify(value);\n}\n\nfunction findDeepMatches(check, payload, segments = [], maps = [], values = []) {\n  if (check(payload)) {\n    maps.push(segments);\n    values.push(payload);\n  } else if (Array.isArray(payload)) {\n    payload.forEach((v, i) => {\n      findDeepMatches(check, v, [...segments, i], maps, values);\n    });\n  } else if (isObject(payload)) {\n    for (const key in payload) {\n      findDeepMatches(check, payload[key], [...segments, key], maps, values);\n    }\n  }\n  return { maps, values };\n}\nfunction getConstructor(value) {\n  if (!isTypescriptObject(value)) {\n    return null;\n  }\n  return Object.getPrototypeOf(value)?.constructor;\n}\nfunction isObject(value) {\n  if (!value || typeof value !== \"object\") {\n    return false;\n  }\n  const proto = Object.getPrototypeOf(value);\n  return proto === Object.prototype || !proto || !proto.constructor;\n}\nfunction isTypescriptObject(value) {\n  return !!value && (typeof value === \"object\" || typeof value === \"function\");\n}\nfunction clone(value) {\n  if (Array.isArray(value)) {\n    return value.map(clone);\n  }\n  if (isObject(value)) {\n    const result = {};\n    for (const key in value) {\n      result[key] = clone(value[key]);\n    }\n    for (const sym of Object.getOwnPropertySymbols(value)) {\n      result[sym] = clone(value[sym]);\n    }\n    return result;\n  }\n  return value;\n}\nfunction get(object, path) {\n  let current = object;\n  for (const key of path) {\n    if (!isTypescriptObject(current)) {\n      return void 0;\n    }\n    current = current[key];\n  }\n  return current;\n}\nfunction isPropertyKey(value) {\n  const type = typeof value;\n  return type === \"string\" || type === \"number\" || type === \"symbol\";\n}\nconst NullProtoObj = /* @__PURE__ */ (() => {\n  const e = function() {\n  };\n  e.prototype = /* @__PURE__ */ Object.create(null);\n  Object.freeze(e.prototype);\n  return e;\n})();\n\nfunction value(value2, ...args) {\n  if (typeof value2 === \"function\") {\n    return value2(...args);\n  }\n  return value2;\n}\nfunction fallback(value2, fallback2) {\n  return value2 === void 0 ? fallback2 : value2;\n}\n\nfunction preventNativeAwait(target) {\n  return new Proxy(target, {\n    get(target2, prop, receiver) {\n      const value2 = Reflect.get(target2, prop, receiver);\n      if (prop !== \"then\" || typeof value2 !== \"function\") {\n        return value2;\n      }\n      return new Proxy(value2, {\n        apply(targetFn, thisArg, args) {\n          if (args.length !== 2 || args.some((arg) => !isNativeFunction(arg))) {\n            return Reflect.apply(targetFn, thisArg, args);\n          }\n          let shouldOmit = true;\n          args[0].call(thisArg, preventNativeAwait(new Proxy(target2, {\n            get: (target3, prop2, receiver2) => {\n              if (shouldOmit && prop2 === \"then\") {\n                shouldOmit = false;\n                return void 0;\n              }\n              return Reflect.get(target3, prop2, receiver2);\n            }\n          })));\n        }\n      });\n    }\n  });\n}\nconst NATIVE_FUNCTION_REGEX = /^\\s*function\\s*\\(\\)\\s*\\{\\s*\\[native code\\]\\s*\\}\\s*$/;\nfunction isNativeFunction(fn) {\n  return typeof fn === \"function\" && NATIVE_FUNCTION_REGEX.test(fn.toString());\n}\nfunction overlayProxy(target, partial) {\n  const proxy = new Proxy(typeof target === \"function\" ? partial : target, {\n    get(_, prop) {\n      const targetValue = prop in partial ? partial : value(target);\n      const v = Reflect.get(targetValue, prop);\n      return typeof v === \"function\" ? v.bind(targetValue) : v;\n    },\n    has(_, prop) {\n      return Reflect.has(partial, prop) || Reflect.has(value(target), prop);\n    }\n  });\n  return proxy;\n}\n\nfunction streamToAsyncIteratorClass(stream) {\n  const reader = stream.getReader();\n  return new AsyncIteratorClass(\n    async () => {\n      return reader.read();\n    },\n    async () => {\n      await reader.cancel();\n    }\n  );\n}\nfunction asyncIteratorToStream(iterator) {\n  return new ReadableStream({\n    async pull(controller) {\n      const { done, value } = await iterator.next();\n      if (done) {\n        controller.close();\n      } else {\n        controller.enqueue(value);\n      }\n    },\n    async cancel() {\n      await iterator.return?.();\n    }\n  });\n}\nfunction asyncIteratorToUnproxiedDataStream(iterator) {\n  return new ReadableStream({\n    async pull(controller) {\n      const { done, value } = await iterator.next();\n      if (done) {\n        controller.close();\n      } else {\n        const unproxied = isObject(value) ? { ...value } : Array.isArray(value) ? value.map((i) => i) : value;\n        controller.enqueue(unproxied);\n      }\n    },\n    async cancel() {\n      await iterator.return?.();\n    }\n  });\n}\n\nfunction tryDecodeURIComponent(value) {\n  try {\n    return decodeURIComponent(value);\n  } catch {\n    return value;\n  }\n}\n\nexport { AbortError, AsyncIdQueue, AsyncIteratorClass, EventPublisher, NullProtoObj, ORPC_NAME, ORPC_SHARED_PACKAGE_NAME, ORPC_SHARED_PACKAGE_VERSION, SequentialIdGenerator, asyncIteratorToStream, asyncIteratorToUnproxiedDataStream, asyncIteratorWithSpan, clone, compareSequentialIds, defer, fallback, findDeepMatches, get, getConstructor, getGlobalOtelConfig, intercept, isAsyncIteratorObject, isObject, isPropertyKey, isTypescriptObject, onError, onFinish, onStart, onSuccess, once, overlayProxy, parseEmptyableJSON, preventNativeAwait, readAsBuffer, replicateAsyncIterator, resolveMaybeOptionalOptions, runInSpanContext, runWithSpan, sequential, setGlobalOtelConfig, setSpanAttribute, setSpanError, splitInHalf, startSpan, streamToAsyncIteratorClass, stringifyJSON, toArray, toOtelException, toSpanAttributeValue, tryDecodeURIComponent, value };\n"],
  "mappings": "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",
  "names": ["isPromise", "value", "value", "value", "isObject", "clone", "get", "partial", "value", "isObject"]
}
