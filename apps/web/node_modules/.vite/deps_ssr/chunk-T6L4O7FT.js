import {
  isDefinedError
} from "./chunk-4MT5BNIL.js";
import {
  isTypescriptObject,
  preventNativeAwait
} from "./chunk-FX53GUXJ.js";

// ../../node_modules/.bun/@orpc+client@1.13.4+460773ef8ff1e07c/node_modules/@orpc/client/dist/index.mjs
async function safe(promise) {
  try {
    const output = await promise;
    return Object.assign(
      [null, output, false, true],
      { error: null, data: output, isDefined: false, isSuccess: true }
    );
  } catch (e) {
    const error = e;
    if (isDefinedError(error)) {
      return Object.assign(
        [error, void 0, true, false],
        { error, data: void 0, isDefined: true, isSuccess: false }
      );
    }
    return Object.assign(
      [error, void 0, false, false],
      { error, data: void 0, isDefined: false, isSuccess: false }
    );
  }
}
function resolveFriendlyClientOptions(options) {
  return {
    ...options,
    context: options.context ?? {}
    // Context only optional if all fields are optional
  };
}
function consumeEventIterator(iterator, options) {
  void (async () => {
    let onFinishState;
    try {
      const resolvedIterator = await iterator;
      while (true) {
        const { done, value } = await resolvedIterator.next();
        if (done) {
          const realValue = value;
          onFinishState = [null, realValue, true];
          options.onSuccess?.(realValue);
          break;
        }
        options.onEvent(value);
      }
    } catch (error) {
      onFinishState = [error, void 0, false];
      if (!options.onError && !options.onFinish) {
        throw error;
      }
      options.onError?.(error);
    } finally {
      options.onFinish?.(onFinishState);
    }
  })();
  return async () => {
    await (await iterator)?.return?.();
  };
}
function createORPCClient(link, options = {}) {
  const path = options.path ?? [];
  const procedureClient = async (...[input, options2 = {}]) => {
    return await link.call(path, input, resolveFriendlyClientOptions(options2));
  };
  const recursive = new Proxy(procedureClient, {
    get(target, key) {
      if (typeof key !== "string") {
        return Reflect.get(target, key);
      }
      return createORPCClient(link, {
        ...options,
        path: [...path, key]
      });
    }
  });
  return preventNativeAwait(recursive);
}
function createSafeClient(client) {
  const proxy = new Proxy((...args) => safe(client(...args)), {
    get(_, prop, receiver) {
      const value = Reflect.get(client, prop, receiver);
      if (typeof prop !== "string") {
        return value;
      }
      if (!isTypescriptObject(value)) {
        return value;
      }
      return createSafeClient(value);
    }
  });
  return proxy;
}
var DynamicLink = class {
  constructor(linkResolver) {
    this.linkResolver = linkResolver;
  }
  async call(path, input, options) {
    const resolvedLink = await this.linkResolver(options, path, input);
    const output = await resolvedLink.call(path, input, options);
    return output;
  }
};

export {
  safe,
  resolveFriendlyClientOptions,
  consumeEventIterator,
  createORPCClient,
  createSafeClient,
  DynamicLink
};
//# sourceMappingURL=chunk-T6L4O7FT.js.map
