{
  "version": 3,
  "sources": ["../../../../../node_modules/.bun/better-auth@1.4.14+cf5dc576ad9023b2/node_modules/better-auth/src/plugins/additional-fields/client.ts", "../../../../../node_modules/.bun/better-auth@1.4.14+cf5dc576ad9023b2/node_modules/better-auth/src/plugins/admin/client.ts", "../../../../../node_modules/.bun/better-auth@1.4.14+cf5dc576ad9023b2/node_modules/better-auth/src/plugins/anonymous/client.ts", "../../../../../node_modules/.bun/better-auth@1.4.14+cf5dc576ad9023b2/node_modules/better-auth/src/plugins/api-key/client.ts", "../../../../../node_modules/.bun/better-auth@1.4.14+cf5dc576ad9023b2/node_modules/better-auth/src/client/plugins/infer-plugin.ts", "../../../../../node_modules/.bun/better-auth@1.4.14+cf5dc576ad9023b2/node_modules/better-auth/src/plugins/custom-session/client.ts", "../../../../../node_modules/.bun/better-auth@1.4.14+cf5dc576ad9023b2/node_modules/better-auth/src/plugins/device-authorization/client.ts", "../../../../../node_modules/.bun/better-auth@1.4.14+cf5dc576ad9023b2/node_modules/better-auth/src/plugins/email-otp/client.ts", "../../../../../node_modules/.bun/better-auth@1.4.14+cf5dc576ad9023b2/node_modules/better-auth/src/plugins/generic-oauth/client.ts", "../../../../../node_modules/.bun/better-auth@1.4.14+cf5dc576ad9023b2/node_modules/better-auth/src/plugins/jwt/client.ts", "../../../../../node_modules/.bun/better-auth@1.4.14+cf5dc576ad9023b2/node_modules/better-auth/src/plugins/last-login-method/client.ts", "../../../../../node_modules/.bun/better-auth@1.4.14+cf5dc576ad9023b2/node_modules/better-auth/src/plugins/magic-link/client.ts", "../../../../../node_modules/.bun/better-auth@1.4.14+cf5dc576ad9023b2/node_modules/better-auth/src/plugins/multi-session/client.ts", "../../../../../node_modules/.bun/better-auth@1.4.14+cf5dc576ad9023b2/node_modules/better-auth/src/plugins/oidc-provider/client.ts", "../../../../../node_modules/.bun/better-auth@1.4.14+cf5dc576ad9023b2/node_modules/better-auth/src/plugins/one-tap/client.ts", "../../../../../node_modules/.bun/better-auth@1.4.14+cf5dc576ad9023b2/node_modules/better-auth/src/plugins/one-time-token/client.ts", "../../../../../node_modules/.bun/better-auth@1.4.14+cf5dc576ad9023b2/node_modules/better-auth/src/plugins/organization/client.ts", "../../../../../node_modules/.bun/better-auth@1.4.14+cf5dc576ad9023b2/node_modules/better-auth/src/plugins/phone-number/client.ts", "../../../../../node_modules/.bun/better-auth@1.4.14+cf5dc576ad9023b2/node_modules/better-auth/src/plugins/siwe/client.ts", "../../../../../node_modules/.bun/better-auth@1.4.14+cf5dc576ad9023b2/node_modules/better-auth/src/plugins/username/client.ts"],
  "sourcesContent": ["import type {\n\tBetterAuthClientPlugin,\n\tBetterAuthOptions,\n\tBetterAuthPlugin,\n} from \"@better-auth/core\";\nimport type { DBFieldAttribute } from \"@better-auth/core/db\";\n\nexport const inferAdditionalFields = <\n\tT,\n\tS extends {\n\t\tuser?:\n\t\t\t| {\n\t\t\t\t\t[key: string]: DBFieldAttribute;\n\t\t\t  }\n\t\t\t| undefined;\n\t\tsession?:\n\t\t\t| {\n\t\t\t\t\t[key: string]: DBFieldAttribute;\n\t\t\t  }\n\t\t\t| undefined;\n\t} = {},\n>(\n\tschema?: S | undefined,\n) => {\n\ttype Opts = T extends BetterAuthOptions\n\t\t? T\n\t\t: T extends {\n\t\t\t\t\toptions: BetterAuthOptions;\n\t\t\t\t}\n\t\t\t? T[\"options\"]\n\t\t\t: never;\n\n\ttype Plugin = Opts extends never\n\t\t? S extends {\n\t\t\t\tuser?:\n\t\t\t\t\t| {\n\t\t\t\t\t\t\t[key: string]: DBFieldAttribute;\n\t\t\t\t\t  }\n\t\t\t\t\t| undefined;\n\t\t\t\tsession?:\n\t\t\t\t\t| {\n\t\t\t\t\t\t\t[key: string]: DBFieldAttribute;\n\t\t\t\t\t  }\n\t\t\t\t\t| undefined;\n\t\t\t}\n\t\t\t? {\n\t\t\t\t\tid: \"additional-fields-client\";\n\t\t\t\t\tschema: {\n\t\t\t\t\t\tuser: {\n\t\t\t\t\t\t\tfields: S[\"user\"] extends object ? S[\"user\"] : {};\n\t\t\t\t\t\t};\n\t\t\t\t\t\tsession: {\n\t\t\t\t\t\t\tfields: S[\"session\"] extends object ? S[\"session\"] : {};\n\t\t\t\t\t\t};\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t: never\n\t\t: Opts extends BetterAuthOptions\n\t\t\t? {\n\t\t\t\t\tid: \"additional-fields\";\n\t\t\t\t\tschema: {\n\t\t\t\t\t\tuser: {\n\t\t\t\t\t\t\tfields: Opts[\"user\"] extends {\n\t\t\t\t\t\t\t\tadditionalFields: infer U;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t? U\n\t\t\t\t\t\t\t\t: {};\n\t\t\t\t\t\t};\n\t\t\t\t\t\tsession: {\n\t\t\t\t\t\t\tfields: Opts[\"session\"] extends {\n\t\t\t\t\t\t\t\tadditionalFields: infer U;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t? U\n\t\t\t\t\t\t\t\t: {};\n\t\t\t\t\t\t};\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t: never;\n\n\treturn {\n\t\tid: \"additional-fields-client\",\n\t\t$InferServerPlugin: {} as Plugin extends BetterAuthPlugin\n\t\t\t? Plugin\n\t\t\t: undefined,\n\t} satisfies BetterAuthClientPlugin;\n};\n", "import type { BetterAuthClientPlugin } from \"@better-auth/core\";\nimport type { AccessControl, Role } from \"../access\";\nimport type { defaultStatements } from \"./access\";\nimport { adminAc, userAc } from \"./access\";\nimport type { admin } from \"./admin\";\nimport { hasPermission } from \"./has-permission\";\n\ninterface AdminClientOptions {\n\tac?: AccessControl | undefined;\n\troles?:\n\t\t| {\n\t\t\t\t[key in string]: Role;\n\t\t  }\n\t\t| undefined;\n}\n\nexport const adminClient = <O extends AdminClientOptions>(\n\toptions?: O | undefined,\n) => {\n\ttype DefaultStatements = typeof defaultStatements;\n\ttype Statements =\n\t\tO[\"ac\"] extends AccessControl<infer S> ? S : DefaultStatements;\n\ttype PermissionType = {\n\t\t[key in keyof Statements]?: Array<\n\t\t\tStatements[key] extends readonly unknown[]\n\t\t\t\t? Statements[key][number]\n\t\t\t\t: never\n\t\t>;\n\t};\n\ttype PermissionExclusive =\n\t\t| {\n\t\t\t\t/**\n\t\t\t\t * @deprecated Use `permissions` instead\n\t\t\t\t */\n\t\t\t\tpermission: PermissionType;\n\t\t\t\tpermissions?: never | undefined;\n\t\t  }\n\t\t| {\n\t\t\t\tpermissions: PermissionType;\n\t\t\t\tpermission?: never | undefined;\n\t\t  };\n\n\tconst roles = {\n\t\tadmin: adminAc,\n\t\tuser: userAc,\n\t\t...options?.roles,\n\t};\n\n\treturn {\n\t\tid: \"admin-client\",\n\t\t$InferServerPlugin: {} as ReturnType<\n\t\t\ttypeof admin<{\n\t\t\t\tac: O[\"ac\"] extends AccessControl\n\t\t\t\t\t? O[\"ac\"]\n\t\t\t\t\t: AccessControl<DefaultStatements>;\n\t\t\t\troles: O[\"roles\"] extends Record<string, Role>\n\t\t\t\t\t? O[\"roles\"]\n\t\t\t\t\t: {\n\t\t\t\t\t\t\tadmin: Role;\n\t\t\t\t\t\t\tuser: Role;\n\t\t\t\t\t\t};\n\t\t\t}>\n\t\t>,\n\t\tgetActions: () => ({\n\t\t\tadmin: {\n\t\t\t\tcheckRolePermission: <\n\t\t\t\t\tR extends O extends { roles: any }\n\t\t\t\t\t\t? keyof O[\"roles\"]\n\t\t\t\t\t\t: \"admin\" | \"user\",\n\t\t\t\t>(\n\t\t\t\t\tdata: PermissionExclusive & {\n\t\t\t\t\t\trole: R;\n\t\t\t\t\t},\n\t\t\t\t) => {\n\t\t\t\t\tconst isAuthorized = hasPermission({\n\t\t\t\t\t\trole: data.role as string,\n\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\tac: options?.ac,\n\t\t\t\t\t\t\troles: roles,\n\t\t\t\t\t\t},\n\t\t\t\t\t\tpermissions: (data.permissions ?? data.permission) as any,\n\t\t\t\t\t});\n\t\t\t\t\treturn isAuthorized;\n\t\t\t\t},\n\t\t\t},\n\t\t}),\n\t\tpathMethods: {\n\t\t\t\"/admin/list-users\": \"GET\",\n\t\t\t\"/admin/stop-impersonating\": \"POST\",\n\t\t},\n\t} satisfies BetterAuthClientPlugin;\n};\n\nexport type * from \"./types\";\n", "import type { BetterAuthClientPlugin } from \"@better-auth/core\";\nimport type { anonymous } from \".\";\n\nexport const anonymousClient = () => {\n\treturn {\n\t\tid: \"anonymous\",\n\t\t$InferServerPlugin: {} as ReturnType<typeof anonymous>,\n\t\tpathMethods: {\n\t\t\t\"/sign-in/anonymous\": \"POST\",\n\t\t\t\"/delete-anonymous-user\": \"POST\",\n\t\t},\n\t\tatomListeners: [\n\t\t\t{\n\t\t\t\tmatcher: (path) => path === \"/sign-in/anonymous\",\n\t\t\t\tsignal: \"$sessionSignal\",\n\t\t\t},\n\t\t],\n\t} satisfies BetterAuthClientPlugin;\n};\n\nexport type * from \"./schema\";\nexport type * from \"./types\";\n", "import type { BetterAuthClientPlugin } from \"@better-auth/core\";\nimport type { apiKey } from \".\";\n\nexport const apiKeyClient = () => {\n\treturn {\n\t\tid: \"api-key\",\n\t\t$InferServerPlugin: {} as ReturnType<typeof apiKey>,\n\t\tpathMethods: {\n\t\t\t\"/api-key/create\": \"POST\",\n\t\t\t\"/api-key/delete\": \"POST\",\n\t\t\t\"/api-key/delete-all-expired-api-keys\": \"POST\",\n\t\t},\n\t} satisfies BetterAuthClientPlugin;\n};\n\nexport type ApiKeyClientPlugin = ReturnType<typeof apiKeyClient>;\n\nexport type * from \"./types\";\n", "import type {\n\tBetterAuthClientPlugin,\n\tBetterAuthOptions,\n} from \"@better-auth/core\";\n\nexport const InferServerPlugin = <\n\tAuthOrOption extends\n\t\t| BetterAuthOptions\n\t\t| {\n\t\t\t\toptions: BetterAuthOptions;\n\t\t  },\n\tID extends string,\n>() => {\n\ttype Option = AuthOrOption extends { options: infer O } ? O : AuthOrOption;\n\ttype Plugin =\n\t\tOption[\"plugins\"] extends Array<infer P>\n\t\t\t? P extends {\n\t\t\t\t\tid: ID;\n\t\t\t\t}\n\t\t\t\t? P\n\t\t\t\t: never\n\t\t\t: never;\n\treturn {\n\t\tid: \"infer-server-plugin\",\n\t\t$InferServerPlugin: {} as Plugin,\n\t} satisfies BetterAuthClientPlugin;\n};\n", "import type { Auth } from \"better-auth\";\nimport { InferServerPlugin } from \"../../client/plugins\";\nimport type { BetterAuthOptions } from \"../../types\";\n\nexport const customSessionClient = <\n\tA extends\n\t\t| Auth\n\t\t| {\n\t\t\t\toptions: BetterAuthOptions;\n\t\t  },\n>() => {\n\treturn InferServerPlugin<A, \"custom-session\">();\n};\n", "import type { BetterAuthClientPlugin } from \"@better-auth/core\";\nimport type { deviceAuthorization } from \".\";\n\nexport const deviceAuthorizationClient = () => {\n\treturn {\n\t\tid: \"device-authorization\",\n\t\t$InferServerPlugin: {} as ReturnType<typeof deviceAuthorization>,\n\t\tpathMethods: {\n\t\t\t\"/device/code\": \"POST\",\n\t\t\t\"/device/token\": \"POST\",\n\t\t\t\"/device\": \"GET\",\n\t\t\t\"/device/approve\": \"POST\",\n\t\t\t\"/device/deny\": \"POST\",\n\t\t},\n\t} satisfies BetterAuthClientPlugin;\n};\n", "import type { BetterAuthClientPlugin } from \"@better-auth/core\";\nimport type { emailOTP } from \".\";\n\nexport const emailOTPClient = () => {\n\treturn {\n\t\tid: \"email-otp\",\n\t\t$InferServerPlugin: {} as ReturnType<typeof emailOTP>,\n\t\tatomListeners: [\n\t\t\t{\n\t\t\t\tmatcher: (path) =>\n\t\t\t\t\tpath === \"/email-otp/verify-email\" || path === \"/sign-in/email-otp\",\n\t\t\t\tsignal: \"$sessionSignal\",\n\t\t\t},\n\t\t],\n\t} satisfies BetterAuthClientPlugin;\n};\n", "import type { BetterAuthClientPlugin } from \"@better-auth/core\";\nimport type { genericOAuth } from \".\";\n\nexport const genericOAuthClient = () => {\n\treturn {\n\t\tid: \"generic-oauth-client\",\n\t\t$InferServerPlugin: {} as ReturnType<typeof genericOAuth>,\n\t} satisfies BetterAuthClientPlugin;\n};\n\nexport type {\n\tBaseOAuthProviderOptions,\n\tGenericOAuthConfig,\n\tGenericOAuthOptions,\n} from \"./index\";\nexport type * from \"./providers\";\n", "import type { BetterAuthClientPlugin } from \"@better-auth/core\";\nimport type { JSONWebKeySet } from \"jose\";\nimport type { jwt } from \"./index\";\n\ninterface JwtClientOptions {\n\tjwks?: {\n\t\t/**\n\t\t * The path of the endpoint exposing the JWKS.\n\t\t * Must match the server configuration.\n\t\t *\n\t\t * @default /jwks\n\t\t */\n\t\tjwksPath?: string;\n\t};\n}\n\nexport const jwtClient = (options?: JwtClientOptions) => {\n\tconst jwksPath = options?.jwks?.jwksPath ?? \"/jwks\";\n\n\treturn {\n\t\tid: \"better-auth-client\",\n\t\t$InferServerPlugin: {} as ReturnType<typeof jwt>,\n\t\tpathMethods: {\n\t\t\t[jwksPath]: \"GET\",\n\t\t},\n\t\tgetActions: ($fetch) => ({\n\t\t\tjwks: async (fetchOptions?: any) => {\n\t\t\t\treturn await $fetch<JSONWebKeySet>(jwksPath, {\n\t\t\t\t\tmethod: \"GET\",\n\t\t\t\t\t...fetchOptions,\n\t\t\t\t});\n\t\t\t},\n\t\t}),\n\t} satisfies BetterAuthClientPlugin;\n};\n\nexport type * from \"./types\";\n", "import type { BetterAuthClientPlugin } from \"@better-auth/core\";\n\n/**\n * Configuration for the client-side last login method plugin\n */\nexport interface LastLoginMethodClientConfig {\n\t/**\n\t * Name of the cookie to read the last login method from\n\t * @default \"better-auth.last_used_login_method\"\n\t */\n\tcookieName?: string | undefined;\n}\n\nfunction getCookieValue(name: string): string | null {\n\tif (typeof document === \"undefined\") {\n\t\treturn null;\n\t}\n\n\tconst cookie = document.cookie\n\t\t.split(\"; \")\n\t\t.find((row) => row.startsWith(`${name}=`));\n\n\treturn cookie ? cookie.split(\"=\")[1]! : null;\n}\n\n/**\n * Client-side plugin to retrieve the last used login method\n */\nexport const lastLoginMethodClient = (\n\tconfig: LastLoginMethodClientConfig = {},\n) => {\n\tconst cookieName = config.cookieName || \"better-auth.last_used_login_method\";\n\n\treturn {\n\t\tid: \"last-login-method-client\",\n\t\tgetActions() {\n\t\t\treturn {\n\t\t\t\t/**\n\t\t\t\t * Get the last used login method from cookies\n\t\t\t\t * @returns The last used login method or null if not found\n\t\t\t\t */\n\t\t\t\tgetLastUsedLoginMethod: (): string | null => {\n\t\t\t\t\treturn getCookieValue(cookieName);\n\t\t\t\t},\n\t\t\t\t/**\n\t\t\t\t * Clear the last used login method cookie\n\t\t\t\t * This sets the cookie with an expiration date in the past\n\t\t\t\t */\n\t\t\t\tclearLastUsedLoginMethod: (): void => {\n\t\t\t\t\tif (typeof document !== \"undefined\") {\n\t\t\t\t\t\tdocument.cookie = `${cookieName}=; expires=Thu, 01 Jan 1970 00:00:00 UTC; path=/;`;\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t/**\n\t\t\t\t * Check if a specific login method was the last used\n\t\t\t\t * @param method The method to check\n\t\t\t\t * @returns True if the method was the last used, false otherwise\n\t\t\t\t */\n\t\t\t\tisLastUsedLoginMethod: (method: string): boolean => {\n\t\t\t\t\tconst lastMethod = getCookieValue(cookieName);\n\t\t\t\t\treturn lastMethod === method;\n\t\t\t\t},\n\t\t\t};\n\t\t},\n\t} satisfies BetterAuthClientPlugin;\n};\n", "import type { BetterAuthClientPlugin } from \"@better-auth/core\";\nimport type { magicLink } from \".\";\n\nexport const magicLinkClient = () => {\n\treturn {\n\t\tid: \"magic-link\",\n\t\t$InferServerPlugin: {} as ReturnType<typeof magicLink>,\n\t} satisfies BetterAuthClientPlugin;\n};\n", "import type { BetterAuthClientPlugin } from \"@better-auth/core\";\nimport type { multiSession } from \".\";\n\nexport const multiSessionClient = () => {\n\treturn {\n\t\tid: \"multi-session\",\n\t\t$InferServerPlugin: {} as ReturnType<typeof multiSession>,\n\t\tatomListeners: [\n\t\t\t{\n\t\t\t\tmatcher(path) {\n\t\t\t\t\treturn path === \"/multi-session/set-active\";\n\t\t\t\t},\n\t\t\t\tsignal: \"$sessionSignal\",\n\t\t\t},\n\t\t],\n\t} satisfies BetterAuthClientPlugin;\n};\n\nexport type { MultiSessionConfig } from \"./index\";\n", "import type { BetterAuthClientPlugin } from \"@better-auth/core\";\nimport type { oidcProvider } from \".\";\n\nexport const oidcClient = () => {\n\treturn {\n\t\tid: \"oidc-client\",\n\t\t$InferServerPlugin: {} as ReturnType<typeof oidcProvider>,\n\t} satisfies BetterAuthClientPlugin;\n};\n\nexport type OidcClientPlugin = ReturnType<typeof oidcClient>;\n\nexport type * from \"./types\";\n", "import type {\n\tBetterAuthClientPlugin,\n\tClientFetchOption,\n} from \"@better-auth/core\";\n\ndeclare global {\n\tinterface Window {\n\t\tgoogle?:\n\t\t\t| {\n\t\t\t\t\taccounts: {\n\t\t\t\t\t\tid: {\n\t\t\t\t\t\t\tinitialize: (config: any) => void;\n\t\t\t\t\t\t\tprompt: (callback?: (notification: any) => void) => void;\n\t\t\t\t\t\t};\n\t\t\t\t\t};\n\t\t\t  }\n\t\t\t| undefined;\n\t\tgoogleScriptInitialized?: boolean | undefined;\n\t}\n}\n\nexport interface GoogleOneTapOptions {\n\t/**\n\t * Google client ID\n\t */\n\tclientId: string;\n\t/**\n\t * Auto select the account if the user is already signed in\n\t */\n\tautoSelect?: boolean | undefined;\n\t/**\n\t * Cancel the flow when the user taps outside the prompt\n\t *\n\t * Note: To use this option, disable `promptOptions.fedCM`\n\t */\n\tcancelOnTapOutside?: boolean | undefined;\n\t/**\n\t * The mode to use for the Google One Tap flow\n\t *\n\t * popup: Use a popup window\n\t * redirect: Redirect the user to the Google One Tap flow\n\t *\n\t * @default \"popup\"\n\t */\n\tuxMode?: (\"popup\" | \"redirect\") | undefined;\n\t/**\n\t * The context to use for the Google One Tap flow.\n\t *\n\t * @see {@link https://developers.google.com/identity/gsi/web/reference/js-reference}\n\t * @default \"signin\"\n\t */\n\tcontext?: (\"signin\" | \"signup\" | \"use\") | undefined;\n\t/**\n\t * Additional configuration options to pass to the Google One Tap API.\n\t */\n\tadditionalOptions?: Record<string, any> | undefined;\n\t/**\n\t * Configuration options for the prompt and exponential backoff behavior.\n\t */\n\tpromptOptions?:\n\t\t| {\n\t\t\t\t/**\n\t\t\t\t * Base delay (in milliseconds) for exponential backoff.\n\t\t\t\t * @default 1000\n\t\t\t\t */\n\t\t\t\tbaseDelay?: number;\n\t\t\t\t/**\n\t\t\t\t * Maximum number of prompt attempts before calling onPromptNotification.\n\t\t\t\t * @default 5\n\t\t\t\t */\n\t\t\t\tmaxAttempts?: number;\n\t\t\t\t/**\n\t\t\t\t * Whether to support FedCM (Federated Credential Management) support.\n\t\t\t\t *\n\t\t\t\t * @see {@link https://developer.chrome.com/docs/identity/fedcm/overview}\n\t\t\t\t * @default true\n\t\t\t\t */\n\t\t\t\tfedCM?: boolean | undefined;\n\t\t  }\n\t\t| undefined;\n}\n\nexport interface GoogleOneTapActionOptions\n\textends Omit<GoogleOneTapOptions, \"clientId\" | \"promptOptions\"> {\n\tfetchOptions?: ClientFetchOption | undefined;\n\t/**\n\t * Callback URL.\n\t */\n\tcallbackURL?: string | undefined;\n\t/**\n\t * Optional callback that receives the prompt notification if (or when) the prompt is dismissed or skipped.\n\t * This lets you render an alternative UI (e.g. a Google Sign-In button) to restart the process.\n\t */\n\tonPromptNotification?: ((notification?: any | undefined) => void) | undefined;\n\tnonce?: string | undefined;\n}\n\ninterface IdentityCredential {\n\treadonly configURL: string;\n\treadonly isAutoSelected: boolean;\n\ttoken: string;\n}\n\nlet isRequestInProgress: AbortController | null = null;\n\nfunction isFedCMSupported() {\n\treturn typeof window !== \"undefined\" && \"IdentityCredential\" in window;\n}\n\n/**\n * Reasons that should NOT trigger a retry.\n * @see https://developers.google.com/identity/gsi/web/reference/js-reference\n */\nconst noRetryReasons = {\n\tdismissed: [\"credential_returned\", \"cancel_called\"],\n\tskipped: [\"user_cancel\", \"tap_outside\"],\n} as const;\n\nexport const oneTapClient = (options: GoogleOneTapOptions) => {\n\treturn {\n\t\tid: \"one-tap\",\n\t\tfetchPlugins: [\n\t\t\t{\n\t\t\t\tid: \"fedcm-signout-handle\",\n\t\t\t\tname: \"FedCM Sign-Out Handler\",\n\t\t\t\thooks: {\n\t\t\t\t\tasync onResponse(ctx) {\n\t\t\t\t\t\tif (!ctx.request.url.toString().includes(\"/sign-out\")) {\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (options.promptOptions?.fedCM === false || !isFedCMSupported()) {\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnavigator.credentials.preventSilentAccess();\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t],\n\t\tgetActions: ($fetch, _) => {\n\t\t\treturn {\n\t\t\t\toneTap: async (\n\t\t\t\t\topts?: GoogleOneTapActionOptions | undefined,\n\t\t\t\t\tfetchOptions?: ClientFetchOption | undefined,\n\t\t\t\t) => {\n\t\t\t\t\tif (isRequestInProgress && !isRequestInProgress.signal.aborted) {\n\t\t\t\t\t\tconsole.warn(\n\t\t\t\t\t\t\t\"A Google One Tap request is already in progress. Please wait.\",\n\t\t\t\t\t\t);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (typeof window === \"undefined\" || !window.document) {\n\t\t\t\t\t\tconsole.warn(\n\t\t\t\t\t\t\t\"Google One Tap is only available in browser environments\",\n\t\t\t\t\t\t);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tasync function callback(idToken: string) {\n\t\t\t\t\t\tawait $fetch(\"/one-tap/callback\", {\n\t\t\t\t\t\t\tmethod: \"POST\",\n\t\t\t\t\t\t\tbody: { idToken },\n\t\t\t\t\t\t\t...opts?.fetchOptions,\n\t\t\t\t\t\t\t...fetchOptions,\n\t\t\t\t\t\t});\n\n\t\t\t\t\t\tif ((!opts?.fetchOptions && !fetchOptions) || opts?.callbackURL) {\n\t\t\t\t\t\t\twindow.location.href = opts?.callbackURL ?? \"/\";\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tconst { autoSelect, cancelOnTapOutside, context } = opts ?? {};\n\t\t\t\t\tconst contextValue = context ?? options.context ?? \"signin\";\n\t\t\t\t\tconst clients = {\n\t\t\t\t\t\tfedCM: async () => {\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tconst identityCredential = (await navigator.credentials.get({\n\t\t\t\t\t\t\t\t\tidentity: {\n\t\t\t\t\t\t\t\t\t\tcontext: contextValue,\n\t\t\t\t\t\t\t\t\t\tproviders: [\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\tconfigURL: \"https://accounts.google.com/gsi/fedcm.json\",\n\t\t\t\t\t\t\t\t\t\t\t\tclientId: options.clientId,\n\t\t\t\t\t\t\t\t\t\t\t\tnonce: opts?.nonce,\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t],\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tmediation: autoSelect ? \"optional\" : \"required\",\n\t\t\t\t\t\t\t\t\tsignal: isRequestInProgress?.signal,\n\t\t\t\t\t\t\t\t} as any)) as IdentityCredential | null;\n\n\t\t\t\t\t\t\t\tif (!identityCredential?.token) {\n\t\t\t\t\t\t\t\t\t// Notify the caller that the prompt resulted in no token.\n\t\t\t\t\t\t\t\t\topts?.onPromptNotification?.(undefined);\n\t\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\tawait callback(identityCredential.token);\n\t\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\t\t\t\tconsole.error(\"Error during FedCM callback:\", error);\n\t\t\t\t\t\t\t\t\tthrow error;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} catch (error: any) {\n\t\t\t\t\t\t\t\tif (error?.code && (error.code === 19 || error.code === 20)) {\n\t\t\t\t\t\t\t\t\t// Notify the caller that the prompt was closed/dismissed.\n\t\t\t\t\t\t\t\t\topts?.onPromptNotification?.(undefined);\n\t\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tthrow error;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t},\n\t\t\t\t\t\toneTap: () => {\n\t\t\t\t\t\t\treturn new Promise<void>((resolve, reject) => {\n\t\t\t\t\t\t\t\tlet isResolved = false;\n\t\t\t\t\t\t\t\tconst baseDelay = options.promptOptions?.baseDelay ?? 1000;\n\t\t\t\t\t\t\t\tconst maxAttempts = options.promptOptions?.maxAttempts ?? 5;\n\n\t\t\t\t\t\t\t\twindow.google?.accounts.id.initialize({\n\t\t\t\t\t\t\t\t\tclient_id: options.clientId,\n\t\t\t\t\t\t\t\t\tcallback: async (response: { credential: string }) => {\n\t\t\t\t\t\t\t\t\t\tisResolved = true;\n\t\t\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\t\t\tawait callback(response.credential);\n\t\t\t\t\t\t\t\t\t\t\tresolve();\n\t\t\t\t\t\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\t\t\t\t\t\tconsole.error(\"Error during One Tap callback:\", error);\n\t\t\t\t\t\t\t\t\t\t\treject(error);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tauto_select: autoSelect,\n\t\t\t\t\t\t\t\t\tcancel_on_tap_outside: cancelOnTapOutside,\n\t\t\t\t\t\t\t\t\tcontext: contextValue,\n\t\t\t\t\t\t\t\t\tux_mode: opts?.uxMode || \"popup\",\n\t\t\t\t\t\t\t\t\tnonce: opts?.nonce,\n\t\t\t\t\t\t\t\t\t/**\n\t\t\t\t\t\t\t\t\t * @see {@link https://developers.google.com/identity/gsi/web/guides/overview}\n\t\t\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\t\t\titp_support: true,\n\n\t\t\t\t\t\t\t\t\t...options.additionalOptions,\n\t\t\t\t\t\t\t\t});\n\n\t\t\t\t\t\t\t\tconst handlePrompt = (attempt: number) => {\n\t\t\t\t\t\t\t\t\tif (isResolved) return;\n\n\t\t\t\t\t\t\t\t\twindow.google?.accounts.id.prompt((notification: any) => {\n\t\t\t\t\t\t\t\t\t\tif (isResolved) return;\n\n\t\t\t\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t\t\t\tnotification.isDismissedMoment &&\n\t\t\t\t\t\t\t\t\t\t\tnotification.isDismissedMoment()\n\t\t\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\t\t\tconst reason = notification.getDismissedReason?.();\n\t\t\t\t\t\t\t\t\t\t\tif (noRetryReasons.dismissed.includes(reason)) {\n\t\t\t\t\t\t\t\t\t\t\t\topts?.onPromptNotification?.(notification);\n\t\t\t\t\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\tif (attempt < maxAttempts) {\n\t\t\t\t\t\t\t\t\t\t\t\tconst delay = Math.pow(2, attempt) * baseDelay;\n\t\t\t\t\t\t\t\t\t\t\t\tsetTimeout(() => handlePrompt(attempt + 1), delay);\n\t\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\t\topts?.onPromptNotification?.(notification);\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t} else if (\n\t\t\t\t\t\t\t\t\t\t\tnotification.isSkippedMoment &&\n\t\t\t\t\t\t\t\t\t\t\tnotification.isSkippedMoment()\n\t\t\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\t\t\tconst reason = notification.getSkippedReason?.();\n\t\t\t\t\t\t\t\t\t\t\tif (noRetryReasons.skipped.includes(reason)) {\n\t\t\t\t\t\t\t\t\t\t\t\topts?.onPromptNotification?.(notification);\n\t\t\t\t\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\tif (attempt < maxAttempts) {\n\t\t\t\t\t\t\t\t\t\t\t\tconst delay = Math.pow(2, attempt) * baseDelay;\n\t\t\t\t\t\t\t\t\t\t\t\tsetTimeout(() => handlePrompt(attempt + 1), delay);\n\t\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\t\topts?.onPromptNotification?.(notification);\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t};\n\n\t\t\t\t\t\t\t\thandlePrompt(0);\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t},\n\t\t\t\t\t};\n\n\t\t\t\t\tif (isRequestInProgress) {\n\t\t\t\t\t\tisRequestInProgress?.abort();\n\t\t\t\t\t}\n\t\t\t\t\tisRequestInProgress = new AbortController();\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tconst client =\n\t\t\t\t\t\t\toptions.promptOptions?.fedCM === false || !isFedCMSupported()\n\t\t\t\t\t\t\t\t? \"oneTap\"\n\t\t\t\t\t\t\t\t: \"fedCM\";\n\t\t\t\t\t\tif (client === \"oneTap\") {\n\t\t\t\t\t\t\tawait loadGoogleScript();\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tawait clients[client]();\n\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\tconsole.error(\"Error during Google One Tap flow:\", error);\n\t\t\t\t\t\tthrow error;\n\t\t\t\t\t} finally {\n\t\t\t\t\t\tisRequestInProgress = null;\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t};\n\t\t},\n\t\tgetAtoms($fetch) {\n\t\t\treturn {};\n\t\t},\n\t} satisfies BetterAuthClientPlugin;\n};\n\nconst loadGoogleScript = (): Promise<void> => {\n\treturn new Promise((resolve) => {\n\t\tif (window.googleScriptInitialized) {\n\t\t\tresolve();\n\t\t\treturn;\n\t\t}\n\n\t\tconst script = document.createElement(\"script\");\n\t\tscript.src = \"https://accounts.google.com/gsi/client\";\n\t\tscript.async = true;\n\t\tscript.defer = true;\n\t\tscript.onload = () => {\n\t\t\twindow.googleScriptInitialized = true;\n\t\t\tresolve();\n\t\t};\n\t\tdocument.head.appendChild(script);\n\t});\n};\n", "import type { BetterAuthClientPlugin } from \"@better-auth/core\";\nimport type { oneTimeToken } from \"./index\";\n\nexport const oneTimeTokenClient = () => {\n\treturn {\n\t\tid: \"one-time-token\",\n\t\t$InferServerPlugin: {} as ReturnType<typeof oneTimeToken>,\n\t} satisfies BetterAuthClientPlugin;\n};\n\nexport type { OneTimeTokenOptions } from \"./index\";\n", "import type { BetterAuthClientPlugin } from \"@better-auth/core\";\nimport type { DBFieldAttribute } from \"@better-auth/core/db\";\nimport { atom } from \"nanostores\";\nimport { useAuthQuery } from \"../../client\";\nimport type {\n\tInferInvitation,\n\tInferMember,\n\tInferOrganization,\n\tInferTeam,\n\tMember,\n} from \"../../plugins/organization/schema\";\nimport type { BetterAuthOptions, BetterAuthPlugin } from \"../../types\";\nimport type { Prettify } from \"../../types/helper\";\nimport type { AccessControl, Role } from \"../access\";\nimport type { defaultStatements } from \"./access\";\nimport { adminAc, defaultRoles, memberAc, ownerAc } from \"./access\";\nimport type { OrganizationPlugin } from \"./organization\";\nimport type { HasPermissionBaseInput } from \"./permission\";\nimport { hasPermissionFn } from \"./permission\";\nimport type { OrganizationOptions } from \"./types\";\n\n/**\n * Using the same `hasPermissionFn` function, but without the need for a `ctx` parameter or the `organizationId` parameter.\n */\nexport const clientSideHasPermission = (input: HasPermissionBaseInput) => {\n\tconst acRoles: {\n\t\t[x: string]: Role<any> | undefined;\n\t} = input.options.roles || defaultRoles;\n\n\treturn hasPermissionFn(input, acRoles);\n};\n\ninterface OrganizationClientOptions {\n\tac?: AccessControl | undefined;\n\troles?:\n\t\t| {\n\t\t\t\t[key in string]: Role;\n\t\t  }\n\t\t| undefined;\n\tteams?:\n\t\t| {\n\t\t\t\tenabled: boolean;\n\t\t  }\n\t\t| undefined;\n\tschema?:\n\t\t| {\n\t\t\t\torganization?: {\n\t\t\t\t\tadditionalFields?: {\n\t\t\t\t\t\t[key: string]: DBFieldAttribute;\n\t\t\t\t\t};\n\t\t\t\t};\n\t\t\t\tmember?: {\n\t\t\t\t\tadditionalFields?: {\n\t\t\t\t\t\t[key: string]: DBFieldAttribute;\n\t\t\t\t\t};\n\t\t\t\t};\n\t\t\t\tinvitation?: {\n\t\t\t\t\tadditionalFields?: {\n\t\t\t\t\t\t[key: string]: DBFieldAttribute;\n\t\t\t\t\t};\n\t\t\t\t};\n\t\t\t\tteam?: {\n\t\t\t\t\tadditionalFields?: {\n\t\t\t\t\t\t[key: string]: DBFieldAttribute;\n\t\t\t\t\t};\n\t\t\t\t};\n\t\t\t\torganizationRole?: {\n\t\t\t\t\tadditionalFields?: {\n\t\t\t\t\t\t[key: string]: DBFieldAttribute;\n\t\t\t\t\t};\n\t\t\t\t};\n\t\t  }\n\t\t| undefined;\n\tdynamicAccessControl?:\n\t\t| {\n\t\t\t\tenabled: boolean;\n\t\t  }\n\t\t| undefined;\n}\n\nexport const organizationClient = <CO extends OrganizationClientOptions>(\n\toptions?: CO | undefined,\n) => {\n\tconst $listOrg = atom<boolean>(false);\n\tconst $activeOrgSignal = atom<boolean>(false);\n\tconst $activeMemberSignal = atom<boolean>(false);\n\tconst $activeMemberRoleSignal = atom<boolean>(false);\n\n\ttype DefaultStatements = typeof defaultStatements;\n\ttype Statements =\n\t\tCO[\"ac\"] extends AccessControl<infer S> ? S : DefaultStatements;\n\ttype PermissionType = {\n\t\t[key in keyof Statements]?: Array<\n\t\t\tStatements[key] extends readonly unknown[]\n\t\t\t\t? Statements[key][number]\n\t\t\t\t: never\n\t\t>;\n\t};\n\ttype PermissionExclusive =\n\t\t| {\n\t\t\t\t/**\n\t\t\t\t * @deprecated Use `permissions` instead\n\t\t\t\t */\n\t\t\t\tpermission: PermissionType;\n\t\t\t\tpermissions?: never | undefined;\n\t\t  }\n\t\t| {\n\t\t\t\tpermissions: PermissionType;\n\t\t\t\tpermission?: never | undefined;\n\t\t  };\n\n\tconst roles = {\n\t\tadmin: adminAc,\n\t\tmember: memberAc,\n\t\towner: ownerAc,\n\t\t...options?.roles,\n\t};\n\n\ttype OrganizationReturn = CO[\"teams\"] extends { enabled: true }\n\t\t? {\n\t\t\t\tmembers: InferMember<CO, false>[];\n\t\t\t\tinvitations: InferInvitation<CO>[];\n\t\t\t\tteams: InferTeam<CO, false>[];\n\t\t\t} & InferOrganization<CO, false>\n\t\t: {\n\t\t\t\tmembers: InferMember<CO, false>[];\n\t\t\t\tinvitations: InferInvitation<CO, false>[];\n\t\t\t} & InferOrganization<CO, false>;\n\n\ttype Schema = CO[\"schema\"];\n\treturn {\n\t\tid: \"organization\",\n\t\t$InferServerPlugin: {} as OrganizationPlugin<{\n\t\t\tac: CO[\"ac\"] extends AccessControl\n\t\t\t\t? CO[\"ac\"]\n\t\t\t\t: AccessControl<DefaultStatements>;\n\t\t\troles: CO[\"roles\"] extends Record<string, Role>\n\t\t\t\t? CO[\"roles\"]\n\t\t\t\t: {\n\t\t\t\t\t\tadmin: Role;\n\t\t\t\t\t\tmember: Role;\n\t\t\t\t\t\towner: Role;\n\t\t\t\t\t};\n\t\t\tteams: {\n\t\t\t\tenabled: CO[\"teams\"] extends { enabled: true } ? true : false;\n\t\t\t};\n\t\t\tschema: Schema;\n\t\t\tdynamicAccessControl: {\n\t\t\t\tenabled: CO[\"dynamicAccessControl\"] extends { enabled: true }\n\t\t\t\t\t? true\n\t\t\t\t\t: false;\n\t\t\t};\n\t\t}>,\n\t\tgetActions: ($fetch, _$store, co) => ({\n\t\t\t$Infer: {\n\t\t\t\tActiveOrganization: {} as OrganizationReturn,\n\t\t\t\tOrganization: {} as InferOrganization<CO, false>,\n\t\t\t\tInvitation: {} as InferInvitation<CO, false>,\n\t\t\t\tMember: {} as InferMember<CO, false>,\n\t\t\t\tTeam: {} as InferTeam<CO, false>,\n\t\t\t},\n\t\t\torganization: {\n\t\t\t\tcheckRolePermission: <\n\t\t\t\t\tR extends CO extends { roles: any }\n\t\t\t\t\t\t? keyof CO[\"roles\"]\n\t\t\t\t\t\t: \"admin\" | \"member\" | \"owner\",\n\t\t\t\t>(\n\t\t\t\t\tdata: PermissionExclusive & {\n\t\t\t\t\t\trole: R;\n\t\t\t\t\t},\n\t\t\t\t) => {\n\t\t\t\t\tconst isAuthorized = clientSideHasPermission({\n\t\t\t\t\t\trole: data.role as string,\n\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\tac: options?.ac,\n\t\t\t\t\t\t\troles: roles,\n\t\t\t\t\t\t},\n\t\t\t\t\t\tpermissions: (data.permissions ?? data.permission) as any,\n\t\t\t\t\t});\n\t\t\t\t\treturn isAuthorized;\n\t\t\t\t},\n\t\t\t},\n\t\t}),\n\t\tgetAtoms: ($fetch) => {\n\t\t\tconst listOrganizations = useAuthQuery<InferOrganization<CO, false>[]>(\n\t\t\t\t$listOrg,\n\t\t\t\t\"/organization/list\",\n\t\t\t\t$fetch,\n\t\t\t\t{\n\t\t\t\t\tmethod: \"GET\",\n\t\t\t\t},\n\t\t\t);\n\t\t\tconst activeOrganization = useAuthQuery<\n\t\t\t\tPrettify<\n\t\t\t\t\tInferOrganization<CO, false> & {\n\t\t\t\t\t\tmembers: InferMember<CO, false>[];\n\t\t\t\t\t\tinvitations: InferInvitation<CO, false>[];\n\t\t\t\t\t}\n\t\t\t\t>\n\t\t\t>(\n\t\t\t\t[$activeOrgSignal],\n\t\t\t\t\"/organization/get-full-organization\",\n\t\t\t\t$fetch,\n\t\t\t\t() => ({\n\t\t\t\t\tmethod: \"GET\",\n\t\t\t\t}),\n\t\t\t);\n\n\t\t\tconst activeMember = useAuthQuery<Member>(\n\t\t\t\t[$activeMemberSignal],\n\t\t\t\t\"/organization/get-active-member\",\n\t\t\t\t$fetch,\n\t\t\t\t{\n\t\t\t\t\tmethod: \"GET\",\n\t\t\t\t},\n\t\t\t);\n\n\t\t\tconst activeMemberRole = useAuthQuery<{ role: string }>(\n\t\t\t\t[$activeMemberRoleSignal],\n\t\t\t\t\"/organization/get-active-member-role\",\n\t\t\t\t$fetch,\n\t\t\t\t{\n\t\t\t\t\tmethod: \"GET\",\n\t\t\t\t},\n\t\t\t);\n\n\t\t\treturn {\n\t\t\t\t$listOrg,\n\t\t\t\t$activeOrgSignal,\n\t\t\t\t$activeMemberSignal,\n\t\t\t\t$activeMemberRoleSignal,\n\t\t\t\tactiveOrganization,\n\t\t\t\tlistOrganizations,\n\t\t\t\tactiveMember,\n\t\t\t\tactiveMemberRole,\n\t\t\t};\n\t\t},\n\t\tpathMethods: {\n\t\t\t\"/organization/get-full-organization\": \"GET\",\n\t\t\t\"/organization/list-user-teams\": \"GET\",\n\t\t},\n\t\tatomListeners: [\n\t\t\t{\n\t\t\t\tmatcher(path) {\n\t\t\t\t\treturn (\n\t\t\t\t\t\tpath === \"/organization/create\" ||\n\t\t\t\t\t\tpath === \"/organization/delete\" ||\n\t\t\t\t\t\tpath === \"/organization/update\"\n\t\t\t\t\t);\n\t\t\t\t},\n\t\t\t\tsignal: \"$listOrg\",\n\t\t\t},\n\t\t\t{\n\t\t\t\tmatcher(path) {\n\t\t\t\t\treturn path.startsWith(\"/organization\");\n\t\t\t\t},\n\t\t\t\tsignal: \"$activeOrgSignal\",\n\t\t\t},\n\t\t\t{\n\t\t\t\tmatcher(path) {\n\t\t\t\t\treturn path.startsWith(\"/organization/set-active\");\n\t\t\t\t},\n\t\t\t\tsignal: \"$sessionSignal\",\n\t\t\t},\n\t\t\t{\n\t\t\t\tmatcher(path) {\n\t\t\t\t\treturn path.includes(\"/organization/update-member-role\");\n\t\t\t\t},\n\t\t\t\tsignal: \"$activeMemberSignal\",\n\t\t\t},\n\t\t\t{\n\t\t\t\tmatcher(path) {\n\t\t\t\t\treturn path.includes(\"/organization/update-member-role\");\n\t\t\t\t},\n\t\t\t\tsignal: \"$activeMemberRoleSignal\",\n\t\t\t},\n\t\t],\n\t} satisfies BetterAuthClientPlugin;\n};\n\nexport const inferOrgAdditionalFields = <\n\tO extends {\n\t\toptions: BetterAuthOptions;\n\t},\n\tS extends OrganizationOptions[\"schema\"] = undefined,\n>(\n\tschema?: S | undefined,\n) => {\n\ttype FindById<\n\t\tT extends readonly BetterAuthPlugin[],\n\t\tTargetId extends string,\n\t> = Extract<T[number], { id: TargetId }>;\n\n\ttype Auth = O extends { options: any } ? O : { options: { plugins: [] } };\n\n\ttype OrganizationPlugin = FindById<\n\t\t// @ts-expect-error\n\t\tAuth[\"options\"][\"plugins\"],\n\t\t\"organization\"\n\t>;\n\n\t// The server schema can contain more properties other than additionalFields, but the client only supports additionalFields\n\t// if we don't remove all other properties we may see assignability issues\n\n\ttype ExtractClientOnlyFields<T> = {\n\t\t[K in keyof T]: T[K] extends { additionalFields: infer _AF }\n\t\t\t? T[K]\n\t\t\t: undefined;\n\t};\n\n\ttype Schema = O extends Object\n\t\t? O extends Exclude<OrganizationOptions[\"schema\"], undefined>\n\t\t\t? O\n\t\t\t: OrganizationPlugin extends { options: { schema: infer S } }\n\t\t\t\t? S extends OrganizationOptions[\"schema\"]\n\t\t\t\t\t? ExtractClientOnlyFields<S>\n\t\t\t\t\t: undefined\n\t\t\t\t: undefined\n\t\t: undefined;\n\treturn {} as undefined extends S ? Schema : S;\n};\n\nexport type * from \"./schema\";\n", "import type { BetterAuthClientPlugin } from \"@better-auth/core\";\nimport type { phoneNumber } from \".\";\n\nexport const phoneNumberClient = () => {\n\treturn {\n\t\tid: \"phoneNumber\",\n\t\t$InferServerPlugin: {} as ReturnType<typeof phoneNumber>,\n\t\tatomListeners: [\n\t\t\t{\n\t\t\t\tmatcher(path) {\n\t\t\t\t\treturn (\n\t\t\t\t\t\tpath === \"/phone-number/update\" ||\n\t\t\t\t\t\tpath === \"/phone-number/verify\" ||\n\t\t\t\t\t\tpath === \"/sign-in/phone-number\"\n\t\t\t\t\t);\n\t\t\t\t},\n\t\t\t\tsignal: \"$sessionSignal\",\n\t\t\t},\n\t\t],\n\t} satisfies BetterAuthClientPlugin;\n};\n\nexport type * from \"./types\";\n", "import type { BetterAuthClientPlugin } from \"@better-auth/core\";\nimport type { siwe } from \".\";\n\nexport const siweClient = () => {\n\treturn {\n\t\tid: \"siwe\",\n\t\t$InferServerPlugin: {} as ReturnType<typeof siwe>,\n\t} satisfies BetterAuthClientPlugin;\n};\n", "import type { BetterAuthClientPlugin } from \"@better-auth/core\";\nimport type { username } from \".\";\n\nexport const usernameClient = () => {\n\treturn {\n\t\tid: \"username\",\n\t\t$InferServerPlugin: {} as ReturnType<typeof username>,\n\t\tatomListeners: [\n\t\t\t{\n\t\t\t\tmatcher: (path) => path === \"/sign-in/username\",\n\t\t\t\tsignal: \"$sessionSignal\",\n\t\t\t},\n\t\t],\n\t} satisfies BetterAuthClientPlugin;\n};\n"],
  "mappings": "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",
  "names": ["isRequestInProgress: AbortController | null", "error: any", "adminAc"]
}
