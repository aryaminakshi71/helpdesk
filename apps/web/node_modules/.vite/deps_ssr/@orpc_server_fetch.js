import {
  createContractedProcedure,
  createProcedureClient,
  fallbackContractConfig,
  getRouter,
  isProcedure,
  traverseContractProcedures,
  unlazy
} from "./chunk-AKOVV7UZ.js";
import {
  StandardRPCJsonSerializer,
  StandardRPCSerializer,
  toFetchResponse,
  toHttpPath,
  toStandardLazyRequest
} from "./chunk-LPWLMQMF.js";
import "./chunk-TDB4QQTE.js";
import {
  ORPCError,
  flattenHeader,
  toORPCError
} from "./chunk-NUVUCMDO.js";
import {
  NullProtoObj,
  ORPC_NAME,
  asyncIteratorWithSpan,
  intercept,
  isAsyncIteratorObject,
  parseEmptyableJSON,
  resolveMaybeOptionalOptions,
  runWithSpan,
  setSpanError,
  toArray,
  value
} from "./chunk-FX53GUXJ.js";
import "./chunk-PLDDJCW6.js";

// ../../node_modules/.bun/@orpc+server@1.13.4+64f0629d09b745d9/node_modules/@orpc/server/dist/shared/server.DZ5BIITo.mjs
function resolveFriendlyStandardHandleOptions(options) {
  return {
    ...options,
    context: options.context ?? {}
    // Context only optional if all fields are optional
  };
}

// ../../node_modules/.bun/@orpc+server@1.13.4+64f0629d09b745d9/node_modules/@orpc/server/dist/shared/server.Bxx6tqNe.mjs
var CompositeStandardHandlerPlugin = class {
  plugins;
  constructor(plugins = []) {
    this.plugins = [...plugins].sort((a, b) => (a.order ?? 0) - (b.order ?? 0));
  }
  init(options, router) {
    for (const plugin of this.plugins) {
      plugin.init?.(options, router);
    }
  }
};
var StandardHandler = class {
  constructor(router, matcher, codec, options) {
    this.matcher = matcher;
    this.codec = codec;
    const plugins = new CompositeStandardHandlerPlugin(options.plugins);
    plugins.init(options, router);
    this.interceptors = toArray(options.interceptors);
    this.clientInterceptors = toArray(options.clientInterceptors);
    this.rootInterceptors = toArray(options.rootInterceptors);
    this.matcher.init(router);
  }
  interceptors;
  clientInterceptors;
  rootInterceptors;
  async handle(request, options) {
    const prefix = options.prefix?.replace(/\/$/, "") || void 0;
    if (prefix && !request.url.pathname.startsWith(`${prefix}/`) && request.url.pathname !== prefix) {
      return { matched: false, response: void 0 };
    }
    return intercept(
      this.rootInterceptors,
      { ...options, request, prefix },
      async (interceptorOptions) => {
        return runWithSpan(
          { name: `${request.method} ${request.url.pathname}` },
          async (span) => {
            let step;
            try {
              return await intercept(
                this.interceptors,
                interceptorOptions,
                async ({ request: request2, context, prefix: prefix2 }) => {
                  const method = request2.method;
                  const url = request2.url;
                  const pathname = prefix2 ? url.pathname.replace(prefix2, "") : url.pathname;
                  const match = await runWithSpan(
                    { name: "find_procedure" },
                    () => this.matcher.match(method, `/${pathname.replace(/^\/|\/$/g, "")}`)
                  );
                  if (!match) {
                    return { matched: false, response: void 0 };
                  }
                  span?.updateName(`${ORPC_NAME}.${match.path.join("/")}`);
                  span?.setAttribute("rpc.system", ORPC_NAME);
                  span?.setAttribute("rpc.method", match.path.join("."));
                  step = "decode_input";
                  let input = await runWithSpan(
                    { name: "decode_input" },
                    () => this.codec.decode(request2, match.params, match.procedure)
                  );
                  step = void 0;
                  if (isAsyncIteratorObject(input)) {
                    input = asyncIteratorWithSpan(
                      { name: "consume_event_iterator_input", signal: request2.signal },
                      input
                    );
                  }
                  const client = createProcedureClient(match.procedure, {
                    context,
                    path: match.path,
                    interceptors: this.clientInterceptors
                  });
                  step = "call_procedure";
                  const output = await client(input, {
                    signal: request2.signal,
                    lastEventId: flattenHeader(request2.headers["last-event-id"])
                  });
                  step = void 0;
                  const response = this.codec.encode(output, match.procedure);
                  return {
                    matched: true,
                    response
                  };
                }
              );
            } catch (e) {
              if (step !== "call_procedure") {
                setSpanError(span, e);
              }
              const error = step === "decode_input" && !(e instanceof ORPCError) ? new ORPCError("BAD_REQUEST", {
                message: `Malformed request. Ensure the request body is properly formatted and the 'Content-Type' header is set correctly.`,
                cause: e
              }) : toORPCError(e);
              const response = this.codec.encodeError(error);
              return {
                matched: true,
                response
              };
            }
          }
        );
      }
    );
  }
};
var StandardRPCCodec = class {
  constructor(serializer) {
    this.serializer = serializer;
  }
  async decode(request, _params, _procedure) {
    const serialized = request.method === "GET" ? parseEmptyableJSON(request.url.searchParams.getAll("data").at(-1)) : await request.body();
    return this.serializer.deserialize(serialized);
  }
  encode(output, _procedure) {
    return {
      status: 200,
      headers: {},
      body: this.serializer.serialize(output)
    };
  }
  encodeError(error) {
    return {
      status: error.status,
      headers: {},
      body: this.serializer.serialize(error.toJSON())
    };
  }
};
var StandardRPCMatcher = class {
  filter;
  tree = new NullProtoObj();
  pendingRouters = [];
  constructor(options = {}) {
    this.filter = options.filter ?? true;
  }
  init(router, path = []) {
    const laziedOptions = traverseContractProcedures({ router, path }, (traverseOptions) => {
      if (!value(this.filter, traverseOptions)) {
        return;
      }
      const { path: path2, contract } = traverseOptions;
      const httpPath = toHttpPath(path2);
      if (isProcedure(contract)) {
        this.tree[httpPath] = {
          path: path2,
          contract,
          procedure: contract,
          // this mean dev not used contract-first so we can used contract as procedure directly
          router
        };
      } else {
        this.tree[httpPath] = {
          path: path2,
          contract,
          procedure: void 0,
          router
        };
      }
    });
    this.pendingRouters.push(...laziedOptions.map((option) => ({
      ...option,
      httpPathPrefix: toHttpPath(option.path)
    })));
  }
  async match(_method, pathname) {
    if (this.pendingRouters.length) {
      const newPendingRouters = [];
      for (const pendingRouter of this.pendingRouters) {
        if (pathname.startsWith(pendingRouter.httpPathPrefix)) {
          const { default: router } = await unlazy(pendingRouter.router);
          this.init(router, pendingRouter.path);
        } else {
          newPendingRouters.push(pendingRouter);
        }
      }
      this.pendingRouters = newPendingRouters;
    }
    const match = this.tree[pathname];
    if (!match) {
      return void 0;
    }
    if (!match.procedure) {
      const { default: maybeProcedure } = await unlazy(getRouter(match.router, match.path));
      if (!isProcedure(maybeProcedure)) {
        throw new Error(`
          [Contract-First] Missing or invalid implementation for procedure at path: ${toHttpPath(match.path)}.
          Ensure that the procedure is correctly defined and matches the expected contract.
        `);
      }
      match.procedure = createContractedProcedure(maybeProcedure, match.contract);
    }
    return {
      path: match.path,
      procedure: match.procedure
    };
  }
};
var StandardRPCHandler = class extends StandardHandler {
  constructor(router, options = {}) {
    const jsonSerializer = new StandardRPCJsonSerializer(options);
    const serializer = new StandardRPCSerializer(jsonSerializer);
    const matcher = new StandardRPCMatcher(options);
    const codec = new StandardRPCCodec(serializer);
    super(router, matcher, codec, options);
  }
};

// ../../node_modules/.bun/@orpc+server@1.13.4+64f0629d09b745d9/node_modules/@orpc/server/dist/shared/server.TEVCLCFC.mjs
var STRICT_GET_METHOD_PLUGIN_IS_GET_METHOD_CONTEXT_SYMBOL = /* @__PURE__ */ Symbol("STRICT_GET_METHOD_PLUGIN_IS_GET_METHOD_CONTEXT");
var StrictGetMethodPlugin = class {
  error;
  /**
   * make sure execute before batch plugin to get real method
   */
  order = 7e6;
  constructor(options = {}) {
    this.error = options.error ?? new ORPCError("METHOD_NOT_SUPPORTED");
  }
  init(options) {
    options.rootInterceptors ??= [];
    options.clientInterceptors ??= [];
    options.rootInterceptors.unshift((options2) => {
      const isGetMethod = options2.request.method === "GET";
      return options2.next({
        ...options2,
        context: {
          ...options2.context,
          [STRICT_GET_METHOD_PLUGIN_IS_GET_METHOD_CONTEXT_SYMBOL]: isGetMethod
        }
      });
    });
    options.clientInterceptors.unshift((options2) => {
      if (typeof options2.context[STRICT_GET_METHOD_PLUGIN_IS_GET_METHOD_CONTEXT_SYMBOL] !== "boolean") {
        throw new TypeError("[StrictGetMethodPlugin] strict GET method context has been corrupted or modified by another plugin or interceptor");
      }
      const procedureMethod = fallbackContractConfig("defaultMethod", options2.procedure["~orpc"].route.method);
      if (options2.context[STRICT_GET_METHOD_PLUGIN_IS_GET_METHOD_CONTEXT_SYMBOL] && procedureMethod !== "GET") {
        throw this.error;
      }
      return options2.next();
    });
  }
};

// ../../node_modules/.bun/@orpc+server@1.13.4+64f0629d09b745d9/node_modules/@orpc/server/dist/adapters/fetch/index.mjs
var BodyLimitPlugin = class {
  maxBodySize;
  constructor(options) {
    this.maxBodySize = options.maxBodySize;
  }
  initRuntimeAdapter(options) {
    options.adapterInterceptors ??= [];
    options.adapterInterceptors.push(async (options2) => {
      if (!options2.request.body) {
        return options2.next();
      }
      let currentBodySize = 0;
      const rawReader = options2.request.body.getReader();
      const reader = new ReadableStream({
        start: async (controller) => {
          try {
            if (Number(options2.request.headers.get("content-length")) > this.maxBodySize) {
              controller.error(new ORPCError("PAYLOAD_TOO_LARGE"));
              return;
            }
            while (true) {
              const { done, value: value2 } = await rawReader.read();
              if (done) {
                break;
              }
              currentBodySize += value2.length;
              if (currentBodySize > this.maxBodySize) {
                controller.error(new ORPCError("PAYLOAD_TOO_LARGE"));
                break;
              }
              controller.enqueue(value2);
            }
          } finally {
            controller.close();
          }
        }
      });
      const requestInit = { body: reader, duplex: "half" };
      return options2.next({
        ...options2,
        request: new Request(options2.request, requestInit)
      });
    });
  }
};
var ORDERED_SUPPORTED_ENCODINGS = ["gzip", "deflate"];
var CompressionPlugin = class {
  encodings;
  threshold;
  filter;
  constructor(options = {}) {
    this.encodings = options.encodings ?? ORDERED_SUPPORTED_ENCODINGS;
    this.threshold = options.threshold ?? 1024;
    this.filter = (request, response) => {
      const hasContentDisposition = response.headers.has("content-disposition");
      const contentType = response.headers.get("content-type");
      if (!hasContentDisposition && contentType?.startsWith("text/event-stream")) {
        return false;
      }
      return options.filter ? options.filter(request, response) : isCompressibleContentType(contentType);
    };
  }
  initRuntimeAdapter(options) {
    options.adapterInterceptors ??= [];
    options.adapterInterceptors.unshift(async (options2) => {
      const result = await options2.next();
      if (!result.matched) {
        return result;
      }
      const response = result.response;
      if (response.headers.has("content-encoding") || response.headers.has("transfer-encoding") || isNoTransformCacheControl(response.headers.get("cache-control"))) {
        return result;
      }
      const contentLength = response.headers.get("content-length");
      if (contentLength && Number(contentLength) < this.threshold) {
        return result;
      }
      const acceptEncoding = options2.request.headers.get("accept-encoding")?.split(",").map((enc) => enc.trim().split(";")[0]);
      const encoding = this.encodings.find((enc) => acceptEncoding?.includes(enc));
      if (!response.body || encoding === void 0) {
        return result;
      }
      if (!this.filter(options2.request, response)) {
        return result;
      }
      const compressedBody = response.body.pipeThrough(new CompressionStream(encoding));
      const compressedHeaders = new Headers(response.headers);
      compressedHeaders.delete("content-length");
      compressedHeaders.set("content-encoding", encoding);
      return {
        ...result,
        response: new Response(compressedBody, {
          status: response.status,
          statusText: response.statusText,
          headers: compressedHeaders
        })
      };
    });
  }
};
var COMPRESSIBLE_CONTENT_TYPE_REGEX = /^\s*(?:text\/(?!event-stream(?:[;\s]|$))[^;\s]+|application\/(?:javascript|json|xml|xml-dtd|ecmascript|dart|postscript|rtf|tar|toml|vnd\.dart|vnd\.ms-fontobject|vnd\.ms-opentype|wasm|x-httpd-php|x-javascript|x-ns-proxy-autoconfig|x-sh|x-tar|x-virtualbox-hdd|x-virtualbox-ova|x-virtualbox-ovf|x-virtualbox-vbox|x-virtualbox-vdi|x-virtualbox-vhd|x-virtualbox-vmdk|x-www-form-urlencoded)|font\/(?:otf|ttf)|image\/(?:bmp|vnd\.adobe\.photoshop|vnd\.microsoft\.icon|vnd\.ms-dds|x-icon|x-ms-bmp)|message\/rfc822|model\/gltf-binary|x-shader\/x-fragment|x-shader\/x-vertex|[^;\s]+?\+(?:json|text|xml|yaml))(?:[;\s]|$)/i;
function isCompressibleContentType(contentType) {
  if (contentType === null) {
    return false;
  }
  return COMPRESSIBLE_CONTENT_TYPE_REGEX.test(contentType);
}
var CACHE_CONTROL_NO_TRANSFORM_REGEX = /(?:^|,)\s*no-transform\s*(?:,|$)/i;
function isNoTransformCacheControl(cacheControl) {
  if (cacheControl === null) {
    return false;
  }
  return CACHE_CONTROL_NO_TRANSFORM_REGEX.test(cacheControl);
}
var CompositeFetchHandlerPlugin = class extends CompositeStandardHandlerPlugin {
  initRuntimeAdapter(options) {
    for (const plugin of this.plugins) {
      plugin.initRuntimeAdapter?.(options);
    }
  }
};
var FetchHandler = class {
  constructor(standardHandler, options = {}) {
    this.standardHandler = standardHandler;
    const plugin = new CompositeFetchHandlerPlugin(options.plugins);
    plugin.initRuntimeAdapter(options);
    this.adapterInterceptors = toArray(options.adapterInterceptors);
    this.toFetchResponseOptions = options;
  }
  toFetchResponseOptions;
  adapterInterceptors;
  async handle(request, ...rest) {
    return intercept(
      this.adapterInterceptors,
      {
        ...resolveFriendlyStandardHandleOptions(resolveMaybeOptionalOptions(rest)),
        request,
        toFetchResponseOptions: this.toFetchResponseOptions
      },
      async ({ request: request2, toFetchResponseOptions, ...options }) => {
        const standardRequest = toStandardLazyRequest(request2);
        const result = await this.standardHandler.handle(standardRequest, options);
        if (!result.matched) {
          return result;
        }
        return {
          matched: true,
          response: toFetchResponse(result.response, toFetchResponseOptions)
        };
      }
    );
  }
};
var RPCHandler = class extends FetchHandler {
  constructor(router, options = {}) {
    if (options.strictGetMethodPluginEnabled ?? true) {
      options.plugins ??= [];
      options.plugins.push(new StrictGetMethodPlugin());
    }
    super(new StandardRPCHandler(router, options), options);
  }
};
export {
  BodyLimitPlugin,
  CompositeFetchHandlerPlugin,
  CompressionPlugin,
  FetchHandler,
  RPCHandler
};
//# sourceMappingURL=@orpc_server_fetch.js.map
