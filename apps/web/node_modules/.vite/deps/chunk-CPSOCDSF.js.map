{
  "version": 3,
  "sources": ["../../../../../node_modules/.bun/@orpc+shared@1.13.4+460773ef8ff1e07c/node_modules/@orpc/shared/dist/index.mjs"],
  "sourcesContent": ["export { group, guard, mapEntries, mapValues, omit, retry, sleep } from 'radash';\n\nfunction resolveMaybeOptionalOptions(rest) {\n  return rest[0] ?? {};\n}\n\nfunction toArray(value) {\n  return Array.isArray(value) ? value : value === void 0 || value === null ? [] : [value];\n}\nfunction splitInHalf(arr) {\n  const half = Math.ceil(arr.length / 2);\n  return [arr.slice(0, half), arr.slice(half)];\n}\n\nfunction readAsBuffer(source) {\n  if (typeof source.bytes === \"function\") {\n    return source.bytes();\n  }\n  return source.arrayBuffer();\n}\n\nconst ORPC_NAME = \"orpc\";\nconst ORPC_SHARED_PACKAGE_NAME = \"@orpc/shared\";\nconst ORPC_SHARED_PACKAGE_VERSION = \"1.13.4\";\n\nclass AbortError extends Error {\n  constructor(...rest) {\n    super(...rest);\n    this.name = \"AbortError\";\n  }\n}\n\nfunction once(fn) {\n  let cached;\n  return () => {\n    if (cached) {\n      return cached.result;\n    }\n    const result = fn();\n    cached = { result };\n    return result;\n  };\n}\nfunction sequential(fn) {\n  let lastOperationPromise = Promise.resolve();\n  return (...args) => {\n    return lastOperationPromise = lastOperationPromise.catch(() => {\n    }).then(() => {\n      return fn(...args);\n    });\n  };\n}\nfunction defer(callback) {\n  if (typeof setTimeout === \"function\") {\n    setTimeout(callback, 0);\n  } else {\n    Promise.resolve().then(() => Promise.resolve().then(() => Promise.resolve().then(callback)));\n  }\n}\n\nconst SPAN_ERROR_STATUS = 2;\nconst GLOBAL_OTEL_CONFIG_KEY = `__${ORPC_SHARED_PACKAGE_NAME}@${ORPC_SHARED_PACKAGE_VERSION}/otel/config__`;\nfunction setGlobalOtelConfig(config) {\n  globalThis[GLOBAL_OTEL_CONFIG_KEY] = config;\n}\nfunction getGlobalOtelConfig() {\n  return globalThis[GLOBAL_OTEL_CONFIG_KEY];\n}\nfunction startSpan(name, options = {}, context) {\n  const tracer = getGlobalOtelConfig()?.tracer;\n  return tracer?.startSpan(name, options, context);\n}\nfunction setSpanError(span, error, options = {}) {\n  if (!span) {\n    return;\n  }\n  const exception = toOtelException(error);\n  span.recordException(exception);\n  if (!options.signal?.aborted || options.signal.reason !== error) {\n    span.setStatus({\n      code: SPAN_ERROR_STATUS,\n      message: exception.message\n    });\n  }\n}\nfunction setSpanAttribute(span, key, value) {\n  if (!span || value === void 0) {\n    return;\n  }\n  span.setAttribute(key, value);\n}\nfunction toOtelException(error) {\n  if (error instanceof Error) {\n    const exception = {\n      message: error.message,\n      name: error.name,\n      stack: error.stack\n    };\n    if (\"code\" in error && (typeof error.code === \"string\" || typeof error.code === \"number\")) {\n      exception.code = error.code;\n    }\n    return exception;\n  }\n  return { message: String(error) };\n}\nfunction toSpanAttributeValue(data) {\n  if (data === void 0) {\n    return \"undefined\";\n  }\n  try {\n    return JSON.stringify(data, (_, value) => {\n      if (typeof value === \"bigint\") {\n        return value.toString();\n      }\n      if (value instanceof Map || value instanceof Set) {\n        return Array.from(value);\n      }\n      return value;\n    });\n  } catch {\n    return String(data);\n  }\n}\nasync function runWithSpan({ name, context, ...options }, fn) {\n  const tracer = getGlobalOtelConfig()?.tracer;\n  if (!tracer) {\n    return fn();\n  }\n  const callback = async (span) => {\n    try {\n      return await fn(span);\n    } catch (e) {\n      setSpanError(span, e, options);\n      throw e;\n    } finally {\n      span.end();\n    }\n  };\n  if (context) {\n    return tracer.startActiveSpan(name, options, context, callback);\n  } else {\n    return tracer.startActiveSpan(name, options, callback);\n  }\n}\nasync function runInSpanContext(span, fn) {\n  const otelConfig = getGlobalOtelConfig();\n  if (!span || !otelConfig) {\n    return fn();\n  }\n  const ctx = otelConfig.trace.setSpan(otelConfig.context.active(), span);\n  return otelConfig.context.with(ctx, fn);\n}\n\nclass AsyncIdQueue {\n  openIds = /* @__PURE__ */ new Set();\n  queues = /* @__PURE__ */ new Map();\n  waiters = /* @__PURE__ */ new Map();\n  get length() {\n    return this.openIds.size;\n  }\n  get waiterIds() {\n    return Array.from(this.waiters.keys());\n  }\n  hasBufferedItems(id) {\n    return Boolean(this.queues.get(id)?.length);\n  }\n  open(id) {\n    this.openIds.add(id);\n  }\n  isOpen(id) {\n    return this.openIds.has(id);\n  }\n  push(id, item) {\n    this.assertOpen(id);\n    const pending = this.waiters.get(id);\n    if (pending?.length) {\n      pending.shift()[0](item);\n      if (pending.length === 0) {\n        this.waiters.delete(id);\n      }\n    } else {\n      const items = this.queues.get(id);\n      if (items) {\n        items.push(item);\n      } else {\n        this.queues.set(id, [item]);\n      }\n    }\n  }\n  async pull(id) {\n    this.assertOpen(id);\n    const items = this.queues.get(id);\n    if (items?.length) {\n      const item = items.shift();\n      if (items.length === 0) {\n        this.queues.delete(id);\n      }\n      return item;\n    }\n    return new Promise((resolve, reject) => {\n      const waitingPulls = this.waiters.get(id);\n      const pending = [resolve, reject];\n      if (waitingPulls) {\n        waitingPulls.push(pending);\n      } else {\n        this.waiters.set(id, [pending]);\n      }\n    });\n  }\n  close({ id, reason } = {}) {\n    if (id === void 0) {\n      this.waiters.forEach((pendingPulls, id2) => {\n        const error2 = reason ?? new AbortError(`[AsyncIdQueue] Queue[${id2}] was closed or aborted while waiting for pulling.`);\n        pendingPulls.forEach(([, reject]) => reject(error2));\n      });\n      this.waiters.clear();\n      this.openIds.clear();\n      this.queues.clear();\n      return;\n    }\n    const error = reason ?? new AbortError(`[AsyncIdQueue] Queue[${id}] was closed or aborted while waiting for pulling.`);\n    this.waiters.get(id)?.forEach(([, reject]) => reject(error));\n    this.waiters.delete(id);\n    this.openIds.delete(id);\n    this.queues.delete(id);\n  }\n  assertOpen(id) {\n    if (!this.isOpen(id)) {\n      throw new Error(`[AsyncIdQueue] Cannot access queue[${id}] because it is not open or aborted.`);\n    }\n  }\n}\n\nfunction isAsyncIteratorObject(maybe) {\n  if (!maybe || typeof maybe !== \"object\") {\n    return false;\n  }\n  return \"next\" in maybe && typeof maybe.next === \"function\" && Symbol.asyncIterator in maybe && typeof maybe[Symbol.asyncIterator] === \"function\";\n}\nconst fallbackAsyncDisposeSymbol = Symbol.for(\"asyncDispose\");\nconst asyncDisposeSymbol = Symbol.asyncDispose ?? fallbackAsyncDisposeSymbol;\nclass AsyncIteratorClass {\n  #isDone = false;\n  #isExecuteComplete = false;\n  #cleanup;\n  #next;\n  constructor(next, cleanup) {\n    this.#cleanup = cleanup;\n    this.#next = sequential(async () => {\n      if (this.#isDone) {\n        return { done: true, value: void 0 };\n      }\n      try {\n        const result = await next();\n        if (result.done) {\n          this.#isDone = true;\n        }\n        return result;\n      } catch (err) {\n        this.#isDone = true;\n        throw err;\n      } finally {\n        if (this.#isDone && !this.#isExecuteComplete) {\n          this.#isExecuteComplete = true;\n          await this.#cleanup(\"next\");\n        }\n      }\n    });\n  }\n  next() {\n    return this.#next();\n  }\n  async return(value) {\n    this.#isDone = true;\n    if (!this.#isExecuteComplete) {\n      this.#isExecuteComplete = true;\n      await this.#cleanup(\"return\");\n    }\n    return { done: true, value };\n  }\n  async throw(err) {\n    this.#isDone = true;\n    if (!this.#isExecuteComplete) {\n      this.#isExecuteComplete = true;\n      await this.#cleanup(\"throw\");\n    }\n    throw err;\n  }\n  /**\n   * asyncDispose symbol only available in esnext, we should fallback to Symbol.for('asyncDispose')\n   */\n  async [asyncDisposeSymbol]() {\n    this.#isDone = true;\n    if (!this.#isExecuteComplete) {\n      this.#isExecuteComplete = true;\n      await this.#cleanup(\"dispose\");\n    }\n  }\n  [Symbol.asyncIterator]() {\n    return this;\n  }\n}\nfunction replicateAsyncIterator(source, count) {\n  const queue = new AsyncIdQueue();\n  const ids = Array.from({ length: count }, (_, i) => i.toString());\n  let isSourceFinished = false;\n  const start = once(async () => {\n    try {\n      while (true) {\n        const item = await source.next();\n        ids.forEach((id) => {\n          if (queue.isOpen(id)) {\n            queue.push(id, { next: item });\n          }\n        });\n        if (item.done) {\n          break;\n        }\n      }\n    } catch (error) {\n      ids.forEach((id) => {\n        if (queue.isOpen(id)) {\n          queue.push(id, { error });\n        }\n      });\n    } finally {\n      isSourceFinished = true;\n    }\n  });\n  const replicated = ids.map((id) => {\n    queue.open(id);\n    return new AsyncIteratorClass(\n      async () => {\n        start();\n        const item = await queue.pull(id);\n        if (item.next) {\n          return item.next;\n        }\n        throw item.error;\n      },\n      async (reason) => {\n        queue.close({ id });\n        if (reason !== \"next\" && !queue.length && !isSourceFinished) {\n          isSourceFinished = true;\n          await source?.return?.();\n        }\n      }\n    );\n  });\n  return replicated;\n}\nfunction asyncIteratorWithSpan({ name, ...options }, iterator) {\n  let span;\n  return new AsyncIteratorClass(\n    async () => {\n      span ??= startSpan(name);\n      try {\n        const result = await runInSpanContext(span, () => iterator.next());\n        span?.addEvent(result.done ? \"completed\" : \"yielded\");\n        return result;\n      } catch (err) {\n        setSpanError(span, err, options);\n        throw err;\n      }\n    },\n    async (reason) => {\n      try {\n        if (reason !== \"next\") {\n          await runInSpanContext(span, () => iterator.return?.());\n        }\n      } catch (err) {\n        setSpanError(span, err, options);\n        throw err;\n      } finally {\n        span?.end();\n      }\n    }\n  );\n}\n\nclass EventPublisher {\n  #listenersMap = /* @__PURE__ */ new Map();\n  #maxBufferedEvents;\n  constructor(options = {}) {\n    this.#maxBufferedEvents = options.maxBufferedEvents ?? 100;\n  }\n  get size() {\n    return this.#listenersMap.size;\n  }\n  /**\n   * Emits an event and delivers the payload to all subscribed listeners.\n   */\n  publish(event, payload) {\n    const listeners = this.#listenersMap.get(event);\n    if (!listeners) {\n      return;\n    }\n    for (const listener of listeners) {\n      listener(payload);\n    }\n  }\n  subscribe(event, listenerOrOptions) {\n    if (typeof listenerOrOptions === \"function\") {\n      let listeners = this.#listenersMap.get(event);\n      if (!listeners) {\n        this.#listenersMap.set(event, listeners = []);\n      }\n      listeners.push(listenerOrOptions);\n      return once(() => {\n        listeners.splice(listeners.indexOf(listenerOrOptions), 1);\n        if (listeners.length === 0) {\n          this.#listenersMap.delete(event);\n        }\n      });\n    }\n    const signal = listenerOrOptions?.signal;\n    const maxBufferedEvents = listenerOrOptions?.maxBufferedEvents ?? this.#maxBufferedEvents;\n    signal?.throwIfAborted();\n    const bufferedEvents = [];\n    const pullResolvers = [];\n    const unsubscribe = this.subscribe(event, (payload) => {\n      const resolver = pullResolvers.shift();\n      if (resolver) {\n        resolver[0]({ done: false, value: payload });\n      } else {\n        bufferedEvents.push(payload);\n        if (bufferedEvents.length > maxBufferedEvents) {\n          bufferedEvents.shift();\n        }\n      }\n    });\n    const abortListener = (event2) => {\n      unsubscribe();\n      pullResolvers.forEach((resolver) => resolver[1](event2.target.reason));\n      pullResolvers.length = 0;\n      bufferedEvents.length = 0;\n    };\n    signal?.addEventListener(\"abort\", abortListener, { once: true });\n    return new AsyncIteratorClass(async () => {\n      if (signal?.aborted) {\n        throw signal.reason;\n      }\n      if (bufferedEvents.length > 0) {\n        return { done: false, value: bufferedEvents.shift() };\n      }\n      return new Promise((resolve, reject) => {\n        pullResolvers.push([resolve, reject]);\n      });\n    }, async () => {\n      unsubscribe();\n      signal?.removeEventListener(\"abort\", abortListener);\n      pullResolvers.forEach((resolver) => resolver[0]({ done: true, value: void 0 }));\n      pullResolvers.length = 0;\n      bufferedEvents.length = 0;\n    });\n  }\n}\n\nclass SequentialIdGenerator {\n  index = BigInt(1);\n  generate() {\n    const id = this.index.toString(36);\n    this.index++;\n    return id;\n  }\n}\nfunction compareSequentialIds(a, b) {\n  if (a.length !== b.length) {\n    return a.length - b.length;\n  }\n  return a < b ? -1 : a > b ? 1 : 0;\n}\n\nfunction onStart(callback) {\n  return async (options, ...rest) => {\n    await callback(options, ...rest);\n    return await options.next();\n  };\n}\nfunction onSuccess(callback) {\n  return async (options, ...rest) => {\n    const result = await options.next();\n    await callback(result, options, ...rest);\n    return result;\n  };\n}\nfunction onError(callback) {\n  return async (options, ...rest) => {\n    try {\n      return await options.next();\n    } catch (error) {\n      await callback(error, options, ...rest);\n      throw error;\n    }\n  };\n}\nfunction onFinish(callback) {\n  let state;\n  return async (options, ...rest) => {\n    try {\n      const result = await options.next();\n      state = [null, result, true];\n      return result;\n    } catch (error) {\n      state = [error, void 0, false];\n      throw error;\n    } finally {\n      await callback(state, options, ...rest);\n    }\n  };\n}\nfunction intercept(interceptors, options, main) {\n  const next = (options2, index) => {\n    const interceptor = interceptors[index];\n    if (!interceptor) {\n      return main(options2);\n    }\n    return interceptor({\n      ...options2,\n      next: (newOptions = options2) => next(newOptions, index + 1)\n    });\n  };\n  return next(options, 0);\n}\n\nfunction parseEmptyableJSON(text) {\n  if (!text) {\n    return void 0;\n  }\n  return JSON.parse(text);\n}\nfunction stringifyJSON(value) {\n  return JSON.stringify(value);\n}\n\nfunction findDeepMatches(check, payload, segments = [], maps = [], values = []) {\n  if (check(payload)) {\n    maps.push(segments);\n    values.push(payload);\n  } else if (Array.isArray(payload)) {\n    payload.forEach((v, i) => {\n      findDeepMatches(check, v, [...segments, i], maps, values);\n    });\n  } else if (isObject(payload)) {\n    for (const key in payload) {\n      findDeepMatches(check, payload[key], [...segments, key], maps, values);\n    }\n  }\n  return { maps, values };\n}\nfunction getConstructor(value) {\n  if (!isTypescriptObject(value)) {\n    return null;\n  }\n  return Object.getPrototypeOf(value)?.constructor;\n}\nfunction isObject(value) {\n  if (!value || typeof value !== \"object\") {\n    return false;\n  }\n  const proto = Object.getPrototypeOf(value);\n  return proto === Object.prototype || !proto || !proto.constructor;\n}\nfunction isTypescriptObject(value) {\n  return !!value && (typeof value === \"object\" || typeof value === \"function\");\n}\nfunction clone(value) {\n  if (Array.isArray(value)) {\n    return value.map(clone);\n  }\n  if (isObject(value)) {\n    const result = {};\n    for (const key in value) {\n      result[key] = clone(value[key]);\n    }\n    for (const sym of Object.getOwnPropertySymbols(value)) {\n      result[sym] = clone(value[sym]);\n    }\n    return result;\n  }\n  return value;\n}\nfunction get(object, path) {\n  let current = object;\n  for (const key of path) {\n    if (!isTypescriptObject(current)) {\n      return void 0;\n    }\n    current = current[key];\n  }\n  return current;\n}\nfunction isPropertyKey(value) {\n  const type = typeof value;\n  return type === \"string\" || type === \"number\" || type === \"symbol\";\n}\nconst NullProtoObj = /* @__PURE__ */ (() => {\n  const e = function() {\n  };\n  e.prototype = /* @__PURE__ */ Object.create(null);\n  Object.freeze(e.prototype);\n  return e;\n})();\n\nfunction value(value2, ...args) {\n  if (typeof value2 === \"function\") {\n    return value2(...args);\n  }\n  return value2;\n}\nfunction fallback(value2, fallback2) {\n  return value2 === void 0 ? fallback2 : value2;\n}\n\nfunction preventNativeAwait(target) {\n  return new Proxy(target, {\n    get(target2, prop, receiver) {\n      const value2 = Reflect.get(target2, prop, receiver);\n      if (prop !== \"then\" || typeof value2 !== \"function\") {\n        return value2;\n      }\n      return new Proxy(value2, {\n        apply(targetFn, thisArg, args) {\n          if (args.length !== 2 || args.some((arg) => !isNativeFunction(arg))) {\n            return Reflect.apply(targetFn, thisArg, args);\n          }\n          let shouldOmit = true;\n          args[0].call(thisArg, preventNativeAwait(new Proxy(target2, {\n            get: (target3, prop2, receiver2) => {\n              if (shouldOmit && prop2 === \"then\") {\n                shouldOmit = false;\n                return void 0;\n              }\n              return Reflect.get(target3, prop2, receiver2);\n            }\n          })));\n        }\n      });\n    }\n  });\n}\nconst NATIVE_FUNCTION_REGEX = /^\\s*function\\s*\\(\\)\\s*\\{\\s*\\[native code\\]\\s*\\}\\s*$/;\nfunction isNativeFunction(fn) {\n  return typeof fn === \"function\" && NATIVE_FUNCTION_REGEX.test(fn.toString());\n}\nfunction overlayProxy(target, partial) {\n  const proxy = new Proxy(typeof target === \"function\" ? partial : target, {\n    get(_, prop) {\n      const targetValue = prop in partial ? partial : value(target);\n      const v = Reflect.get(targetValue, prop);\n      return typeof v === \"function\" ? v.bind(targetValue) : v;\n    },\n    has(_, prop) {\n      return Reflect.has(partial, prop) || Reflect.has(value(target), prop);\n    }\n  });\n  return proxy;\n}\n\nfunction streamToAsyncIteratorClass(stream) {\n  const reader = stream.getReader();\n  return new AsyncIteratorClass(\n    async () => {\n      return reader.read();\n    },\n    async () => {\n      await reader.cancel();\n    }\n  );\n}\nfunction asyncIteratorToStream(iterator) {\n  return new ReadableStream({\n    async pull(controller) {\n      const { done, value } = await iterator.next();\n      if (done) {\n        controller.close();\n      } else {\n        controller.enqueue(value);\n      }\n    },\n    async cancel() {\n      await iterator.return?.();\n    }\n  });\n}\nfunction asyncIteratorToUnproxiedDataStream(iterator) {\n  return new ReadableStream({\n    async pull(controller) {\n      const { done, value } = await iterator.next();\n      if (done) {\n        controller.close();\n      } else {\n        const unproxied = isObject(value) ? { ...value } : Array.isArray(value) ? value.map((i) => i) : value;\n        controller.enqueue(unproxied);\n      }\n    },\n    async cancel() {\n      await iterator.return?.();\n    }\n  });\n}\n\nfunction tryDecodeURIComponent(value) {\n  try {\n    return decodeURIComponent(value);\n  } catch {\n    return value;\n  }\n}\n\nexport { AbortError, AsyncIdQueue, AsyncIteratorClass, EventPublisher, NullProtoObj, ORPC_NAME, ORPC_SHARED_PACKAGE_NAME, ORPC_SHARED_PACKAGE_VERSION, SequentialIdGenerator, asyncIteratorToStream, asyncIteratorToUnproxiedDataStream, asyncIteratorWithSpan, clone, compareSequentialIds, defer, fallback, findDeepMatches, get, getConstructor, getGlobalOtelConfig, intercept, isAsyncIteratorObject, isObject, isPropertyKey, isTypescriptObject, onError, onFinish, onStart, onSuccess, once, overlayProxy, parseEmptyableJSON, preventNativeAwait, readAsBuffer, replicateAsyncIterator, resolveMaybeOptionalOptions, runInSpanContext, runWithSpan, sequential, setGlobalOtelConfig, setSpanAttribute, setSpanError, splitInHalf, startSpan, streamToAsyncIteratorClass, stringifyJSON, toArray, toOtelException, toSpanAttributeValue, tryDecodeURIComponent, value };\n"],
  "mappings": ";AAEA,SAAS,4BAA4B,MAAM;AACzC,SAAO,KAAK,CAAC,KAAK,CAAC;AACrB;AAEA,SAAS,QAAQA,QAAO;AACtB,SAAO,MAAM,QAAQA,MAAK,IAAIA,SAAQA,WAAU,UAAUA,WAAU,OAAO,CAAC,IAAI,CAACA,MAAK;AACxF;AAaA,IAAM,YAAY;AAClB,IAAM,2BAA2B;AACjC,IAAM,8BAA8B;AAEpC,IAAM,aAAN,cAAyB,MAAM;AAAA,EAC7B,eAAe,MAAM;AACnB,UAAM,GAAG,IAAI;AACb,SAAK,OAAO;AAAA,EACd;AACF;AAEA,SAAS,KAAK,IAAI;AAChB,MAAI;AACJ,SAAO,MAAM;AACX,QAAI,QAAQ;AACV,aAAO,OAAO;AAAA,IAChB;AACA,UAAM,SAAS,GAAG;AAClB,aAAS,EAAE,OAAO;AAClB,WAAO;AAAA,EACT;AACF;AACA,SAAS,WAAW,IAAI;AACtB,MAAI,uBAAuB,QAAQ,QAAQ;AAC3C,SAAO,IAAI,SAAS;AAClB,WAAO,uBAAuB,qBAAqB,MAAM,MAAM;AAAA,IAC/D,CAAC,EAAE,KAAK,MAAM;AACZ,aAAO,GAAG,GAAG,IAAI;AAAA,IACnB,CAAC;AAAA,EACH;AACF;AASA,IAAM,oBAAoB;AAC1B,IAAM,yBAAyB,KAAK,wBAAwB,IAAI,2BAA2B;AAI3F,SAAS,sBAAsB;AAC7B,SAAO,WAAW,sBAAsB;AAC1C;AACA,SAAS,UAAU,MAAM,UAAU,CAAC,GAAG,SAAS;AAC9C,QAAM,SAAS,oBAAoB,GAAG;AACtC,SAAO,QAAQ,UAAU,MAAM,SAAS,OAAO;AACjD;AACA,SAAS,aAAa,MAAM,OAAO,UAAU,CAAC,GAAG;AAC/C,MAAI,CAAC,MAAM;AACT;AAAA,EACF;AACA,QAAM,YAAY,gBAAgB,KAAK;AACvC,OAAK,gBAAgB,SAAS;AAC9B,MAAI,CAAC,QAAQ,QAAQ,WAAW,QAAQ,OAAO,WAAW,OAAO;AAC/D,SAAK,UAAU;AAAA,MACb,MAAM;AAAA,MACN,SAAS,UAAU;AAAA,IACrB,CAAC;AAAA,EACH;AACF;AAOA,SAAS,gBAAgB,OAAO;AAC9B,MAAI,iBAAiB,OAAO;AAC1B,UAAM,YAAY;AAAA,MAChB,SAAS,MAAM;AAAA,MACf,MAAM,MAAM;AAAA,MACZ,OAAO,MAAM;AAAA,IACf;AACA,QAAI,UAAU,UAAU,OAAO,MAAM,SAAS,YAAY,OAAO,MAAM,SAAS,WAAW;AACzF,gBAAU,OAAO,MAAM;AAAA,IACzB;AACA,WAAO;AAAA,EACT;AACA,SAAO,EAAE,SAAS,OAAO,KAAK,EAAE;AAClC;AAmBA,eAAe,YAAY,EAAE,MAAM,SAAS,GAAG,QAAQ,GAAG,IAAI;AAC5D,QAAM,SAAS,oBAAoB,GAAG;AACtC,MAAI,CAAC,QAAQ;AACX,WAAO,GAAG;AAAA,EACZ;AACA,QAAM,WAAW,OAAO,SAAS;AAC/B,QAAI;AACF,aAAO,MAAM,GAAG,IAAI;AAAA,IACtB,SAAS,GAAG;AACV,mBAAa,MAAM,GAAG,OAAO;AAC7B,YAAM;AAAA,IACR,UAAE;AACA,WAAK,IAAI;AAAA,IACX;AAAA,EACF;AACA,MAAI,SAAS;AACX,WAAO,OAAO,gBAAgB,MAAM,SAAS,SAAS,QAAQ;AAAA,EAChE,OAAO;AACL,WAAO,OAAO,gBAAgB,MAAM,SAAS,QAAQ;AAAA,EACvD;AACF;AACA,eAAe,iBAAiB,MAAM,IAAI;AACxC,QAAM,aAAa,oBAAoB;AACvC,MAAI,CAAC,QAAQ,CAAC,YAAY;AACxB,WAAO,GAAG;AAAA,EACZ;AACA,QAAM,MAAM,WAAW,MAAM,QAAQ,WAAW,QAAQ,OAAO,GAAG,IAAI;AACtE,SAAO,WAAW,QAAQ,KAAK,KAAK,EAAE;AACxC;AAkFA,SAAS,sBAAsB,OAAO;AACpC,MAAI,CAAC,SAAS,OAAO,UAAU,UAAU;AACvC,WAAO;AAAA,EACT;AACA,SAAO,UAAU,SAAS,OAAO,MAAM,SAAS,cAAc,OAAO,iBAAiB,SAAS,OAAO,MAAM,OAAO,aAAa,MAAM;AACxI;AACA,IAAM,6BAA6B,uBAAO,IAAI,cAAc;AAC5D,IAAM,qBAAqB,OAAO,gBAAgB;AAClD,IAAM,qBAAN,MAAyB;AAAA,EACvB,UAAU;AAAA,EACV,qBAAqB;AAAA,EACrB;AAAA,EACA;AAAA,EACA,YAAY,MAAM,SAAS;AACzB,SAAK,WAAW;AAChB,SAAK,QAAQ,WAAW,YAAY;AAClC,UAAI,KAAK,SAAS;AAChB,eAAO,EAAE,MAAM,MAAM,OAAO,OAAO;AAAA,MACrC;AACA,UAAI;AACF,cAAM,SAAS,MAAM,KAAK;AAC1B,YAAI,OAAO,MAAM;AACf,eAAK,UAAU;AAAA,QACjB;AACA,eAAO;AAAA,MACT,SAAS,KAAK;AACZ,aAAK,UAAU;AACf,cAAM;AAAA,MACR,UAAE;AACA,YAAI,KAAK,WAAW,CAAC,KAAK,oBAAoB;AAC5C,eAAK,qBAAqB;AAC1B,gBAAM,KAAK,SAAS,MAAM;AAAA,QAC5B;AAAA,MACF;AAAA,IACF,CAAC;AAAA,EACH;AAAA,EACA,OAAO;AACL,WAAO,KAAK,MAAM;AAAA,EACpB;AAAA,EACA,MAAM,OAAOC,QAAO;AAClB,SAAK,UAAU;AACf,QAAI,CAAC,KAAK,oBAAoB;AAC5B,WAAK,qBAAqB;AAC1B,YAAM,KAAK,SAAS,QAAQ;AAAA,IAC9B;AACA,WAAO,EAAE,MAAM,MAAM,OAAAA,OAAM;AAAA,EAC7B;AAAA,EACA,MAAM,MAAM,KAAK;AACf,SAAK,UAAU;AACf,QAAI,CAAC,KAAK,oBAAoB;AAC5B,WAAK,qBAAqB;AAC1B,YAAM,KAAK,SAAS,OAAO;AAAA,IAC7B;AACA,UAAM;AAAA,EACR;AAAA;AAAA;AAAA;AAAA,EAIA,OAAO,kBAAkB,IAAI;AAC3B,SAAK,UAAU;AACf,QAAI,CAAC,KAAK,oBAAoB;AAC5B,WAAK,qBAAqB;AAC1B,YAAM,KAAK,SAAS,SAAS;AAAA,IAC/B;AAAA,EACF;AAAA,EACA,CAAC,OAAO,aAAa,IAAI;AACvB,WAAO;AAAA,EACT;AACF;AAkDA,SAAS,sBAAsB,EAAE,MAAM,GAAG,QAAQ,GAAG,UAAU;AAC7D,MAAI;AACJ,SAAO,IAAI;AAAA,IACT,YAAY;AACV,eAAS,UAAU,IAAI;AACvB,UAAI;AACF,cAAM,SAAS,MAAM,iBAAiB,MAAM,MAAM,SAAS,KAAK,CAAC;AACjE,cAAM,SAAS,OAAO,OAAO,cAAc,SAAS;AACpD,eAAO;AAAA,MACT,SAAS,KAAK;AACZ,qBAAa,MAAM,KAAK,OAAO;AAC/B,cAAM;AAAA,MACR;AAAA,IACF;AAAA,IACA,OAAO,WAAW;AAChB,UAAI;AACF,YAAI,WAAW,QAAQ;AACrB,gBAAM,iBAAiB,MAAM,MAAM,SAAS,SAAS,CAAC;AAAA,QACxD;AAAA,MACF,SAAS,KAAK;AACZ,qBAAa,MAAM,KAAK,OAAO;AAC/B,cAAM;AAAA,MACR,UAAE;AACA,cAAM,IAAI;AAAA,MACZ;AAAA,IACF;AAAA,EACF;AACF;AAEA,IAAM,iBAAN,MAAqB;AAAA,EACnB,gBAAgC,oBAAI,IAAI;AAAA,EACxC;AAAA,EACA,YAAY,UAAU,CAAC,GAAG;AACxB,SAAK,qBAAqB,QAAQ,qBAAqB;AAAA,EACzD;AAAA,EACA,IAAI,OAAO;AACT,WAAO,KAAK,cAAc;AAAA,EAC5B;AAAA;AAAA;AAAA;AAAA,EAIA,QAAQ,OAAO,SAAS;AACtB,UAAM,YAAY,KAAK,cAAc,IAAI,KAAK;AAC9C,QAAI,CAAC,WAAW;AACd;AAAA,IACF;AACA,eAAW,YAAY,WAAW;AAChC,eAAS,OAAO;AAAA,IAClB;AAAA,EACF;AAAA,EACA,UAAU,OAAO,mBAAmB;AAClC,QAAI,OAAO,sBAAsB,YAAY;AAC3C,UAAI,YAAY,KAAK,cAAc,IAAI,KAAK;AAC5C,UAAI,CAAC,WAAW;AACd,aAAK,cAAc,IAAI,OAAO,YAAY,CAAC,CAAC;AAAA,MAC9C;AACA,gBAAU,KAAK,iBAAiB;AAChC,aAAO,KAAK,MAAM;AAChB,kBAAU,OAAO,UAAU,QAAQ,iBAAiB,GAAG,CAAC;AACxD,YAAI,UAAU,WAAW,GAAG;AAC1B,eAAK,cAAc,OAAO,KAAK;AAAA,QACjC;AAAA,MACF,CAAC;AAAA,IACH;AACA,UAAM,SAAS,mBAAmB;AAClC,UAAM,oBAAoB,mBAAmB,qBAAqB,KAAK;AACvE,YAAQ,eAAe;AACvB,UAAM,iBAAiB,CAAC;AACxB,UAAM,gBAAgB,CAAC;AACvB,UAAM,cAAc,KAAK,UAAU,OAAO,CAAC,YAAY;AACrD,YAAM,WAAW,cAAc,MAAM;AACrC,UAAI,UAAU;AACZ,iBAAS,CAAC,EAAE,EAAE,MAAM,OAAO,OAAO,QAAQ,CAAC;AAAA,MAC7C,OAAO;AACL,uBAAe,KAAK,OAAO;AAC3B,YAAI,eAAe,SAAS,mBAAmB;AAC7C,yBAAe,MAAM;AAAA,QACvB;AAAA,MACF;AAAA,IACF,CAAC;AACD,UAAM,gBAAgB,CAAC,WAAW;AAChC,kBAAY;AACZ,oBAAc,QAAQ,CAAC,aAAa,SAAS,CAAC,EAAE,OAAO,OAAO,MAAM,CAAC;AACrE,oBAAc,SAAS;AACvB,qBAAe,SAAS;AAAA,IAC1B;AACA,YAAQ,iBAAiB,SAAS,eAAe,EAAE,MAAM,KAAK,CAAC;AAC/D,WAAO,IAAI,mBAAmB,YAAY;AACxC,UAAI,QAAQ,SAAS;AACnB,cAAM,OAAO;AAAA,MACf;AACA,UAAI,eAAe,SAAS,GAAG;AAC7B,eAAO,EAAE,MAAM,OAAO,OAAO,eAAe,MAAM,EAAE;AAAA,MACtD;AACA,aAAO,IAAI,QAAQ,CAAC,SAAS,WAAW;AACtC,sBAAc,KAAK,CAAC,SAAS,MAAM,CAAC;AAAA,MACtC,CAAC;AAAA,IACH,GAAG,YAAY;AACb,kBAAY;AACZ,cAAQ,oBAAoB,SAAS,aAAa;AAClD,oBAAc,QAAQ,CAAC,aAAa,SAAS,CAAC,EAAE,EAAE,MAAM,MAAM,OAAO,OAAO,CAAC,CAAC;AAC9E,oBAAc,SAAS;AACvB,qBAAe,SAAS;AAAA,IAC1B,CAAC;AAAA,EACH;AACF;AAiBA,SAAS,QAAQ,UAAU;AACzB,SAAO,OAAO,YAAY,SAAS;AACjC,UAAM,SAAS,SAAS,GAAG,IAAI;AAC/B,WAAO,MAAM,QAAQ,KAAK;AAAA,EAC5B;AACF;AACA,SAAS,UAAU,UAAU;AAC3B,SAAO,OAAO,YAAY,SAAS;AACjC,UAAM,SAAS,MAAM,QAAQ,KAAK;AAClC,UAAM,SAAS,QAAQ,SAAS,GAAG,IAAI;AACvC,WAAO;AAAA,EACT;AACF;AACA,SAAS,QAAQ,UAAU;AACzB,SAAO,OAAO,YAAY,SAAS;AACjC,QAAI;AACF,aAAO,MAAM,QAAQ,KAAK;AAAA,IAC5B,SAAS,OAAO;AACd,YAAM,SAAS,OAAO,SAAS,GAAG,IAAI;AACtC,YAAM;AAAA,IACR;AAAA,EACF;AACF;AACA,SAAS,SAAS,UAAU;AAC1B,MAAI;AACJ,SAAO,OAAO,YAAY,SAAS;AACjC,QAAI;AACF,YAAM,SAAS,MAAM,QAAQ,KAAK;AAClC,cAAQ,CAAC,MAAM,QAAQ,IAAI;AAC3B,aAAO;AAAA,IACT,SAAS,OAAO;AACd,cAAQ,CAAC,OAAO,QAAQ,KAAK;AAC7B,YAAM;AAAA,IACR,UAAE;AACA,YAAM,SAAS,OAAO,SAAS,GAAG,IAAI;AAAA,IACxC;AAAA,EACF;AACF;AACA,SAAS,UAAU,cAAc,SAAS,MAAM;AAC9C,QAAM,OAAO,CAAC,UAAU,UAAU;AAChC,UAAM,cAAc,aAAa,KAAK;AACtC,QAAI,CAAC,aAAa;AAChB,aAAO,KAAK,QAAQ;AAAA,IACtB;AACA,WAAO,YAAY;AAAA,MACjB,GAAG;AAAA,MACH,MAAM,CAAC,aAAa,aAAa,KAAK,YAAY,QAAQ,CAAC;AAAA,IAC7D,CAAC;AAAA,EACH;AACA,SAAO,KAAK,SAAS,CAAC;AACxB;AAEA,SAAS,mBAAmB,MAAM;AAChC,MAAI,CAAC,MAAM;AACT,WAAO;AAAA,EACT;AACA,SAAO,KAAK,MAAM,IAAI;AACxB;AACA,SAAS,cAAcC,QAAO;AAC5B,SAAO,KAAK,UAAUA,MAAK;AAC7B;AAiBA,SAAS,eAAeC,QAAO;AAC7B,MAAI,CAAC,mBAAmBA,MAAK,GAAG;AAC9B,WAAO;AAAA,EACT;AACA,SAAO,OAAO,eAAeA,MAAK,GAAG;AACvC;AACA,SAASC,UAASD,QAAO;AACvB,MAAI,CAACA,UAAS,OAAOA,WAAU,UAAU;AACvC,WAAO;AAAA,EACT;AACA,QAAM,QAAQ,OAAO,eAAeA,MAAK;AACzC,SAAO,UAAU,OAAO,aAAa,CAAC,SAAS,CAAC,MAAM;AACxD;AACA,SAAS,mBAAmBA,QAAO;AACjC,SAAO,CAAC,CAACA,WAAU,OAAOA,WAAU,YAAY,OAAOA,WAAU;AACnE;AAiBA,SAASE,KAAI,QAAQ,MAAM;AACzB,MAAI,UAAU;AACd,aAAW,OAAO,MAAM;AACtB,QAAI,CAAC,mBAAmB,OAAO,GAAG;AAChC,aAAO;AAAA,IACT;AACA,cAAU,QAAQ,GAAG;AAAA,EACvB;AACA,SAAO;AACT;AAKA,IAAM,gBAAgC,MAAM;AAC1C,QAAM,IAAI,WAAW;AAAA,EACrB;AACA,IAAE,YAA4B,uBAAO,OAAO,IAAI;AAChD,SAAO,OAAO,EAAE,SAAS;AACzB,SAAO;AACT,GAAG;AAEH,SAAS,MAAM,WAAW,MAAM;AAC9B,MAAI,OAAO,WAAW,YAAY;AAChC,WAAO,OAAO,GAAG,IAAI;AAAA,EACvB;AACA,SAAO;AACT;AAKA,SAAS,mBAAmB,QAAQ;AAClC,SAAO,IAAI,MAAM,QAAQ;AAAA,IACvB,IAAI,SAAS,MAAM,UAAU;AAC3B,YAAM,SAAS,QAAQ,IAAI,SAAS,MAAM,QAAQ;AAClD,UAAI,SAAS,UAAU,OAAO,WAAW,YAAY;AACnD,eAAO;AAAA,MACT;AACA,aAAO,IAAI,MAAM,QAAQ;AAAA,QACvB,MAAM,UAAU,SAAS,MAAM;AAC7B,cAAI,KAAK,WAAW,KAAK,KAAK,KAAK,CAAC,QAAQ,CAAC,iBAAiB,GAAG,CAAC,GAAG;AACnE,mBAAO,QAAQ,MAAM,UAAU,SAAS,IAAI;AAAA,UAC9C;AACA,cAAI,aAAa;AACjB,eAAK,CAAC,EAAE,KAAK,SAAS,mBAAmB,IAAI,MAAM,SAAS;AAAA,YAC1D,KAAK,CAAC,SAAS,OAAO,cAAc;AAClC,kBAAI,cAAc,UAAU,QAAQ;AAClC,6BAAa;AACb,uBAAO;AAAA,cACT;AACA,qBAAO,QAAQ,IAAI,SAAS,OAAO,SAAS;AAAA,YAC9C;AAAA,UACF,CAAC,CAAC,CAAC;AAAA,QACL;AAAA,MACF,CAAC;AAAA,IACH;AAAA,EACF,CAAC;AACH;AACA,IAAM,wBAAwB;AAC9B,SAAS,iBAAiB,IAAI;AAC5B,SAAO,OAAO,OAAO,cAAc,sBAAsB,KAAK,GAAG,SAAS,CAAC;AAC7E;AAeA,SAAS,2BAA2B,QAAQ;AAC1C,QAAM,SAAS,OAAO,UAAU;AAChC,SAAO,IAAI;AAAA,IACT,YAAY;AACV,aAAO,OAAO,KAAK;AAAA,IACrB;AAAA,IACA,YAAY;AACV,YAAM,OAAO,OAAO;AAAA,IACtB;AAAA,EACF;AACF;AACA,SAAS,sBAAsB,UAAU;AACvC,SAAO,IAAI,eAAe;AAAA,IACxB,MAAM,KAAK,YAAY;AACrB,YAAM,EAAE,MAAM,OAAAC,OAAM,IAAI,MAAM,SAAS,KAAK;AAC5C,UAAI,MAAM;AACR,mBAAW,MAAM;AAAA,MACnB,OAAO;AACL,mBAAW,QAAQA,MAAK;AAAA,MAC1B;AAAA,IACF;AAAA,IACA,MAAM,SAAS;AACb,YAAM,SAAS,SAAS;AAAA,IAC1B;AAAA,EACF,CAAC;AACH;AACA,SAAS,mCAAmC,UAAU;AACpD,SAAO,IAAI,eAAe;AAAA,IACxB,MAAM,KAAK,YAAY;AACrB,YAAM,EAAE,MAAM,OAAAA,OAAM,IAAI,MAAM,SAAS,KAAK;AAC5C,UAAI,MAAM;AACR,mBAAW,MAAM;AAAA,MACnB,OAAO;AACL,cAAM,YAAYC,UAASD,MAAK,IAAI,EAAE,GAAGA,OAAM,IAAI,MAAM,QAAQA,MAAK,IAAIA,OAAM,IAAI,CAAC,MAAM,CAAC,IAAIA;AAChG,mBAAW,QAAQ,SAAS;AAAA,MAC9B;AAAA,IACF;AAAA,IACA,MAAM,SAAS;AACb,YAAM,SAAS,SAAS;AAAA,IAC1B;AAAA,EACF,CAAC;AACH;AAEA,SAAS,sBAAsBA,QAAO;AACpC,MAAI;AACF,WAAO,mBAAmBA,MAAK;AAAA,EACjC,QAAQ;AACN,WAAOA;AAAA,EACT;AACF;",
  "names": ["value", "value", "value", "value", "isObject", "get", "value", "isObject"]
}
